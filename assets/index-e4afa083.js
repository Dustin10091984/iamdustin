(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) i(a);
  new MutationObserver((a) => {
    for (const d of a)
      if (d.type === "childList")
        for (const M of d.addedNodes)
          M.tagName === "LINK" && M.rel === "modulepreload" && i(M);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(a) {
    const d = {};
    return (
      a.integrity && (d.integrity = a.integrity),
      a.referrerPolicy && (d.referrerPolicy = a.referrerPolicy),
      a.crossOrigin === "use-credentials"
        ? (d.credentials = "include")
        : a.crossOrigin === "anonymous"
        ? (d.credentials = "omit")
        : (d.credentials = "same-origin"),
      d
    );
  }
  function i(a) {
    if (a.ep) return;
    a.ep = !0;
    const d = n(a);
    fetch(a.href, d);
  }
})();
var Hl =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Ci(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var Ul = { exports: {} },
  Vs = {},
  Gl = { exports: {} },
  bt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Un = Symbol.for("react.element"),
  ad = Symbol.for("react.portal"),
  ld = Symbol.for("react.fragment"),
  hd = Symbol.for("react.strict_mode"),
  cd = Symbol.for("react.profiler"),
  dd = Symbol.for("react.provider"),
  ud = Symbol.for("react.context"),
  pd = Symbol.for("react.forward_ref"),
  fd = Symbol.for("react.suspense"),
  gd = Symbol.for("react.memo"),
  md = Symbol.for("react.lazy"),
  Pa = Symbol.iterator;
function yd(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Pa && t[Pa]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var Xl = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Wl = Object.assign,
  Yl = {};
function Ji(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = Yl),
    (this.updater = n || Xl);
}
Ji.prototype.isReactComponent = {};
Ji.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
Ji.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function _l() {}
_l.prototype = Ji.prototype;
function jr(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = Yl),
    (this.updater = n || Xl);
}
var Nr = (jr.prototype = new _l());
Nr.constructor = jr;
Wl(Nr, Ji.prototype);
Nr.isPureReactComponent = !0;
var Aa = Array.isArray,
  Vl = Object.prototype.hasOwnProperty,
  Or = { current: null },
  ql = { key: !0, ref: !0, __self: !0, __source: !0 };
function Kl(t, e, n) {
  var i,
    a = {},
    d = null,
    M = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (M = e.ref),
    e.key !== void 0 && (d = "" + e.key),
    e))
      Vl.call(e, i) && !ql.hasOwnProperty(i) && (a[i] = e[i]);
  var O = arguments.length - 2;
  if (O === 1) a.children = n;
  else if (1 < O) {
    for (var B = Array(O), G = 0; G < O; G++) B[G] = arguments[G + 2];
    a.children = B;
  }
  if (t && t.defaultProps)
    for (i in ((O = t.defaultProps), O)) a[i] === void 0 && (a[i] = O[i]);
  return {
    $$typeof: Un,
    type: t,
    key: d,
    ref: M,
    props: a,
    _owner: Or.current,
  };
}
function xd(t, e) {
  return {
    $$typeof: Un,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function Ir(t) {
  return typeof t == "object" && t !== null && t.$$typeof === Un;
}
function vd(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var Ta = /\/+/g;
function ho(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? vd("" + t.key)
    : e.toString(36);
}
function ds(t, e, n, i, a) {
  var d = typeof t;
  (d === "undefined" || d === "boolean") && (t = null);
  var M = !1;
  if (t === null) M = !0;
  else
    switch (d) {
      case "string":
      case "number":
        M = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case Un:
          case ad:
            M = !0;
        }
    }
  if (M)
    return (
      (M = t),
      (a = a(M)),
      (t = i === "" ? "." + ho(M, 0) : i),
      Aa(a)
        ? ((n = ""),
          t != null && (n = t.replace(Ta, "$&/") + "/"),
          ds(a, e, n, "", function (G) {
            return G;
          }))
        : a != null &&
          (Ir(a) &&
            (a = xd(
              a,
              n +
                (!a.key || (M && M.key === a.key)
                  ? ""
                  : ("" + a.key).replace(Ta, "$&/") + "/") +
                t
            )),
          e.push(a)),
      1
    );
  if (((M = 0), (i = i === "" ? "." : i + ":"), Aa(t)))
    for (var O = 0; O < t.length; O++) {
      d = t[O];
      var B = i + ho(d, O);
      M += ds(d, e, n, B, a);
    }
  else if (((B = yd(t)), typeof B == "function"))
    for (t = B.call(t), O = 0; !(d = t.next()).done; )
      (d = d.value), (B = i + ho(d, O++)), (M += ds(d, e, n, B, a));
  else if (d === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return M;
}
function Vn(t, e, n) {
  if (t == null) return t;
  var i = [],
    a = 0;
  return (
    ds(t, i, "", "", function (d) {
      return e.call(n, d, a++);
    }),
    i
  );
}
function Sd(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var ie = { current: null },
  us = { transition: null },
  wd = {
    ReactCurrentDispatcher: ie,
    ReactCurrentBatchConfig: us,
    ReactCurrentOwner: Or,
  };
bt.Children = {
  map: Vn,
  forEach: function (t, e, n) {
    Vn(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      Vn(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      Vn(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!Ir(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
bt.Component = Ji;
bt.Fragment = ld;
bt.Profiler = cd;
bt.PureComponent = jr;
bt.StrictMode = hd;
bt.Suspense = fd;
bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = wd;
bt.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var i = Wl({}, t.props),
    a = t.key,
    d = t.ref,
    M = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((d = e.ref), (M = Or.current)),
      e.key !== void 0 && (a = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var O = t.type.defaultProps;
    for (B in e)
      Vl.call(e, B) &&
        !ql.hasOwnProperty(B) &&
        (i[B] = e[B] === void 0 && O !== void 0 ? O[B] : e[B]);
  }
  var B = arguments.length - 2;
  if (B === 1) i.children = n;
  else if (1 < B) {
    O = Array(B);
    for (var G = 0; G < B; G++) O[G] = arguments[G + 2];
    i.children = O;
  }
  return { $$typeof: Un, type: t.type, key: a, ref: d, props: i, _owner: M };
};
bt.createContext = function (t) {
  return (
    (t = {
      $$typeof: ud,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: dd, _context: t }),
    (t.Consumer = t)
  );
};
bt.createElement = Kl;
bt.createFactory = function (t) {
  var e = Kl.bind(null, t);
  return (e.type = t), e;
};
bt.createRef = function () {
  return { current: null };
};
bt.forwardRef = function (t) {
  return { $$typeof: pd, render: t };
};
bt.isValidElement = Ir;
bt.lazy = function (t) {
  return { $$typeof: md, _payload: { _status: -1, _result: t }, _init: Sd };
};
bt.memo = function (t, e) {
  return { $$typeof: gd, type: t, compare: e === void 0 ? null : e };
};
bt.startTransition = function (t) {
  var e = us.transition;
  us.transition = {};
  try {
    t();
  } finally {
    us.transition = e;
  }
};
bt.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
bt.useCallback = function (t, e) {
  return ie.current.useCallback(t, e);
};
bt.useContext = function (t) {
  return ie.current.useContext(t);
};
bt.useDebugValue = function () {};
bt.useDeferredValue = function (t) {
  return ie.current.useDeferredValue(t);
};
bt.useEffect = function (t, e) {
  return ie.current.useEffect(t, e);
};
bt.useId = function () {
  return ie.current.useId();
};
bt.useImperativeHandle = function (t, e, n) {
  return ie.current.useImperativeHandle(t, e, n);
};
bt.useInsertionEffect = function (t, e) {
  return ie.current.useInsertionEffect(t, e);
};
bt.useLayoutEffect = function (t, e) {
  return ie.current.useLayoutEffect(t, e);
};
bt.useMemo = function (t, e) {
  return ie.current.useMemo(t, e);
};
bt.useReducer = function (t, e, n) {
  return ie.current.useReducer(t, e, n);
};
bt.useRef = function (t) {
  return ie.current.useRef(t);
};
bt.useState = function (t) {
  return ie.current.useState(t);
};
bt.useSyncExternalStore = function (t, e, n) {
  return ie.current.useSyncExternalStore(t, e, n);
};
bt.useTransition = function () {
  return ie.current.useTransition();
};
bt.version = "18.2.0";
Gl.exports = bt;
var Ft = Gl.exports;
const kd = Ci(Ft);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Cd = Ft,
  bd = Symbol.for("react.element"),
  Md = Symbol.for("react.fragment"),
  Pd = Object.prototype.hasOwnProperty,
  Ad = Cd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Td = { key: !0, ref: !0, __self: !0, __source: !0 };
function $l(t, e, n) {
  var i,
    a = {},
    d = null,
    M = null;
  n !== void 0 && (d = "" + n),
    e.key !== void 0 && (d = "" + e.key),
    e.ref !== void 0 && (M = e.ref);
  for (i in e) Pd.call(e, i) && !Td.hasOwnProperty(i) && (a[i] = e[i]);
  if (t && t.defaultProps)
    for (i in ((e = t.defaultProps), e)) a[i] === void 0 && (a[i] = e[i]);
  return {
    $$typeof: bd,
    type: t,
    key: d,
    ref: M,
    props: a,
    _owner: Ad.current,
  };
}
Vs.Fragment = Md;
Vs.jsx = $l;
Vs.jsxs = $l;
Ul.exports = Vs;
var dt = Ul.exports,
  Bo = {},
  Zl = { exports: {} },
  pe = {},
  Ql = { exports: {} },
  Jl = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(v, N) {
    var w = v.length;
    v.push(N);
    t: for (; 0 < w; ) {
      var R = (w - 1) >>> 1,
        X = v[R];
      if (0 < a(X, N)) (v[R] = N), (v[w] = X), (w = R);
      else break t;
    }
  }
  function n(v) {
    return v.length === 0 ? null : v[0];
  }
  function i(v) {
    if (v.length === 0) return null;
    var N = v[0],
      w = v.pop();
    if (w !== N) {
      v[0] = w;
      t: for (var R = 0, X = v.length, J = X >>> 1; R < J; ) {
        var K = 2 * (R + 1) - 1,
          H = v[K],
          k = K + 1,
          U = v[k];
        if (0 > a(H, w))
          k < X && 0 > a(U, H)
            ? ((v[R] = U), (v[k] = w), (R = k))
            : ((v[R] = H), (v[K] = w), (R = K));
        else if (k < X && 0 > a(U, w)) (v[R] = U), (v[k] = w), (R = k);
        else break t;
      }
    }
    return N;
  }
  function a(v, N) {
    var w = v.sortIndex - N.sortIndex;
    return w !== 0 ? w : v.id - N.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var d = performance;
    t.unstable_now = function () {
      return d.now();
    };
  } else {
    var M = Date,
      O = M.now();
    t.unstable_now = function () {
      return M.now() - O;
    };
  }
  var B = [],
    G = [],
    Y = 1,
    L = null,
    E = 3,
    z = !1,
    S = !1,
    x = !1,
    P = typeof setTimeout == "function" ? setTimeout : null,
    h = typeof clearTimeout == "function" ? clearTimeout : null,
    s = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function l(v) {
    for (var N = n(G); N !== null; ) {
      if (N.callback === null) i(G);
      else if (N.startTime <= v)
        i(G), (N.sortIndex = N.expirationTime), e(B, N);
      else break;
      N = n(G);
    }
  }
  function p(v) {
    if (((x = !1), l(v), !S))
      if (n(B) !== null) (S = !0), c(g);
      else {
        var N = n(G);
        N !== null && u(p, N.startTime - v);
      }
  }
  function g(v, N) {
    (S = !1), x && ((x = !1), h(A), (A = -1)), (z = !0);
    var w = E;
    try {
      for (
        l(N), L = n(B);
        L !== null && (!(L.expirationTime > N) || (v && !b()));

      ) {
        var R = L.callback;
        if (typeof R == "function") {
          (L.callback = null), (E = L.priorityLevel);
          var X = R(L.expirationTime <= N);
          (N = t.unstable_now()),
            typeof X == "function" ? (L.callback = X) : L === n(B) && i(B),
            l(N);
        } else i(B);
        L = n(B);
      }
      if (L !== null) var J = !0;
      else {
        var K = n(G);
        K !== null && u(p, K.startTime - N), (J = !1);
      }
      return J;
    } finally {
      (L = null), (E = w), (z = !1);
    }
  }
  var T = !1,
    D = null,
    A = -1,
    m = 5,
    f = -1;
  function b() {
    return !(t.unstable_now() - f < m);
  }
  function y() {
    if (D !== null) {
      var v = t.unstable_now();
      f = v;
      var N = !0;
      try {
        N = D(!0, v);
      } finally {
        N ? C() : ((T = !1), (D = null));
      }
    } else T = !1;
  }
  var C;
  if (typeof s == "function")
    C = function () {
      s(y);
    };
  else if (typeof MessageChannel < "u") {
    var o = new MessageChannel(),
      r = o.port2;
    (o.port1.onmessage = y),
      (C = function () {
        r.postMessage(null);
      });
  } else
    C = function () {
      P(y, 0);
    };
  function c(v) {
    (D = v), T || ((T = !0), C());
  }
  function u(v, N) {
    A = P(function () {
      v(t.unstable_now());
    }, N);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (v) {
      v.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      S || z || ((S = !0), c(g));
    }),
    (t.unstable_forceFrameRate = function (v) {
      0 > v || 125 < v
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (m = 0 < v ? Math.floor(1e3 / v) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return E;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(B);
    }),
    (t.unstable_next = function (v) {
      switch (E) {
        case 1:
        case 2:
        case 3:
          var N = 3;
          break;
        default:
          N = E;
      }
      var w = E;
      E = N;
      try {
        return v();
      } finally {
        E = w;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (v, N) {
      switch (v) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          v = 3;
      }
      var w = E;
      E = v;
      try {
        return N();
      } finally {
        E = w;
      }
    }),
    (t.unstable_scheduleCallback = function (v, N, w) {
      var R = t.unstable_now();
      switch (
        (typeof w == "object" && w !== null
          ? ((w = w.delay), (w = typeof w == "number" && 0 < w ? R + w : R))
          : (w = R),
        v)
      ) {
        case 1:
          var X = -1;
          break;
        case 2:
          X = 250;
          break;
        case 5:
          X = 1073741823;
          break;
        case 4:
          X = 1e4;
          break;
        default:
          X = 5e3;
      }
      return (
        (X = w + X),
        (v = {
          id: Y++,
          callback: N,
          priorityLevel: v,
          startTime: w,
          expirationTime: X,
          sortIndex: -1,
        }),
        w > R
          ? ((v.sortIndex = w),
            e(G, v),
            n(B) === null &&
              v === n(G) &&
              (x ? (h(A), (A = -1)) : (x = !0), u(p, w - R)))
          : ((v.sortIndex = X), e(B, v), S || z || ((S = !0), c(g))),
        v
      );
    }),
    (t.unstable_shouldYield = b),
    (t.unstable_wrapCallback = function (v) {
      var N = E;
      return function () {
        var w = E;
        E = N;
        try {
          return v.apply(this, arguments);
        } finally {
          E = w;
        }
      };
    });
})(Jl);
Ql.exports = Jl;
var Ed = Ql.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var th = Ft,
  ue = Ed;
function mt(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var eh = new Set(),
  bn = {};
function bi(t, e) {
  _i(t, e), _i(t + "Capture", e);
}
function _i(t, e) {
  for (bn[t] = e, t = 0; t < e.length; t++) eh.add(e[t]);
}
var He = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Ro = Object.prototype.hasOwnProperty,
  Ld =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Ea = {},
  La = {};
function Dd(t) {
  return Ro.call(La, t)
    ? !0
    : Ro.call(Ea, t)
    ? !1
    : Ld.test(t)
    ? (La[t] = !0)
    : ((Ea[t] = !0), !1);
}
function jd(t, e, n, i) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function Nd(t, e, n, i) {
  if (e === null || typeof e > "u" || jd(t, e, n, i)) return !0;
  if (i) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function ne(t, e, n, i, a, d, M) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = a),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = d),
    (this.removeEmptyString = M);
}
var Vt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    Vt[t] = new ne(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  Vt[e] = new ne(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  Vt[t] = new ne(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  Vt[t] = new ne(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    Vt[t] = new ne(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  Vt[t] = new ne(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  Vt[t] = new ne(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  Vt[t] = new ne(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  Vt[t] = new ne(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var Br = /[\-:]([a-z])/g;
function Rr(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(Br, Rr);
    Vt[e] = new ne(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(Br, Rr);
    Vt[e] = new ne(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(Br, Rr);
  Vt[e] = new ne(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  Vt[t] = new ne(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
Vt.xlinkHref = new ne(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  Vt[t] = new ne(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function zr(t, e, n, i) {
  var a = Vt.hasOwnProperty(e) ? Vt[e] : null;
  (a !== null
    ? a.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (Nd(e, n, a, i) && (n = null),
    i || a === null
      ? Dd(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : a.mustUseProperty
      ? (t[a.propertyName] = n === null ? (a.type === 3 ? !1 : "") : n)
      : ((e = a.attributeName),
        (i = a.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((a = a.type),
            (n = a === 3 || (a === 4 && n === !0) ? "" : "" + n),
            i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n))));
}
var We = th.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  qn = Symbol.for("react.element"),
  Ai = Symbol.for("react.portal"),
  Ti = Symbol.for("react.fragment"),
  Fr = Symbol.for("react.strict_mode"),
  zo = Symbol.for("react.profiler"),
  ih = Symbol.for("react.provider"),
  nh = Symbol.for("react.context"),
  Hr = Symbol.for("react.forward_ref"),
  Fo = Symbol.for("react.suspense"),
  Ho = Symbol.for("react.suspense_list"),
  Ur = Symbol.for("react.memo"),
  _e = Symbol.for("react.lazy"),
  sh = Symbol.for("react.offscreen"),
  Da = Symbol.iterator;
function nn(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Da && t[Da]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var Bt = Object.assign,
  co;
function dn(t) {
  if (co === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      co = (e && e[1]) || "";
    }
  return (
    `
` +
    co +
    t
  );
}
var uo = !1;
function po(t, e) {
  if (!t || uo) return "";
  uo = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (G) {
          var i = G;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (G) {
          i = G;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (G) {
        i = G;
      }
      t();
    }
  } catch (G) {
    if (G && i && typeof G.stack == "string") {
      for (
        var a = G.stack.split(`
`),
          d = i.stack.split(`
`),
          M = a.length - 1,
          O = d.length - 1;
        1 <= M && 0 <= O && a[M] !== d[O];

      )
        O--;
      for (; 1 <= M && 0 <= O; M--, O--)
        if (a[M] !== d[O]) {
          if (M !== 1 || O !== 1)
            do
              if ((M--, O--, 0 > O || a[M] !== d[O])) {
                var B =
                  `
` + a[M].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    B.includes("<anonymous>") &&
                    (B = B.replace("<anonymous>", t.displayName)),
                  B
                );
              }
            while (1 <= M && 0 <= O);
          break;
        }
    }
  } finally {
    (uo = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? dn(t) : "";
}
function Od(t) {
  switch (t.tag) {
    case 5:
      return dn(t.type);
    case 16:
      return dn("Lazy");
    case 13:
      return dn("Suspense");
    case 19:
      return dn("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = po(t.type, !1)), t;
    case 11:
      return (t = po(t.type.render, !1)), t;
    case 1:
      return (t = po(t.type, !0)), t;
    default:
      return "";
  }
}
function Uo(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Ti:
      return "Fragment";
    case Ai:
      return "Portal";
    case zo:
      return "Profiler";
    case Fr:
      return "StrictMode";
    case Fo:
      return "Suspense";
    case Ho:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case nh:
        return (t.displayName || "Context") + ".Consumer";
      case ih:
        return (t._context.displayName || "Context") + ".Provider";
      case Hr:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case Ur:
        return (
          (e = t.displayName || null), e !== null ? e : Uo(t.type) || "Memo"
        );
      case _e:
        (e = t._payload), (t = t._init);
        try {
          return Uo(t(e));
        } catch {}
    }
  return null;
}
function Id(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Uo(e);
    case 8:
      return e === Fr ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function ri(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function oh(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function Bd(t) {
  var e = oh(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    i = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var a = n.get,
      d = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return a.call(this);
        },
        set: function (M) {
          (i = "" + M), d.call(this, M);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (M) {
          i = "" + M;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function Kn(t) {
  t._valueTracker || (t._valueTracker = Bd(t));
}
function rh(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    i = "";
  return (
    t && (i = oh(t) ? (t.checked ? "true" : "false") : t.value),
    (t = i),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function Cs(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function Go(t, e) {
  var n = e.checked;
  return Bt({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function ja(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (n = ri(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: i,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function ah(t, e) {
  (e = e.checked), e != null && zr(t, "checked", e, !1);
}
function Xo(t, e) {
  ah(t, e);
  var n = ri(e.value),
    i = e.type;
  if (n != null)
    i === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (i === "submit" || i === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Wo(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && Wo(t, e.type, ri(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function Na(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function Wo(t, e, n) {
  (e !== "number" || Cs(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var un = Array.isArray;
function Hi(t, e, n, i) {
  if (((t = t.options), e)) {
    e = {};
    for (var a = 0; a < n.length; a++) e["$" + n[a]] = !0;
    for (n = 0; n < t.length; n++)
      (a = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== a && (t[n].selected = a),
        a && i && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + ri(n), e = null, a = 0; a < t.length; a++) {
      if (t[a].value === n) {
        (t[a].selected = !0), i && (t[a].defaultSelected = !0);
        return;
      }
      e !== null || t[a].disabled || (e = t[a]);
    }
    e !== null && (e.selected = !0);
  }
}
function Yo(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(mt(91));
  return Bt({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function Oa(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(mt(92));
      if (un(n)) {
        if (1 < n.length) throw Error(mt(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: ri(n) };
}
function lh(t, e) {
  var n = ri(e.value),
    i = ri(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    i != null && (t.defaultValue = "" + i);
}
function Ia(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function hh(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function _o(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? hh(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var $n,
  ch = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, i, a) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, i, a);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        $n = $n || document.createElement("div"),
          $n.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = $n.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function Mn(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var gn = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  Rd = ["Webkit", "ms", "Moz", "O"];
Object.keys(gn).forEach(function (t) {
  Rd.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (gn[e] = gn[t]);
  });
});
function dh(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (gn.hasOwnProperty(t) && gn[t])
    ? ("" + e).trim()
    : e + "px";
}
function uh(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var i = n.indexOf("--") === 0,
        a = dh(n, e[n], i);
      n === "float" && (n = "cssFloat"), i ? t.setProperty(n, a) : (t[n] = a);
    }
}
var zd = Bt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function Vo(t, e) {
  if (e) {
    if (zd[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(mt(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(mt(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(mt(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(mt(62));
  }
}
function qo(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var Ko = null;
function Gr(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var $o = null,
  Ui = null,
  Gi = null;
function Ba(t) {
  if ((t = Wn(t))) {
    if (typeof $o != "function") throw Error(mt(280));
    var e = t.stateNode;
    e && ((e = Qs(e)), $o(t.stateNode, t.type, e));
  }
}
function ph(t) {
  Ui ? (Gi ? Gi.push(t) : (Gi = [t])) : (Ui = t);
}
function fh() {
  if (Ui) {
    var t = Ui,
      e = Gi;
    if (((Gi = Ui = null), Ba(t), e)) for (t = 0; t < e.length; t++) Ba(e[t]);
  }
}
function gh(t, e) {
  return t(e);
}
function mh() {}
var fo = !1;
function yh(t, e, n) {
  if (fo) return t(e, n);
  fo = !0;
  try {
    return gh(t, e, n);
  } finally {
    (fo = !1), (Ui !== null || Gi !== null) && (mh(), fh());
  }
}
function Pn(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var i = Qs(n);
  if (i === null) return null;
  n = i[e];
  t: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((t = t.type),
        (i = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !i);
      break t;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(mt(231, e, typeof n));
  return n;
}
var Zo = !1;
if (He)
  try {
    var sn = {};
    Object.defineProperty(sn, "passive", {
      get: function () {
        Zo = !0;
      },
    }),
      window.addEventListener("test", sn, sn),
      window.removeEventListener("test", sn, sn);
  } catch {
    Zo = !1;
  }
function Fd(t, e, n, i, a, d, M, O, B) {
  var G = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, G);
  } catch (Y) {
    this.onError(Y);
  }
}
var mn = !1,
  bs = null,
  Ms = !1,
  Qo = null,
  Hd = {
    onError: function (t) {
      (mn = !0), (bs = t);
    },
  };
function Ud(t, e, n, i, a, d, M, O, B) {
  (mn = !1), (bs = null), Fd.apply(Hd, arguments);
}
function Gd(t, e, n, i, a, d, M, O, B) {
  if ((Ud.apply(this, arguments), mn)) {
    if (mn) {
      var G = bs;
      (mn = !1), (bs = null);
    } else throw Error(mt(198));
    Ms || ((Ms = !0), (Qo = G));
  }
}
function Mi(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function xh(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function Ra(t) {
  if (Mi(t) !== t) throw Error(mt(188));
}
function Xd(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = Mi(t)), e === null)) throw Error(mt(188));
    return e !== t ? null : t;
  }
  for (var n = t, i = e; ; ) {
    var a = n.return;
    if (a === null) break;
    var d = a.alternate;
    if (d === null) {
      if (((i = a.return), i !== null)) {
        n = i;
        continue;
      }
      break;
    }
    if (a.child === d.child) {
      for (d = a.child; d; ) {
        if (d === n) return Ra(a), t;
        if (d === i) return Ra(a), e;
        d = d.sibling;
      }
      throw Error(mt(188));
    }
    if (n.return !== i.return) (n = a), (i = d);
    else {
      for (var M = !1, O = a.child; O; ) {
        if (O === n) {
          (M = !0), (n = a), (i = d);
          break;
        }
        if (O === i) {
          (M = !0), (i = a), (n = d);
          break;
        }
        O = O.sibling;
      }
      if (!M) {
        for (O = d.child; O; ) {
          if (O === n) {
            (M = !0), (n = d), (i = a);
            break;
          }
          if (O === i) {
            (M = !0), (i = d), (n = a);
            break;
          }
          O = O.sibling;
        }
        if (!M) throw Error(mt(189));
      }
    }
    if (n.alternate !== i) throw Error(mt(190));
  }
  if (n.tag !== 3) throw Error(mt(188));
  return n.stateNode.current === n ? t : e;
}
function vh(t) {
  return (t = Xd(t)), t !== null ? Sh(t) : null;
}
function Sh(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = Sh(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var wh = ue.unstable_scheduleCallback,
  za = ue.unstable_cancelCallback,
  Wd = ue.unstable_shouldYield,
  Yd = ue.unstable_requestPaint,
  zt = ue.unstable_now,
  _d = ue.unstable_getCurrentPriorityLevel,
  Xr = ue.unstable_ImmediatePriority,
  kh = ue.unstable_UserBlockingPriority,
  Ps = ue.unstable_NormalPriority,
  Vd = ue.unstable_LowPriority,
  Ch = ue.unstable_IdlePriority,
  qs = null,
  Ne = null;
function qd(t) {
  if (Ne && typeof Ne.onCommitFiberRoot == "function")
    try {
      Ne.onCommitFiberRoot(qs, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var Ae = Math.clz32 ? Math.clz32 : Zd,
  Kd = Math.log,
  $d = Math.LN2;
function Zd(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((Kd(t) / $d) | 0)) | 0;
}
var Zn = 64,
  Qn = 4194304;
function pn(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function As(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var i = 0,
    a = t.suspendedLanes,
    d = t.pingedLanes,
    M = n & 268435455;
  if (M !== 0) {
    var O = M & ~a;
    O !== 0 ? (i = pn(O)) : ((d &= M), d !== 0 && (i = pn(d)));
  } else (M = n & ~a), M !== 0 ? (i = pn(M)) : d !== 0 && (i = pn(d));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & a) &&
    ((a = i & -i), (d = e & -e), a >= d || (a === 16 && (d & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= i; 0 < e; )
      (n = 31 - Ae(e)), (a = 1 << n), (i |= t[n]), (e &= ~a);
  return i;
}
function Qd(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function Jd(t, e) {
  for (
    var n = t.suspendedLanes,
      i = t.pingedLanes,
      a = t.expirationTimes,
      d = t.pendingLanes;
    0 < d;

  ) {
    var M = 31 - Ae(d),
      O = 1 << M,
      B = a[M];
    B === -1
      ? (!(O & n) || O & i) && (a[M] = Qd(O, e))
      : B <= e && (t.expiredLanes |= O),
      (d &= ~O);
  }
}
function Jo(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function bh() {
  var t = Zn;
  return (Zn <<= 1), !(Zn & 4194240) && (Zn = 64), t;
}
function go(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function Gn(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - Ae(e)),
    (t[e] = n);
}
function tu(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var i = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var a = 31 - Ae(n),
      d = 1 << a;
    (e[a] = 0), (i[a] = -1), (t[a] = -1), (n &= ~d);
  }
}
function Wr(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var i = 31 - Ae(n),
      a = 1 << i;
    (a & e) | (t[i] & e) && (t[i] |= e), (n &= ~a);
  }
}
var At = 0;
function Mh(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var Ph,
  Yr,
  Ah,
  Th,
  Eh,
  tr = !1,
  Jn = [],
  Qe = null,
  Je = null,
  ti = null,
  An = new Map(),
  Tn = new Map(),
  qe = [],
  eu =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Fa(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Qe = null;
      break;
    case "dragenter":
    case "dragleave":
      Je = null;
      break;
    case "mouseover":
    case "mouseout":
      ti = null;
      break;
    case "pointerover":
    case "pointerout":
      An.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Tn.delete(e.pointerId);
  }
}
function on(t, e, n, i, a, d) {
  return t === null || t.nativeEvent !== d
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: i,
        nativeEvent: d,
        targetContainers: [a],
      }),
      e !== null && ((e = Wn(e)), e !== null && Yr(e)),
      t)
    : ((t.eventSystemFlags |= i),
      (e = t.targetContainers),
      a !== null && e.indexOf(a) === -1 && e.push(a),
      t);
}
function iu(t, e, n, i, a) {
  switch (e) {
    case "focusin":
      return (Qe = on(Qe, t, e, n, i, a)), !0;
    case "dragenter":
      return (Je = on(Je, t, e, n, i, a)), !0;
    case "mouseover":
      return (ti = on(ti, t, e, n, i, a)), !0;
    case "pointerover":
      var d = a.pointerId;
      return An.set(d, on(An.get(d) || null, t, e, n, i, a)), !0;
    case "gotpointercapture":
      return (
        (d = a.pointerId), Tn.set(d, on(Tn.get(d) || null, t, e, n, i, a)), !0
      );
  }
  return !1;
}
function Lh(t) {
  var e = pi(t.target);
  if (e !== null) {
    var n = Mi(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = xh(n)), e !== null)) {
          (t.blockedOn = e),
            Eh(t.priority, function () {
              Ah(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function ps(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = er(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var i = new n.constructor(n.type, n);
      (Ko = i), n.target.dispatchEvent(i), (Ko = null);
    } else return (e = Wn(n)), e !== null && Yr(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function Ha(t, e, n) {
  ps(t) && n.delete(e);
}
function nu() {
  (tr = !1),
    Qe !== null && ps(Qe) && (Qe = null),
    Je !== null && ps(Je) && (Je = null),
    ti !== null && ps(ti) && (ti = null),
    An.forEach(Ha),
    Tn.forEach(Ha);
}
function rn(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    tr ||
      ((tr = !0),
      ue.unstable_scheduleCallback(ue.unstable_NormalPriority, nu)));
}
function En(t) {
  function e(a) {
    return rn(a, t);
  }
  if (0 < Jn.length) {
    rn(Jn[0], t);
    for (var n = 1; n < Jn.length; n++) {
      var i = Jn[n];
      i.blockedOn === t && (i.blockedOn = null);
    }
  }
  for (
    Qe !== null && rn(Qe, t),
      Je !== null && rn(Je, t),
      ti !== null && rn(ti, t),
      An.forEach(e),
      Tn.forEach(e),
      n = 0;
    n < qe.length;
    n++
  )
    (i = qe[n]), i.blockedOn === t && (i.blockedOn = null);
  for (; 0 < qe.length && ((n = qe[0]), n.blockedOn === null); )
    Lh(n), n.blockedOn === null && qe.shift();
}
var Xi = We.ReactCurrentBatchConfig,
  Ts = !0;
function su(t, e, n, i) {
  var a = At,
    d = Xi.transition;
  Xi.transition = null;
  try {
    (At = 1), _r(t, e, n, i);
  } finally {
    (At = a), (Xi.transition = d);
  }
}
function ou(t, e, n, i) {
  var a = At,
    d = Xi.transition;
  Xi.transition = null;
  try {
    (At = 4), _r(t, e, n, i);
  } finally {
    (At = a), (Xi.transition = d);
  }
}
function _r(t, e, n, i) {
  if (Ts) {
    var a = er(t, e, n, i);
    if (a === null) Mo(t, e, i, Es, n), Fa(t, i);
    else if (iu(a, t, e, n, i)) i.stopPropagation();
    else if ((Fa(t, i), e & 4 && -1 < eu.indexOf(t))) {
      for (; a !== null; ) {
        var d = Wn(a);
        if (
          (d !== null && Ph(d),
          (d = er(t, e, n, i)),
          d === null && Mo(t, e, i, Es, n),
          d === a)
        )
          break;
        a = d;
      }
      a !== null && i.stopPropagation();
    } else Mo(t, e, i, null, n);
  }
}
var Es = null;
function er(t, e, n, i) {
  if (((Es = null), (t = Gr(i)), (t = pi(t)), t !== null))
    if (((e = Mi(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = xh(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (Es = t), null;
}
function Dh(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (_d()) {
        case Xr:
          return 1;
        case kh:
          return 4;
        case Ps:
        case Vd:
          return 16;
        case Ch:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var $e = null,
  Vr = null,
  fs = null;
function jh() {
  if (fs) return fs;
  var t,
    e = Vr,
    n = e.length,
    i,
    a = "value" in $e ? $e.value : $e.textContent,
    d = a.length;
  for (t = 0; t < n && e[t] === a[t]; t++);
  var M = n - t;
  for (i = 1; i <= M && e[n - i] === a[d - i]; i++);
  return (fs = a.slice(t, 1 < i ? 1 - i : void 0));
}
function gs(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function ts() {
  return !0;
}
function Ua() {
  return !1;
}
function fe(t) {
  function e(n, i, a, d, M) {
    (this._reactName = n),
      (this._targetInst = a),
      (this.type = i),
      (this.nativeEvent = d),
      (this.target = M),
      (this.currentTarget = null);
    for (var O in t)
      t.hasOwnProperty(O) && ((n = t[O]), (this[O] = n ? n(d) : d[O]));
    return (
      (this.isDefaultPrevented = (
        d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1
      )
        ? ts
        : Ua),
      (this.isPropagationStopped = Ua),
      this
    );
  }
  return (
    Bt(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = ts));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = ts));
      },
      persist: function () {},
      isPersistent: ts,
    }),
    e
  );
}
var tn = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  qr = fe(tn),
  Xn = Bt({}, tn, { view: 0, detail: 0 }),
  ru = fe(Xn),
  mo,
  yo,
  an,
  Ks = Bt({}, Xn, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Kr,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== an &&
            (an && t.type === "mousemove"
              ? ((mo = t.screenX - an.screenX), (yo = t.screenY - an.screenY))
              : (yo = mo = 0),
            (an = t)),
          mo);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : yo;
    },
  }),
  Ga = fe(Ks),
  au = Bt({}, Ks, { dataTransfer: 0 }),
  lu = fe(au),
  hu = Bt({}, Xn, { relatedTarget: 0 }),
  xo = fe(hu),
  cu = Bt({}, tn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  du = fe(cu),
  uu = Bt({}, tn, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  pu = fe(uu),
  fu = Bt({}, tn, { data: 0 }),
  Xa = fe(fu),
  gu = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  mu = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  yu = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function xu(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = yu[t]) ? !!e[t] : !1;
}
function Kr() {
  return xu;
}
var vu = Bt({}, Xn, {
    key: function (t) {
      if (t.key) {
        var e = gu[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = gs(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? mu[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Kr,
    charCode: function (t) {
      return t.type === "keypress" ? gs(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? gs(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  Su = fe(vu),
  wu = Bt({}, Ks, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Wa = fe(wu),
  ku = Bt({}, Xn, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Kr,
  }),
  Cu = fe(ku),
  bu = Bt({}, tn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Mu = fe(bu),
  Pu = Bt({}, Ks, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Au = fe(Pu),
  Tu = [9, 13, 27, 32],
  $r = He && "CompositionEvent" in window,
  yn = null;
He && "documentMode" in document && (yn = document.documentMode);
var Eu = He && "TextEvent" in window && !yn,
  Nh = He && (!$r || (yn && 8 < yn && 11 >= yn)),
  Ya = String.fromCharCode(32),
  _a = !1;
function Oh(t, e) {
  switch (t) {
    case "keyup":
      return Tu.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function Ih(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Ei = !1;
function Lu(t, e) {
  switch (t) {
    case "compositionend":
      return Ih(e);
    case "keypress":
      return e.which !== 32 ? null : ((_a = !0), Ya);
    case "textInput":
      return (t = e.data), t === Ya && _a ? null : t;
    default:
      return null;
  }
}
function Du(t, e) {
  if (Ei)
    return t === "compositionend" || (!$r && Oh(t, e))
      ? ((t = jh()), (fs = Vr = $e = null), (Ei = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return Nh && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var ju = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function Va(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!ju[t.type] : e === "textarea";
}
function Bh(t, e, n, i) {
  ph(i),
    (e = Ls(e, "onChange")),
    0 < e.length &&
      ((n = new qr("onChange", "change", null, n, i)),
      t.push({ event: n, listeners: e }));
}
var xn = null,
  Ln = null;
function Nu(t) {
  Vh(t, 0);
}
function $s(t) {
  var e = ji(t);
  if (rh(e)) return t;
}
function Ou(t, e) {
  if (t === "change") return e;
}
var Rh = !1;
if (He) {
  var vo;
  if (He) {
    var So = "oninput" in document;
    if (!So) {
      var qa = document.createElement("div");
      qa.setAttribute("oninput", "return;"),
        (So = typeof qa.oninput == "function");
    }
    vo = So;
  } else vo = !1;
  Rh = vo && (!document.documentMode || 9 < document.documentMode);
}
function Ka() {
  xn && (xn.detachEvent("onpropertychange", zh), (Ln = xn = null));
}
function zh(t) {
  if (t.propertyName === "value" && $s(Ln)) {
    var e = [];
    Bh(e, Ln, t, Gr(t)), yh(Nu, e);
  }
}
function Iu(t, e, n) {
  t === "focusin"
    ? (Ka(), (xn = e), (Ln = n), xn.attachEvent("onpropertychange", zh))
    : t === "focusout" && Ka();
}
function Bu(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return $s(Ln);
}
function Ru(t, e) {
  if (t === "click") return $s(e);
}
function zu(t, e) {
  if (t === "input" || t === "change") return $s(e);
}
function Fu(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var Ee = typeof Object.is == "function" ? Object.is : Fu;
function Dn(t, e) {
  if (Ee(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    i = Object.keys(e);
  if (n.length !== i.length) return !1;
  for (i = 0; i < n.length; i++) {
    var a = n[i];
    if (!Ro.call(e, a) || !Ee(t[a], e[a])) return !1;
  }
  return !0;
}
function $a(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function Za(t, e) {
  var n = $a(t);
  t = 0;
  for (var i; n; ) {
    if (n.nodeType === 3) {
      if (((i = t + n.textContent.length), t <= e && i >= e))
        return { node: n, offset: e - t };
      t = i;
    }
    t: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break t;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = $a(n);
  }
}
function Fh(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? Fh(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function Hh() {
  for (var t = window, e = Cs(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = Cs(t.document);
  }
  return e;
}
function Zr(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function Hu(t) {
  var e = Hh(),
    n = t.focusedElem,
    i = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    Fh(n.ownerDocument.documentElement, n)
  ) {
    if (i !== null && Zr(n)) {
      if (
        ((e = i.start),
        (t = i.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var a = n.textContent.length,
          d = Math.min(i.start, a);
        (i = i.end === void 0 ? d : Math.min(i.end, a)),
          !t.extend && d > i && ((a = i), (i = d), (d = a)),
          (a = Za(n, d));
        var M = Za(n, i);
        a &&
          M &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== a.node ||
            t.anchorOffset !== a.offset ||
            t.focusNode !== M.node ||
            t.focusOffset !== M.offset) &&
          ((e = e.createRange()),
          e.setStart(a.node, a.offset),
          t.removeAllRanges(),
          d > i
            ? (t.addRange(e), t.extend(M.node, M.offset))
            : (e.setEnd(M.node, M.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var Uu = He && "documentMode" in document && 11 >= document.documentMode,
  Li = null,
  ir = null,
  vn = null,
  nr = !1;
function Qa(t, e, n) {
  var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  nr ||
    Li == null ||
    Li !== Cs(i) ||
    ((i = Li),
    "selectionStart" in i && Zr(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (vn && Dn(vn, i)) ||
      ((vn = i),
      (i = Ls(ir, "onSelect")),
      0 < i.length &&
        ((e = new qr("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: i }),
        (e.target = Li))));
}
function es(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var Di = {
    animationend: es("Animation", "AnimationEnd"),
    animationiteration: es("Animation", "AnimationIteration"),
    animationstart: es("Animation", "AnimationStart"),
    transitionend: es("Transition", "TransitionEnd"),
  },
  wo = {},
  Uh = {};
He &&
  ((Uh = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Di.animationend.animation,
    delete Di.animationiteration.animation,
    delete Di.animationstart.animation),
  "TransitionEvent" in window || delete Di.transitionend.transition);
function Zs(t) {
  if (wo[t]) return wo[t];
  if (!Di[t]) return t;
  var e = Di[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in Uh) return (wo[t] = e[n]);
  return t;
}
var Gh = Zs("animationend"),
  Xh = Zs("animationiteration"),
  Wh = Zs("animationstart"),
  Yh = Zs("transitionend"),
  _h = new Map(),
  Ja =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function li(t, e) {
  _h.set(t, e), bi(e, [t]);
}
for (var ko = 0; ko < Ja.length; ko++) {
  var Co = Ja[ko],
    Gu = Co.toLowerCase(),
    Xu = Co[0].toUpperCase() + Co.slice(1);
  li(Gu, "on" + Xu);
}
li(Gh, "onAnimationEnd");
li(Xh, "onAnimationIteration");
li(Wh, "onAnimationStart");
li("dblclick", "onDoubleClick");
li("focusin", "onFocus");
li("focusout", "onBlur");
li(Yh, "onTransitionEnd");
_i("onMouseEnter", ["mouseout", "mouseover"]);
_i("onMouseLeave", ["mouseout", "mouseover"]);
_i("onPointerEnter", ["pointerout", "pointerover"]);
_i("onPointerLeave", ["pointerout", "pointerover"]);
bi(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
bi(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
bi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
bi(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
bi(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
bi(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var fn =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Wu = new Set("cancel close invalid load scroll toggle".split(" ").concat(fn));
function tl(t, e, n) {
  var i = t.type || "unknown-event";
  (t.currentTarget = n), Gd(i, e, void 0, t), (t.currentTarget = null);
}
function Vh(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var i = t[n],
      a = i.event;
    i = i.listeners;
    t: {
      var d = void 0;
      if (e)
        for (var M = i.length - 1; 0 <= M; M--) {
          var O = i[M],
            B = O.instance,
            G = O.currentTarget;
          if (((O = O.listener), B !== d && a.isPropagationStopped())) break t;
          tl(a, O, G), (d = B);
        }
      else
        for (M = 0; M < i.length; M++) {
          if (
            ((O = i[M]),
            (B = O.instance),
            (G = O.currentTarget),
            (O = O.listener),
            B !== d && a.isPropagationStopped())
          )
            break t;
          tl(a, O, G), (d = B);
        }
    }
  }
  if (Ms) throw ((t = Qo), (Ms = !1), (Qo = null), t);
}
function Et(t, e) {
  var n = e[lr];
  n === void 0 && (n = e[lr] = new Set());
  var i = t + "__bubble";
  n.has(i) || (qh(e, t, 2, !1), n.add(i));
}
function bo(t, e, n) {
  var i = 0;
  e && (i |= 4), qh(n, t, i, e);
}
var is = "_reactListening" + Math.random().toString(36).slice(2);
function jn(t) {
  if (!t[is]) {
    (t[is] = !0),
      eh.forEach(function (n) {
        n !== "selectionchange" && (Wu.has(n) || bo(n, !1, t), bo(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[is] || ((e[is] = !0), bo("selectionchange", !1, e));
  }
}
function qh(t, e, n, i) {
  switch (Dh(e)) {
    case 1:
      var a = su;
      break;
    case 4:
      a = ou;
      break;
    default:
      a = _r;
  }
  (n = a.bind(null, e, n, t)),
    (a = void 0),
    !Zo ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (a = !0),
    i
      ? a !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: a })
        : t.addEventListener(e, n, !0)
      : a !== void 0
      ? t.addEventListener(e, n, { passive: a })
      : t.addEventListener(e, n, !1);
}
function Mo(t, e, n, i, a) {
  var d = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    t: for (;;) {
      if (i === null) return;
      var M = i.tag;
      if (M === 3 || M === 4) {
        var O = i.stateNode.containerInfo;
        if (O === a || (O.nodeType === 8 && O.parentNode === a)) break;
        if (M === 4)
          for (M = i.return; M !== null; ) {
            var B = M.tag;
            if (
              (B === 3 || B === 4) &&
              ((B = M.stateNode.containerInfo),
              B === a || (B.nodeType === 8 && B.parentNode === a))
            )
              return;
            M = M.return;
          }
        for (; O !== null; ) {
          if (((M = pi(O)), M === null)) return;
          if (((B = M.tag), B === 5 || B === 6)) {
            i = d = M;
            continue t;
          }
          O = O.parentNode;
        }
      }
      i = i.return;
    }
  yh(function () {
    var G = d,
      Y = Gr(n),
      L = [];
    t: {
      var E = _h.get(t);
      if (E !== void 0) {
        var z = qr,
          S = t;
        switch (t) {
          case "keypress":
            if (gs(n) === 0) break t;
          case "keydown":
          case "keyup":
            z = Su;
            break;
          case "focusin":
            (S = "focus"), (z = xo);
            break;
          case "focusout":
            (S = "blur"), (z = xo);
            break;
          case "beforeblur":
          case "afterblur":
            z = xo;
            break;
          case "click":
            if (n.button === 2) break t;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            z = Ga;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            z = lu;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            z = Cu;
            break;
          case Gh:
          case Xh:
          case Wh:
            z = du;
            break;
          case Yh:
            z = Mu;
            break;
          case "scroll":
            z = ru;
            break;
          case "wheel":
            z = Au;
            break;
          case "copy":
          case "cut":
          case "paste":
            z = pu;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            z = Wa;
        }
        var x = (e & 4) !== 0,
          P = !x && t === "scroll",
          h = x ? (E !== null ? E + "Capture" : null) : E;
        x = [];
        for (var s = G, l; s !== null; ) {
          l = s;
          var p = l.stateNode;
          if (
            (l.tag === 5 &&
              p !== null &&
              ((l = p),
              h !== null && ((p = Pn(s, h)), p != null && x.push(Nn(s, p, l)))),
            P)
          )
            break;
          s = s.return;
        }
        0 < x.length &&
          ((E = new z(E, S, null, n, Y)), L.push({ event: E, listeners: x }));
      }
    }
    if (!(e & 7)) {
      t: {
        if (
          ((E = t === "mouseover" || t === "pointerover"),
          (z = t === "mouseout" || t === "pointerout"),
          E &&
            n !== Ko &&
            (S = n.relatedTarget || n.fromElement) &&
            (pi(S) || S[Ue]))
        )
          break t;
        if (
          (z || E) &&
          ((E =
            Y.window === Y
              ? Y
              : (E = Y.ownerDocument)
              ? E.defaultView || E.parentWindow
              : window),
          z
            ? ((S = n.relatedTarget || n.toElement),
              (z = G),
              (S = S ? pi(S) : null),
              S !== null &&
                ((P = Mi(S)), S !== P || (S.tag !== 5 && S.tag !== 6)) &&
                (S = null))
            : ((z = null), (S = G)),
          z !== S)
        ) {
          if (
            ((x = Ga),
            (p = "onMouseLeave"),
            (h = "onMouseEnter"),
            (s = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((x = Wa),
              (p = "onPointerLeave"),
              (h = "onPointerEnter"),
              (s = "pointer")),
            (P = z == null ? E : ji(z)),
            (l = S == null ? E : ji(S)),
            (E = new x(p, s + "leave", z, n, Y)),
            (E.target = P),
            (E.relatedTarget = l),
            (p = null),
            pi(Y) === G &&
              ((x = new x(h, s + "enter", S, n, Y)),
              (x.target = l),
              (x.relatedTarget = P),
              (p = x)),
            (P = p),
            z && S)
          )
            e: {
              for (x = z, h = S, s = 0, l = x; l; l = Pi(l)) s++;
              for (l = 0, p = h; p; p = Pi(p)) l++;
              for (; 0 < s - l; ) (x = Pi(x)), s--;
              for (; 0 < l - s; ) (h = Pi(h)), l--;
              for (; s--; ) {
                if (x === h || (h !== null && x === h.alternate)) break e;
                (x = Pi(x)), (h = Pi(h));
              }
              x = null;
            }
          else x = null;
          z !== null && el(L, E, z, x, !1),
            S !== null && P !== null && el(L, P, S, x, !0);
        }
      }
      t: {
        if (
          ((E = G ? ji(G) : window),
          (z = E.nodeName && E.nodeName.toLowerCase()),
          z === "select" || (z === "input" && E.type === "file"))
        )
          var g = Ou;
        else if (Va(E))
          if (Rh) g = zu;
          else {
            g = Bu;
            var T = Iu;
          }
        else
          (z = E.nodeName) &&
            z.toLowerCase() === "input" &&
            (E.type === "checkbox" || E.type === "radio") &&
            (g = Ru);
        if (g && (g = g(t, G))) {
          Bh(L, g, n, Y);
          break t;
        }
        T && T(t, E, G),
          t === "focusout" &&
            (T = E._wrapperState) &&
            T.controlled &&
            E.type === "number" &&
            Wo(E, "number", E.value);
      }
      switch (((T = G ? ji(G) : window), t)) {
        case "focusin":
          (Va(T) || T.contentEditable === "true") &&
            ((Li = T), (ir = G), (vn = null));
          break;
        case "focusout":
          vn = ir = Li = null;
          break;
        case "mousedown":
          nr = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (nr = !1), Qa(L, n, Y);
          break;
        case "selectionchange":
          if (Uu) break;
        case "keydown":
        case "keyup":
          Qa(L, n, Y);
      }
      var D;
      if ($r)
        t: {
          switch (t) {
            case "compositionstart":
              var A = "onCompositionStart";
              break t;
            case "compositionend":
              A = "onCompositionEnd";
              break t;
            case "compositionupdate":
              A = "onCompositionUpdate";
              break t;
          }
          A = void 0;
        }
      else
        Ei
          ? Oh(t, n) && (A = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (A = "onCompositionStart");
      A &&
        (Nh &&
          n.locale !== "ko" &&
          (Ei || A !== "onCompositionStart"
            ? A === "onCompositionEnd" && Ei && (D = jh())
            : (($e = Y),
              (Vr = "value" in $e ? $e.value : $e.textContent),
              (Ei = !0))),
        (T = Ls(G, A)),
        0 < T.length &&
          ((A = new Xa(A, t, null, n, Y)),
          L.push({ event: A, listeners: T }),
          D ? (A.data = D) : ((D = Ih(n)), D !== null && (A.data = D)))),
        (D = Eu ? Lu(t, n) : Du(t, n)) &&
          ((G = Ls(G, "onBeforeInput")),
          0 < G.length &&
            ((Y = new Xa("onBeforeInput", "beforeinput", null, n, Y)),
            L.push({ event: Y, listeners: G }),
            (Y.data = D)));
    }
    Vh(L, e);
  });
}
function Nn(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function Ls(t, e) {
  for (var n = e + "Capture", i = []; t !== null; ) {
    var a = t,
      d = a.stateNode;
    a.tag === 5 &&
      d !== null &&
      ((a = d),
      (d = Pn(t, n)),
      d != null && i.unshift(Nn(t, d, a)),
      (d = Pn(t, e)),
      d != null && i.push(Nn(t, d, a))),
      (t = t.return);
  }
  return i;
}
function Pi(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function el(t, e, n, i, a) {
  for (var d = e._reactName, M = []; n !== null && n !== i; ) {
    var O = n,
      B = O.alternate,
      G = O.stateNode;
    if (B !== null && B === i) break;
    O.tag === 5 &&
      G !== null &&
      ((O = G),
      a
        ? ((B = Pn(n, d)), B != null && M.unshift(Nn(n, B, O)))
        : a || ((B = Pn(n, d)), B != null && M.push(Nn(n, B, O)))),
      (n = n.return);
  }
  M.length !== 0 && t.push({ event: e, listeners: M });
}
var Yu = /\r\n?/g,
  _u = /\u0000|\uFFFD/g;
function il(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      Yu,
      `
`
    )
    .replace(_u, "");
}
function ns(t, e, n) {
  if (((e = il(e)), il(t) !== e && n)) throw Error(mt(425));
}
function Ds() {}
var sr = null,
  or = null;
function rr(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var ar = typeof setTimeout == "function" ? setTimeout : void 0,
  Vu = typeof clearTimeout == "function" ? clearTimeout : void 0,
  nl = typeof Promise == "function" ? Promise : void 0,
  qu =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof nl < "u"
      ? function (t) {
          return nl.resolve(null).then(t).catch(Ku);
        }
      : ar;
function Ku(t) {
  setTimeout(function () {
    throw t;
  });
}
function Po(t, e) {
  var n = e,
    i = 0;
  do {
    var a = n.nextSibling;
    if ((t.removeChild(n), a && a.nodeType === 8))
      if (((n = a.data), n === "/$")) {
        if (i === 0) {
          t.removeChild(a), En(e);
          return;
        }
        i--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || i++;
    n = a;
  } while (n);
  En(e);
}
function ei(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function sl(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var en = Math.random().toString(36).slice(2),
  je = "__reactFiber$" + en,
  On = "__reactProps$" + en,
  Ue = "__reactContainer$" + en,
  lr = "__reactEvents$" + en,
  $u = "__reactListeners$" + en,
  Zu = "__reactHandles$" + en;
function pi(t) {
  var e = t[je];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[Ue] || n[je])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = sl(t); t !== null; ) {
          if ((n = t[je])) return n;
          t = sl(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function Wn(t) {
  return (
    (t = t[je] || t[Ue]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function ji(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(mt(33));
}
function Qs(t) {
  return t[On] || null;
}
var hr = [],
  Ni = -1;
function hi(t) {
  return { current: t };
}
function Lt(t) {
  0 > Ni || ((t.current = hr[Ni]), (hr[Ni] = null), Ni--);
}
function Tt(t, e) {
  Ni++, (hr[Ni] = t.current), (t.current = e);
}
var ai = {},
  Qt = hi(ai),
  re = hi(!1),
  xi = ai;
function Vi(t, e) {
  var n = t.type.contextTypes;
  if (!n) return ai;
  var i = t.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var a = {},
    d;
  for (d in n) a[d] = e[d];
  return (
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = a)),
    a
  );
}
function ae(t) {
  return (t = t.childContextTypes), t != null;
}
function js() {
  Lt(re), Lt(Qt);
}
function ol(t, e, n) {
  if (Qt.current !== ai) throw Error(mt(168));
  Tt(Qt, e), Tt(re, n);
}
function Kh(t, e, n) {
  var i = t.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return n;
  i = i.getChildContext();
  for (var a in i) if (!(a in e)) throw Error(mt(108, Id(t) || "Unknown", a));
  return Bt({}, n, i);
}
function Ns(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || ai),
    (xi = Qt.current),
    Tt(Qt, t),
    Tt(re, re.current),
    !0
  );
}
function rl(t, e, n) {
  var i = t.stateNode;
  if (!i) throw Error(mt(169));
  n
    ? ((t = Kh(t, e, xi)),
      (i.__reactInternalMemoizedMergedChildContext = t),
      Lt(re),
      Lt(Qt),
      Tt(Qt, t))
    : Lt(re),
    Tt(re, n);
}
var Be = null,
  Js = !1,
  Ao = !1;
function $h(t) {
  Be === null ? (Be = [t]) : Be.push(t);
}
function Qu(t) {
  (Js = !0), $h(t);
}
function ci() {
  if (!Ao && Be !== null) {
    Ao = !0;
    var t = 0,
      e = At;
    try {
      var n = Be;
      for (At = 1; t < n.length; t++) {
        var i = n[t];
        do i = i(!0);
        while (i !== null);
      }
      (Be = null), (Js = !1);
    } catch (a) {
      throw (Be !== null && (Be = Be.slice(t + 1)), wh(Xr, ci), a);
    } finally {
      (At = e), (Ao = !1);
    }
  }
  return null;
}
var Oi = [],
  Ii = 0,
  Os = null,
  Is = 0,
  me = [],
  ye = 0,
  vi = null,
  Re = 1,
  ze = "";
function di(t, e) {
  (Oi[Ii++] = Is), (Oi[Ii++] = Os), (Os = t), (Is = e);
}
function Zh(t, e, n) {
  (me[ye++] = Re), (me[ye++] = ze), (me[ye++] = vi), (vi = t);
  var i = Re;
  t = ze;
  var a = 32 - Ae(i) - 1;
  (i &= ~(1 << a)), (n += 1);
  var d = 32 - Ae(e) + a;
  if (30 < d) {
    var M = a - (a % 5);
    (d = (i & ((1 << M) - 1)).toString(32)),
      (i >>= M),
      (a -= M),
      (Re = (1 << (32 - Ae(e) + a)) | (n << a) | i),
      (ze = d + t);
  } else (Re = (1 << d) | (n << a) | i), (ze = t);
}
function Qr(t) {
  t.return !== null && (di(t, 1), Zh(t, 1, 0));
}
function Jr(t) {
  for (; t === Os; )
    (Os = Oi[--Ii]), (Oi[Ii] = null), (Is = Oi[--Ii]), (Oi[Ii] = null);
  for (; t === vi; )
    (vi = me[--ye]),
      (me[ye] = null),
      (ze = me[--ye]),
      (me[ye] = null),
      (Re = me[--ye]),
      (me[ye] = null);
}
var de = null,
  ce = null,
  jt = !1,
  Pe = null;
function Qh(t, e) {
  var n = xe(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function al(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (de = t), (ce = ei(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (de = t), (ce = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = vi !== null ? { id: Re, overflow: ze } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = xe(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (de = t),
            (ce = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function cr(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function dr(t) {
  if (jt) {
    var e = ce;
    if (e) {
      var n = e;
      if (!al(t, e)) {
        if (cr(t)) throw Error(mt(418));
        e = ei(n.nextSibling);
        var i = de;
        e && al(t, e)
          ? Qh(i, n)
          : ((t.flags = (t.flags & -4097) | 2), (jt = !1), (de = t));
      }
    } else {
      if (cr(t)) throw Error(mt(418));
      (t.flags = (t.flags & -4097) | 2), (jt = !1), (de = t);
    }
  }
}
function ll(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  de = t;
}
function ss(t) {
  if (t !== de) return !1;
  if (!jt) return ll(t), (jt = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !rr(t.type, t.memoizedProps))),
    e && (e = ce))
  ) {
    if (cr(t)) throw (Jh(), Error(mt(418)));
    for (; e; ) Qh(t, e), (e = ei(e.nextSibling));
  }
  if ((ll(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(mt(317));
    t: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              ce = ei(t.nextSibling);
              break t;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      ce = null;
    }
  } else ce = de ? ei(t.stateNode.nextSibling) : null;
  return !0;
}
function Jh() {
  for (var t = ce; t; ) t = ei(t.nextSibling);
}
function qi() {
  (ce = de = null), (jt = !1);
}
function ta(t) {
  Pe === null ? (Pe = [t]) : Pe.push(t);
}
var Ju = We.ReactCurrentBatchConfig;
function be(t, e) {
  if (t && t.defaultProps) {
    (e = Bt({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
var Bs = hi(null),
  Rs = null,
  Bi = null,
  ea = null;
function ia() {
  ea = Bi = Rs = null;
}
function na(t) {
  var e = Bs.current;
  Lt(Bs), (t._currentValue = e);
}
function ur(t, e, n) {
  for (; t !== null; ) {
    var i = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function Wi(t, e) {
  (Rs = t),
    (ea = Bi = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (oe = !0), (t.firstContext = null));
}
function Se(t) {
  var e = t._currentValue;
  if (ea !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), Bi === null)) {
      if (Rs === null) throw Error(mt(308));
      (Bi = t), (Rs.dependencies = { lanes: 0, firstContext: t });
    } else Bi = Bi.next = t;
  return e;
}
var fi = null;
function sa(t) {
  fi === null ? (fi = [t]) : fi.push(t);
}
function tc(t, e, n, i) {
  var a = e.interleaved;
  return (
    a === null ? ((n.next = n), sa(e)) : ((n.next = a.next), (a.next = n)),
    (e.interleaved = n),
    Ge(t, i)
  );
}
function Ge(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var Ve = !1;
function oa(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function ec(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function Fe(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function ii(t, e, n) {
  var i = t.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Pt & 2)) {
    var a = i.pending;
    return (
      a === null ? (e.next = e) : ((e.next = a.next), (a.next = e)),
      (i.pending = e),
      Ge(t, n)
    );
  }
  return (
    (a = i.interleaved),
    a === null ? ((e.next = e), sa(i)) : ((e.next = a.next), (a.next = e)),
    (i.interleaved = e),
    Ge(t, n)
  );
}
function ms(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), Wr(t, n);
  }
}
function hl(t, e) {
  var n = t.updateQueue,
    i = t.alternate;
  if (i !== null && ((i = i.updateQueue), n === i)) {
    var a = null,
      d = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var M = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        d === null ? (a = d = M) : (d = d.next = M), (n = n.next);
      } while (n !== null);
      d === null ? (a = d = e) : (d = d.next = e);
    } else a = d = e;
    (n = {
      baseState: i.baseState,
      firstBaseUpdate: a,
      lastBaseUpdate: d,
      shared: i.shared,
      effects: i.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function zs(t, e, n, i) {
  var a = t.updateQueue;
  Ve = !1;
  var d = a.firstBaseUpdate,
    M = a.lastBaseUpdate,
    O = a.shared.pending;
  if (O !== null) {
    a.shared.pending = null;
    var B = O,
      G = B.next;
    (B.next = null), M === null ? (d = G) : (M.next = G), (M = B);
    var Y = t.alternate;
    Y !== null &&
      ((Y = Y.updateQueue),
      (O = Y.lastBaseUpdate),
      O !== M &&
        (O === null ? (Y.firstBaseUpdate = G) : (O.next = G),
        (Y.lastBaseUpdate = B)));
  }
  if (d !== null) {
    var L = a.baseState;
    (M = 0), (Y = G = B = null), (O = d);
    do {
      var E = O.lane,
        z = O.eventTime;
      if ((i & E) === E) {
        Y !== null &&
          (Y = Y.next =
            {
              eventTime: z,
              lane: 0,
              tag: O.tag,
              payload: O.payload,
              callback: O.callback,
              next: null,
            });
        t: {
          var S = t,
            x = O;
          switch (((E = e), (z = n), x.tag)) {
            case 1:
              if (((S = x.payload), typeof S == "function")) {
                L = S.call(z, L, E);
                break t;
              }
              L = S;
              break t;
            case 3:
              S.flags = (S.flags & -65537) | 128;
            case 0:
              if (
                ((S = x.payload),
                (E = typeof S == "function" ? S.call(z, L, E) : S),
                E == null)
              )
                break t;
              L = Bt({}, L, E);
              break t;
            case 2:
              Ve = !0;
          }
        }
        O.callback !== null &&
          O.lane !== 0 &&
          ((t.flags |= 64),
          (E = a.effects),
          E === null ? (a.effects = [O]) : E.push(O));
      } else
        (z = {
          eventTime: z,
          lane: E,
          tag: O.tag,
          payload: O.payload,
          callback: O.callback,
          next: null,
        }),
          Y === null ? ((G = Y = z), (B = L)) : (Y = Y.next = z),
          (M |= E);
      if (((O = O.next), O === null)) {
        if (((O = a.shared.pending), O === null)) break;
        (E = O),
          (O = E.next),
          (E.next = null),
          (a.lastBaseUpdate = E),
          (a.shared.pending = null);
      }
    } while (1);
    if (
      (Y === null && (B = L),
      (a.baseState = B),
      (a.firstBaseUpdate = G),
      (a.lastBaseUpdate = Y),
      (e = a.shared.interleaved),
      e !== null)
    ) {
      a = e;
      do (M |= a.lane), (a = a.next);
      while (a !== e);
    } else d === null && (a.shared.lanes = 0);
    (wi |= M), (t.lanes = M), (t.memoizedState = L);
  }
}
function cl(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var i = t[e],
        a = i.callback;
      if (a !== null) {
        if (((i.callback = null), (i = n), typeof a != "function"))
          throw Error(mt(191, a));
        a.call(i);
      }
    }
}
var ic = new th.Component().refs;
function pr(t, e, n, i) {
  (e = t.memoizedState),
    (n = n(i, e)),
    (n = n == null ? e : Bt({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var to = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Mi(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var i = ee(),
      a = si(t),
      d = Fe(i, a);
    (d.payload = e),
      n != null && (d.callback = n),
      (e = ii(t, d, a)),
      e !== null && (Te(e, t, a, i), ms(e, t, a));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var i = ee(),
      a = si(t),
      d = Fe(i, a);
    (d.tag = 1),
      (d.payload = e),
      n != null && (d.callback = n),
      (e = ii(t, d, a)),
      e !== null && (Te(e, t, a, i), ms(e, t, a));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = ee(),
      i = si(t),
      a = Fe(n, i);
    (a.tag = 2),
      e != null && (a.callback = e),
      (e = ii(t, a, i)),
      e !== null && (Te(e, t, i, n), ms(e, t, i));
  },
};
function dl(t, e, n, i, a, d, M) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(i, d, M)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Dn(n, i) || !Dn(a, d)
      : !0
  );
}
function nc(t, e, n) {
  var i = !1,
    a = ai,
    d = e.contextType;
  return (
    typeof d == "object" && d !== null
      ? (d = Se(d))
      : ((a = ae(e) ? xi : Qt.current),
        (i = e.contextTypes),
        (d = (i = i != null) ? Vi(t, a) : ai)),
    (e = new e(n, d)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = to),
    (t.stateNode = e),
    (e._reactInternals = t),
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = a),
      (t.__reactInternalMemoizedMaskedChildContext = d)),
    e
  );
}
function ul(t, e, n, i) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, i),
    e.state !== t && to.enqueueReplaceState(e, e.state, null);
}
function fr(t, e, n, i) {
  var a = t.stateNode;
  (a.props = n), (a.state = t.memoizedState), (a.refs = ic), oa(t);
  var d = e.contextType;
  typeof d == "object" && d !== null
    ? (a.context = Se(d))
    : ((d = ae(e) ? xi : Qt.current), (a.context = Vi(t, d))),
    (a.state = t.memoizedState),
    (d = e.getDerivedStateFromProps),
    typeof d == "function" && (pr(t, e, d, n), (a.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function" ||
      (typeof a.UNSAFE_componentWillMount != "function" &&
        typeof a.componentWillMount != "function") ||
      ((e = a.state),
      typeof a.componentWillMount == "function" && a.componentWillMount(),
      typeof a.UNSAFE_componentWillMount == "function" &&
        a.UNSAFE_componentWillMount(),
      e !== a.state && to.enqueueReplaceState(a, a.state, null),
      zs(t, n, a, i),
      (a.state = t.memoizedState)),
    typeof a.componentDidMount == "function" && (t.flags |= 4194308);
}
function ln(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(mt(309));
        var i = n.stateNode;
      }
      if (!i) throw Error(mt(147, t));
      var a = i,
        d = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === d
        ? e.ref
        : ((e = function (M) {
            var O = a.refs;
            O === ic && (O = a.refs = {}),
              M === null ? delete O[d] : (O[d] = M);
          }),
          (e._stringRef = d),
          e);
    }
    if (typeof t != "string") throw Error(mt(284));
    if (!n._owner) throw Error(mt(290, t));
  }
  return t;
}
function os(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      mt(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function pl(t) {
  var e = t._init;
  return e(t._payload);
}
function sc(t) {
  function e(h, s) {
    if (t) {
      var l = h.deletions;
      l === null ? ((h.deletions = [s]), (h.flags |= 16)) : l.push(s);
    }
  }
  function n(h, s) {
    if (!t) return null;
    for (; s !== null; ) e(h, s), (s = s.sibling);
    return null;
  }
  function i(h, s) {
    for (h = new Map(); s !== null; )
      s.key !== null ? h.set(s.key, s) : h.set(s.index, s), (s = s.sibling);
    return h;
  }
  function a(h, s) {
    return (h = oi(h, s)), (h.index = 0), (h.sibling = null), h;
  }
  function d(h, s, l) {
    return (
      (h.index = l),
      t
        ? ((l = h.alternate),
          l !== null
            ? ((l = l.index), l < s ? ((h.flags |= 2), s) : l)
            : ((h.flags |= 2), s))
        : ((h.flags |= 1048576), s)
    );
  }
  function M(h) {
    return t && h.alternate === null && (h.flags |= 2), h;
  }
  function O(h, s, l, p) {
    return s === null || s.tag !== 6
      ? ((s = Oo(l, h.mode, p)), (s.return = h), s)
      : ((s = a(s, l)), (s.return = h), s);
  }
  function B(h, s, l, p) {
    var g = l.type;
    return g === Ti
      ? Y(h, s, l.props.children, p, l.key)
      : s !== null &&
        (s.elementType === g ||
          (typeof g == "object" &&
            g !== null &&
            g.$$typeof === _e &&
            pl(g) === s.type))
      ? ((p = a(s, l.props)), (p.ref = ln(h, s, l)), (p.return = h), p)
      : ((p = ks(l.type, l.key, l.props, null, h.mode, p)),
        (p.ref = ln(h, s, l)),
        (p.return = h),
        p);
  }
  function G(h, s, l, p) {
    return s === null ||
      s.tag !== 4 ||
      s.stateNode.containerInfo !== l.containerInfo ||
      s.stateNode.implementation !== l.implementation
      ? ((s = Io(l, h.mode, p)), (s.return = h), s)
      : ((s = a(s, l.children || [])), (s.return = h), s);
  }
  function Y(h, s, l, p, g) {
    return s === null || s.tag !== 7
      ? ((s = yi(l, h.mode, p, g)), (s.return = h), s)
      : ((s = a(s, l)), (s.return = h), s);
  }
  function L(h, s, l) {
    if ((typeof s == "string" && s !== "") || typeof s == "number")
      return (s = Oo("" + s, h.mode, l)), (s.return = h), s;
    if (typeof s == "object" && s !== null) {
      switch (s.$$typeof) {
        case qn:
          return (
            (l = ks(s.type, s.key, s.props, null, h.mode, l)),
            (l.ref = ln(h, null, s)),
            (l.return = h),
            l
          );
        case Ai:
          return (s = Io(s, h.mode, l)), (s.return = h), s;
        case _e:
          var p = s._init;
          return L(h, p(s._payload), l);
      }
      if (un(s) || nn(s))
        return (s = yi(s, h.mode, l, null)), (s.return = h), s;
      os(h, s);
    }
    return null;
  }
  function E(h, s, l, p) {
    var g = s !== null ? s.key : null;
    if ((typeof l == "string" && l !== "") || typeof l == "number")
      return g !== null ? null : O(h, s, "" + l, p);
    if (typeof l == "object" && l !== null) {
      switch (l.$$typeof) {
        case qn:
          return l.key === g ? B(h, s, l, p) : null;
        case Ai:
          return l.key === g ? G(h, s, l, p) : null;
        case _e:
          return (g = l._init), E(h, s, g(l._payload), p);
      }
      if (un(l) || nn(l)) return g !== null ? null : Y(h, s, l, p, null);
      os(h, l);
    }
    return null;
  }
  function z(h, s, l, p, g) {
    if ((typeof p == "string" && p !== "") || typeof p == "number")
      return (h = h.get(l) || null), O(s, h, "" + p, g);
    if (typeof p == "object" && p !== null) {
      switch (p.$$typeof) {
        case qn:
          return (h = h.get(p.key === null ? l : p.key) || null), B(s, h, p, g);
        case Ai:
          return (h = h.get(p.key === null ? l : p.key) || null), G(s, h, p, g);
        case _e:
          var T = p._init;
          return z(h, s, l, T(p._payload), g);
      }
      if (un(p) || nn(p)) return (h = h.get(l) || null), Y(s, h, p, g, null);
      os(s, p);
    }
    return null;
  }
  function S(h, s, l, p) {
    for (
      var g = null, T = null, D = s, A = (s = 0), m = null;
      D !== null && A < l.length;
      A++
    ) {
      D.index > A ? ((m = D), (D = null)) : (m = D.sibling);
      var f = E(h, D, l[A], p);
      if (f === null) {
        D === null && (D = m);
        break;
      }
      t && D && f.alternate === null && e(h, D),
        (s = d(f, s, A)),
        T === null ? (g = f) : (T.sibling = f),
        (T = f),
        (D = m);
    }
    if (A === l.length) return n(h, D), jt && di(h, A), g;
    if (D === null) {
      for (; A < l.length; A++)
        (D = L(h, l[A], p)),
          D !== null &&
            ((s = d(D, s, A)), T === null ? (g = D) : (T.sibling = D), (T = D));
      return jt && di(h, A), g;
    }
    for (D = i(h, D); A < l.length; A++)
      (m = z(D, h, A, l[A], p)),
        m !== null &&
          (t && m.alternate !== null && D.delete(m.key === null ? A : m.key),
          (s = d(m, s, A)),
          T === null ? (g = m) : (T.sibling = m),
          (T = m));
    return (
      t &&
        D.forEach(function (b) {
          return e(h, b);
        }),
      jt && di(h, A),
      g
    );
  }
  function x(h, s, l, p) {
    var g = nn(l);
    if (typeof g != "function") throw Error(mt(150));
    if (((l = g.call(l)), l == null)) throw Error(mt(151));
    for (
      var T = (g = null), D = s, A = (s = 0), m = null, f = l.next();
      D !== null && !f.done;
      A++, f = l.next()
    ) {
      D.index > A ? ((m = D), (D = null)) : (m = D.sibling);
      var b = E(h, D, f.value, p);
      if (b === null) {
        D === null && (D = m);
        break;
      }
      t && D && b.alternate === null && e(h, D),
        (s = d(b, s, A)),
        T === null ? (g = b) : (T.sibling = b),
        (T = b),
        (D = m);
    }
    if (f.done) return n(h, D), jt && di(h, A), g;
    if (D === null) {
      for (; !f.done; A++, f = l.next())
        (f = L(h, f.value, p)),
          f !== null &&
            ((s = d(f, s, A)), T === null ? (g = f) : (T.sibling = f), (T = f));
      return jt && di(h, A), g;
    }
    for (D = i(h, D); !f.done; A++, f = l.next())
      (f = z(D, h, A, f.value, p)),
        f !== null &&
          (t && f.alternate !== null && D.delete(f.key === null ? A : f.key),
          (s = d(f, s, A)),
          T === null ? (g = f) : (T.sibling = f),
          (T = f));
    return (
      t &&
        D.forEach(function (y) {
          return e(h, y);
        }),
      jt && di(h, A),
      g
    );
  }
  function P(h, s, l, p) {
    if (
      (typeof l == "object" &&
        l !== null &&
        l.type === Ti &&
        l.key === null &&
        (l = l.props.children),
      typeof l == "object" && l !== null)
    ) {
      switch (l.$$typeof) {
        case qn:
          t: {
            for (var g = l.key, T = s; T !== null; ) {
              if (T.key === g) {
                if (((g = l.type), g === Ti)) {
                  if (T.tag === 7) {
                    n(h, T.sibling),
                      (s = a(T, l.props.children)),
                      (s.return = h),
                      (h = s);
                    break t;
                  }
                } else if (
                  T.elementType === g ||
                  (typeof g == "object" &&
                    g !== null &&
                    g.$$typeof === _e &&
                    pl(g) === T.type)
                ) {
                  n(h, T.sibling),
                    (s = a(T, l.props)),
                    (s.ref = ln(h, T, l)),
                    (s.return = h),
                    (h = s);
                  break t;
                }
                n(h, T);
                break;
              } else e(h, T);
              T = T.sibling;
            }
            l.type === Ti
              ? ((s = yi(l.props.children, h.mode, p, l.key)),
                (s.return = h),
                (h = s))
              : ((p = ks(l.type, l.key, l.props, null, h.mode, p)),
                (p.ref = ln(h, s, l)),
                (p.return = h),
                (h = p));
          }
          return M(h);
        case Ai:
          t: {
            for (T = l.key; s !== null; ) {
              if (s.key === T)
                if (
                  s.tag === 4 &&
                  s.stateNode.containerInfo === l.containerInfo &&
                  s.stateNode.implementation === l.implementation
                ) {
                  n(h, s.sibling),
                    (s = a(s, l.children || [])),
                    (s.return = h),
                    (h = s);
                  break t;
                } else {
                  n(h, s);
                  break;
                }
              else e(h, s);
              s = s.sibling;
            }
            (s = Io(l, h.mode, p)), (s.return = h), (h = s);
          }
          return M(h);
        case _e:
          return (T = l._init), P(h, s, T(l._payload), p);
      }
      if (un(l)) return S(h, s, l, p);
      if (nn(l)) return x(h, s, l, p);
      os(h, l);
    }
    return (typeof l == "string" && l !== "") || typeof l == "number"
      ? ((l = "" + l),
        s !== null && s.tag === 6
          ? (n(h, s.sibling), (s = a(s, l)), (s.return = h), (h = s))
          : (n(h, s), (s = Oo(l, h.mode, p)), (s.return = h), (h = s)),
        M(h))
      : n(h, s);
  }
  return P;
}
var Ki = sc(!0),
  oc = sc(!1),
  Yn = {},
  Oe = hi(Yn),
  In = hi(Yn),
  Bn = hi(Yn);
function gi(t) {
  if (t === Yn) throw Error(mt(174));
  return t;
}
function ra(t, e) {
  switch ((Tt(Bn, e), Tt(In, t), Tt(Oe, Yn), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : _o(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = _o(e, t));
  }
  Lt(Oe), Tt(Oe, e);
}
function $i() {
  Lt(Oe), Lt(In), Lt(Bn);
}
function rc(t) {
  gi(Bn.current);
  var e = gi(Oe.current),
    n = _o(e, t.type);
  e !== n && (Tt(In, t), Tt(Oe, n));
}
function aa(t) {
  In.current === t && (Lt(Oe), Lt(In));
}
var Ot = hi(0);
function Fs(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var To = [];
function la() {
  for (var t = 0; t < To.length; t++)
    To[t]._workInProgressVersionPrimary = null;
  To.length = 0;
}
var ys = We.ReactCurrentDispatcher,
  Eo = We.ReactCurrentBatchConfig,
  Si = 0,
  It = null,
  Ut = null,
  Xt = null,
  Hs = !1,
  Sn = !1,
  Rn = 0,
  tp = 0;
function Kt() {
  throw Error(mt(321));
}
function ha(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!Ee(t[n], e[n])) return !1;
  return !0;
}
function ca(t, e, n, i, a, d) {
  if (
    ((Si = d),
    (It = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (ys.current = t === null || t.memoizedState === null ? sp : op),
    (t = n(i, a)),
    Sn)
  ) {
    d = 0;
    do {
      if (((Sn = !1), (Rn = 0), 25 <= d)) throw Error(mt(301));
      (d += 1),
        (Xt = Ut = null),
        (e.updateQueue = null),
        (ys.current = rp),
        (t = n(i, a));
    } while (Sn);
  }
  if (
    ((ys.current = Us),
    (e = Ut !== null && Ut.next !== null),
    (Si = 0),
    (Xt = Ut = It = null),
    (Hs = !1),
    e)
  )
    throw Error(mt(300));
  return t;
}
function da() {
  var t = Rn !== 0;
  return (Rn = 0), t;
}
function De() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Xt === null ? (It.memoizedState = Xt = t) : (Xt = Xt.next = t), Xt;
}
function we() {
  if (Ut === null) {
    var t = It.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Ut.next;
  var e = Xt === null ? It.memoizedState : Xt.next;
  if (e !== null) (Xt = e), (Ut = t);
  else {
    if (t === null) throw Error(mt(310));
    (Ut = t),
      (t = {
        memoizedState: Ut.memoizedState,
        baseState: Ut.baseState,
        baseQueue: Ut.baseQueue,
        queue: Ut.queue,
        next: null,
      }),
      Xt === null ? (It.memoizedState = Xt = t) : (Xt = Xt.next = t);
  }
  return Xt;
}
function zn(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function Lo(t) {
  var e = we(),
    n = e.queue;
  if (n === null) throw Error(mt(311));
  n.lastRenderedReducer = t;
  var i = Ut,
    a = i.baseQueue,
    d = n.pending;
  if (d !== null) {
    if (a !== null) {
      var M = a.next;
      (a.next = d.next), (d.next = M);
    }
    (i.baseQueue = a = d), (n.pending = null);
  }
  if (a !== null) {
    (d = a.next), (i = i.baseState);
    var O = (M = null),
      B = null,
      G = d;
    do {
      var Y = G.lane;
      if ((Si & Y) === Y)
        B !== null &&
          (B = B.next =
            {
              lane: 0,
              action: G.action,
              hasEagerState: G.hasEagerState,
              eagerState: G.eagerState,
              next: null,
            }),
          (i = G.hasEagerState ? G.eagerState : t(i, G.action));
      else {
        var L = {
          lane: Y,
          action: G.action,
          hasEagerState: G.hasEagerState,
          eagerState: G.eagerState,
          next: null,
        };
        B === null ? ((O = B = L), (M = i)) : (B = B.next = L),
          (It.lanes |= Y),
          (wi |= Y);
      }
      G = G.next;
    } while (G !== null && G !== d);
    B === null ? (M = i) : (B.next = O),
      Ee(i, e.memoizedState) || (oe = !0),
      (e.memoizedState = i),
      (e.baseState = M),
      (e.baseQueue = B),
      (n.lastRenderedState = i);
  }
  if (((t = n.interleaved), t !== null)) {
    a = t;
    do (d = a.lane), (It.lanes |= d), (wi |= d), (a = a.next);
    while (a !== t);
  } else a === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function Do(t) {
  var e = we(),
    n = e.queue;
  if (n === null) throw Error(mt(311));
  n.lastRenderedReducer = t;
  var i = n.dispatch,
    a = n.pending,
    d = e.memoizedState;
  if (a !== null) {
    n.pending = null;
    var M = (a = a.next);
    do (d = t(d, M.action)), (M = M.next);
    while (M !== a);
    Ee(d, e.memoizedState) || (oe = !0),
      (e.memoizedState = d),
      e.baseQueue === null && (e.baseState = d),
      (n.lastRenderedState = d);
  }
  return [d, i];
}
function ac() {}
function lc(t, e) {
  var n = It,
    i = we(),
    a = e(),
    d = !Ee(i.memoizedState, a);
  if (
    (d && ((i.memoizedState = a), (oe = !0)),
    (i = i.queue),
    ua(dc.bind(null, n, i, t), [t]),
    i.getSnapshot !== e || d || (Xt !== null && Xt.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Fn(9, cc.bind(null, n, i, a, e), void 0, null),
      Wt === null)
    )
      throw Error(mt(349));
    Si & 30 || hc(n, e, a);
  }
  return a;
}
function hc(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = It.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (It.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function cc(t, e, n, i) {
  (e.value = n), (e.getSnapshot = i), uc(e) && pc(t);
}
function dc(t, e, n) {
  return n(function () {
    uc(e) && pc(t);
  });
}
function uc(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !Ee(t, n);
  } catch {
    return !0;
  }
}
function pc(t) {
  var e = Ge(t, 1);
  e !== null && Te(e, t, 1, -1);
}
function fl(t) {
  var e = De();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: zn,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = np.bind(null, It, t)),
    [e.memoizedState, t]
  );
}
function Fn(t, e, n, i) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: i, next: null }),
    (e = It.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (It.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((i = n.next), (n.next = t), (t.next = i), (e.lastEffect = t))),
    t
  );
}
function fc() {
  return we().memoizedState;
}
function xs(t, e, n, i) {
  var a = De();
  (It.flags |= t),
    (a.memoizedState = Fn(1 | e, n, void 0, i === void 0 ? null : i));
}
function eo(t, e, n, i) {
  var a = we();
  i = i === void 0 ? null : i;
  var d = void 0;
  if (Ut !== null) {
    var M = Ut.memoizedState;
    if (((d = M.destroy), i !== null && ha(i, M.deps))) {
      a.memoizedState = Fn(e, n, d, i);
      return;
    }
  }
  (It.flags |= t), (a.memoizedState = Fn(1 | e, n, d, i));
}
function gl(t, e) {
  return xs(8390656, 8, t, e);
}
function ua(t, e) {
  return eo(2048, 8, t, e);
}
function gc(t, e) {
  return eo(4, 2, t, e);
}
function mc(t, e) {
  return eo(4, 4, t, e);
}
function yc(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function xc(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), eo(4, 4, yc.bind(null, e, t), n)
  );
}
function pa() {}
function vc(t, e) {
  var n = we();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && ha(e, i[1])
    ? i[0]
    : ((n.memoizedState = [t, e]), t);
}
function Sc(t, e) {
  var n = we();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && ha(e, i[1])
    ? i[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function wc(t, e, n) {
  return Si & 21
    ? (Ee(n, e) || ((n = bh()), (It.lanes |= n), (wi |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (oe = !0)), (t.memoizedState = n));
}
function ep(t, e) {
  var n = At;
  (At = n !== 0 && 4 > n ? n : 4), t(!0);
  var i = Eo.transition;
  Eo.transition = {};
  try {
    t(!1), e();
  } finally {
    (At = n), (Eo.transition = i);
  }
}
function kc() {
  return we().memoizedState;
}
function ip(t, e, n) {
  var i = si(t);
  if (
    ((n = {
      lane: i,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Cc(t))
  )
    bc(e, n);
  else if (((n = tc(t, e, n, i)), n !== null)) {
    var a = ee();
    Te(n, t, i, a), Mc(n, e, i);
  }
}
function np(t, e, n) {
  var i = si(t),
    a = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (Cc(t)) bc(e, a);
  else {
    var d = t.alternate;
    if (
      t.lanes === 0 &&
      (d === null || d.lanes === 0) &&
      ((d = e.lastRenderedReducer), d !== null)
    )
      try {
        var M = e.lastRenderedState,
          O = d(M, n);
        if (((a.hasEagerState = !0), (a.eagerState = O), Ee(O, M))) {
          var B = e.interleaved;
          B === null
            ? ((a.next = a), sa(e))
            : ((a.next = B.next), (B.next = a)),
            (e.interleaved = a);
          return;
        }
      } catch {
      } finally {
      }
    (n = tc(t, e, a, i)),
      n !== null && ((a = ee()), Te(n, t, i, a), Mc(n, e, i));
  }
}
function Cc(t) {
  var e = t.alternate;
  return t === It || (e !== null && e === It);
}
function bc(t, e) {
  Sn = Hs = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function Mc(t, e, n) {
  if (n & 4194240) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), Wr(t, n);
  }
}
var Us = {
    readContext: Se,
    useCallback: Kt,
    useContext: Kt,
    useEffect: Kt,
    useImperativeHandle: Kt,
    useInsertionEffect: Kt,
    useLayoutEffect: Kt,
    useMemo: Kt,
    useReducer: Kt,
    useRef: Kt,
    useState: Kt,
    useDebugValue: Kt,
    useDeferredValue: Kt,
    useTransition: Kt,
    useMutableSource: Kt,
    useSyncExternalStore: Kt,
    useId: Kt,
    unstable_isNewReconciler: !1,
  },
  sp = {
    readContext: Se,
    useCallback: function (t, e) {
      return (De().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: Se,
    useEffect: gl,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        xs(4194308, 4, yc.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return xs(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return xs(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = De();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var i = De();
      return (
        (e = n !== void 0 ? n(e) : e),
        (i.memoizedState = i.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (i.queue = t),
        (t = t.dispatch = ip.bind(null, It, t)),
        [i.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = De();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: fl,
    useDebugValue: pa,
    useDeferredValue: function (t) {
      return (De().memoizedState = t);
    },
    useTransition: function () {
      var t = fl(!1),
        e = t[0];
      return (t = ep.bind(null, t[1])), (De().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var i = It,
        a = De();
      if (jt) {
        if (n === void 0) throw Error(mt(407));
        n = n();
      } else {
        if (((n = e()), Wt === null)) throw Error(mt(349));
        Si & 30 || hc(i, e, n);
      }
      a.memoizedState = n;
      var d = { value: n, getSnapshot: e };
      return (
        (a.queue = d),
        gl(dc.bind(null, i, d, t), [t]),
        (i.flags |= 2048),
        Fn(9, cc.bind(null, i, d, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = De(),
        e = Wt.identifierPrefix;
      if (jt) {
        var n = ze,
          i = Re;
        (n = (i & ~(1 << (32 - Ae(i) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = Rn++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = tp++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  op = {
    readContext: Se,
    useCallback: vc,
    useContext: Se,
    useEffect: ua,
    useImperativeHandle: xc,
    useInsertionEffect: gc,
    useLayoutEffect: mc,
    useMemo: Sc,
    useReducer: Lo,
    useRef: fc,
    useState: function () {
      return Lo(zn);
    },
    useDebugValue: pa,
    useDeferredValue: function (t) {
      var e = we();
      return wc(e, Ut.memoizedState, t);
    },
    useTransition: function () {
      var t = Lo(zn)[0],
        e = we().memoizedState;
      return [t, e];
    },
    useMutableSource: ac,
    useSyncExternalStore: lc,
    useId: kc,
    unstable_isNewReconciler: !1,
  },
  rp = {
    readContext: Se,
    useCallback: vc,
    useContext: Se,
    useEffect: ua,
    useImperativeHandle: xc,
    useInsertionEffect: gc,
    useLayoutEffect: mc,
    useMemo: Sc,
    useReducer: Do,
    useRef: fc,
    useState: function () {
      return Do(zn);
    },
    useDebugValue: pa,
    useDeferredValue: function (t) {
      var e = we();
      return Ut === null ? (e.memoizedState = t) : wc(e, Ut.memoizedState, t);
    },
    useTransition: function () {
      var t = Do(zn)[0],
        e = we().memoizedState;
      return [t, e];
    },
    useMutableSource: ac,
    useSyncExternalStore: lc,
    useId: kc,
    unstable_isNewReconciler: !1,
  };
function Zi(t, e) {
  try {
    var n = "",
      i = e;
    do (n += Od(i)), (i = i.return);
    while (i);
    var a = n;
  } catch (d) {
    a =
      `
Error generating stack: ` +
      d.message +
      `
` +
      d.stack;
  }
  return { value: t, source: e, stack: a, digest: null };
}
function jo(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function gr(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var ap = typeof WeakMap == "function" ? WeakMap : Map;
function Pc(t, e, n) {
  (n = Fe(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var i = e.value;
  return (
    (n.callback = function () {
      Xs || ((Xs = !0), (Mr = i)), gr(t, e);
    }),
    n
  );
}
function Ac(t, e, n) {
  (n = Fe(-1, n)), (n.tag = 3);
  var i = t.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var a = e.value;
    (n.payload = function () {
      return i(a);
    }),
      (n.callback = function () {
        gr(t, e);
      });
  }
  var d = t.stateNode;
  return (
    d !== null &&
      typeof d.componentDidCatch == "function" &&
      (n.callback = function () {
        gr(t, e),
          typeof i != "function" &&
            (ni === null ? (ni = new Set([this])) : ni.add(this));
        var M = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: M !== null ? M : "",
        });
      }),
    n
  );
}
function ml(t, e, n) {
  var i = t.pingCache;
  if (i === null) {
    i = t.pingCache = new ap();
    var a = new Set();
    i.set(e, a);
  } else (a = i.get(e)), a === void 0 && ((a = new Set()), i.set(e, a));
  a.has(n) || (a.add(n), (t = wp.bind(null, t, e, n)), e.then(t, t));
}
function yl(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function xl(t, e, n, i, a) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = a), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = Fe(-1, 1)), (e.tag = 2), ii(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var lp = We.ReactCurrentOwner,
  oe = !1;
function te(t, e, n, i) {
  e.child = t === null ? oc(e, null, n, i) : Ki(e, t.child, n, i);
}
function vl(t, e, n, i, a) {
  n = n.render;
  var d = e.ref;
  return (
    Wi(e, a),
    (i = ca(t, e, n, i, d, a)),
    (n = da()),
    t !== null && !oe
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~a),
        Xe(t, e, a))
      : (jt && n && Qr(e), (e.flags |= 1), te(t, e, i, a), e.child)
  );
}
function Sl(t, e, n, i, a) {
  if (t === null) {
    var d = n.type;
    return typeof d == "function" &&
      !wa(d) &&
      d.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = d), Tc(t, e, d, i, a))
      : ((t = ks(n.type, null, i, e, e.mode, a)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((d = t.child), !(t.lanes & a))) {
    var M = d.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Dn), n(M, i) && t.ref === e.ref)
    )
      return Xe(t, e, a);
  }
  return (
    (e.flags |= 1),
    (t = oi(d, i)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function Tc(t, e, n, i, a) {
  if (t !== null) {
    var d = t.memoizedProps;
    if (Dn(d, i) && t.ref === e.ref)
      if (((oe = !1), (e.pendingProps = i = d), (t.lanes & a) !== 0))
        t.flags & 131072 && (oe = !0);
      else return (e.lanes = t.lanes), Xe(t, e, a);
  }
  return mr(t, e, n, i, a);
}
function Ec(t, e, n) {
  var i = e.pendingProps,
    a = i.children,
    d = t !== null ? t.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Tt(zi, he),
        (he |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = d !== null ? d.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Tt(zi, he),
          (he |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = d !== null ? d.baseLanes : n),
        Tt(zi, he),
        (he |= i);
    }
  else
    d !== null ? ((i = d.baseLanes | n), (e.memoizedState = null)) : (i = n),
      Tt(zi, he),
      (he |= i);
  return te(t, e, a, n), e.child;
}
function Lc(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function mr(t, e, n, i, a) {
  var d = ae(n) ? xi : Qt.current;
  return (
    (d = Vi(e, d)),
    Wi(e, a),
    (n = ca(t, e, n, i, d, a)),
    (i = da()),
    t !== null && !oe
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~a),
        Xe(t, e, a))
      : (jt && i && Qr(e), (e.flags |= 1), te(t, e, n, a), e.child)
  );
}
function wl(t, e, n, i, a) {
  if (ae(n)) {
    var d = !0;
    Ns(e);
  } else d = !1;
  if ((Wi(e, a), e.stateNode === null))
    vs(t, e), nc(e, n, i), fr(e, n, i, a), (i = !0);
  else if (t === null) {
    var M = e.stateNode,
      O = e.memoizedProps;
    M.props = O;
    var B = M.context,
      G = n.contextType;
    typeof G == "object" && G !== null
      ? (G = Se(G))
      : ((G = ae(n) ? xi : Qt.current), (G = Vi(e, G)));
    var Y = n.getDerivedStateFromProps,
      L =
        typeof Y == "function" ||
        typeof M.getSnapshotBeforeUpdate == "function";
    L ||
      (typeof M.UNSAFE_componentWillReceiveProps != "function" &&
        typeof M.componentWillReceiveProps != "function") ||
      ((O !== i || B !== G) && ul(e, M, i, G)),
      (Ve = !1);
    var E = e.memoizedState;
    (M.state = E),
      zs(e, i, M, a),
      (B = e.memoizedState),
      O !== i || E !== B || re.current || Ve
        ? (typeof Y == "function" && (pr(e, n, Y, i), (B = e.memoizedState)),
          (O = Ve || dl(e, n, O, i, E, B, G))
            ? (L ||
                (typeof M.UNSAFE_componentWillMount != "function" &&
                  typeof M.componentWillMount != "function") ||
                (typeof M.componentWillMount == "function" &&
                  M.componentWillMount(),
                typeof M.UNSAFE_componentWillMount == "function" &&
                  M.UNSAFE_componentWillMount()),
              typeof M.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof M.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = B)),
          (M.props = i),
          (M.state = B),
          (M.context = G),
          (i = O))
        : (typeof M.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (M = e.stateNode),
      ec(t, e),
      (O = e.memoizedProps),
      (G = e.type === e.elementType ? O : be(e.type, O)),
      (M.props = G),
      (L = e.pendingProps),
      (E = M.context),
      (B = n.contextType),
      typeof B == "object" && B !== null
        ? (B = Se(B))
        : ((B = ae(n) ? xi : Qt.current), (B = Vi(e, B)));
    var z = n.getDerivedStateFromProps;
    (Y =
      typeof z == "function" ||
      typeof M.getSnapshotBeforeUpdate == "function") ||
      (typeof M.UNSAFE_componentWillReceiveProps != "function" &&
        typeof M.componentWillReceiveProps != "function") ||
      ((O !== L || E !== B) && ul(e, M, i, B)),
      (Ve = !1),
      (E = e.memoizedState),
      (M.state = E),
      zs(e, i, M, a);
    var S = e.memoizedState;
    O !== L || E !== S || re.current || Ve
      ? (typeof z == "function" && (pr(e, n, z, i), (S = e.memoizedState)),
        (G = Ve || dl(e, n, G, i, E, S, B) || !1)
          ? (Y ||
              (typeof M.UNSAFE_componentWillUpdate != "function" &&
                typeof M.componentWillUpdate != "function") ||
              (typeof M.componentWillUpdate == "function" &&
                M.componentWillUpdate(i, S, B),
              typeof M.UNSAFE_componentWillUpdate == "function" &&
                M.UNSAFE_componentWillUpdate(i, S, B)),
            typeof M.componentDidUpdate == "function" && (e.flags |= 4),
            typeof M.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof M.componentDidUpdate != "function" ||
              (O === t.memoizedProps && E === t.memoizedState) ||
              (e.flags |= 4),
            typeof M.getSnapshotBeforeUpdate != "function" ||
              (O === t.memoizedProps && E === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = S)),
        (M.props = i),
        (M.state = S),
        (M.context = B),
        (i = G))
      : (typeof M.componentDidUpdate != "function" ||
          (O === t.memoizedProps && E === t.memoizedState) ||
          (e.flags |= 4),
        typeof M.getSnapshotBeforeUpdate != "function" ||
          (O === t.memoizedProps && E === t.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return yr(t, e, n, i, d, a);
}
function yr(t, e, n, i, a, d) {
  Lc(t, e);
  var M = (e.flags & 128) !== 0;
  if (!i && !M) return a && rl(e, n, !1), Xe(t, e, d);
  (i = e.stateNode), (lp.current = e);
  var O =
    M && typeof n.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    t !== null && M
      ? ((e.child = Ki(e, t.child, null, d)), (e.child = Ki(e, null, O, d)))
      : te(t, e, O, d),
    (e.memoizedState = i.state),
    a && rl(e, n, !0),
    e.child
  );
}
function Dc(t) {
  var e = t.stateNode;
  e.pendingContext
    ? ol(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && ol(t, e.context, !1),
    ra(t, e.containerInfo);
}
function kl(t, e, n, i, a) {
  return qi(), ta(a), (e.flags |= 256), te(t, e, n, i), e.child;
}
var xr = { dehydrated: null, treeContext: null, retryLane: 0 };
function vr(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function jc(t, e, n) {
  var i = e.pendingProps,
    a = Ot.current,
    d = !1,
    M = (e.flags & 128) !== 0,
    O;
  if (
    ((O = M) ||
      (O = t !== null && t.memoizedState === null ? !1 : (a & 2) !== 0),
    O
      ? ((d = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (a |= 1),
    Tt(Ot, a & 1),
    t === null)
  )
    return (
      dr(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((M = i.children),
          (t = i.fallback),
          d
            ? ((i = e.mode),
              (d = e.child),
              (M = { mode: "hidden", children: M }),
              !(i & 1) && d !== null
                ? ((d.childLanes = 0), (d.pendingProps = M))
                : (d = so(M, i, 0, null)),
              (t = yi(t, i, n, null)),
              (d.return = e),
              (t.return = e),
              (d.sibling = t),
              (e.child = d),
              (e.child.memoizedState = vr(n)),
              (e.memoizedState = xr),
              t)
            : fa(e, M))
    );
  if (((a = t.memoizedState), a !== null && ((O = a.dehydrated), O !== null)))
    return hp(t, e, M, i, O, a, n);
  if (d) {
    (d = i.fallback), (M = e.mode), (a = t.child), (O = a.sibling);
    var B = { mode: "hidden", children: i.children };
    return (
      !(M & 1) && e.child !== a
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = B),
          (e.deletions = null))
        : ((i = oi(a, B)), (i.subtreeFlags = a.subtreeFlags & 14680064)),
      O !== null ? (d = oi(O, d)) : ((d = yi(d, M, n, null)), (d.flags |= 2)),
      (d.return = e),
      (i.return = e),
      (i.sibling = d),
      (e.child = i),
      (i = d),
      (d = e.child),
      (M = t.child.memoizedState),
      (M =
        M === null
          ? vr(n)
          : {
              baseLanes: M.baseLanes | n,
              cachePool: null,
              transitions: M.transitions,
            }),
      (d.memoizedState = M),
      (d.childLanes = t.childLanes & ~n),
      (e.memoizedState = xr),
      i
    );
  }
  return (
    (d = t.child),
    (t = d.sibling),
    (i = oi(d, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = n),
    (i.return = e),
    (i.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function fa(t, e) {
  return (
    (e = so({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function rs(t, e, n, i) {
  return (
    i !== null && ta(i),
    Ki(e, t.child, null, n),
    (t = fa(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function hp(t, e, n, i, a, d, M) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (i = jo(Error(mt(422)))), rs(t, e, M, i))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((d = i.fallback),
        (a = e.mode),
        (i = so({ mode: "visible", children: i.children }, a, 0, null)),
        (d = yi(d, a, M, null)),
        (d.flags |= 2),
        (i.return = e),
        (d.return = e),
        (i.sibling = d),
        (e.child = i),
        e.mode & 1 && Ki(e, t.child, null, M),
        (e.child.memoizedState = vr(M)),
        (e.memoizedState = xr),
        d);
  if (!(e.mode & 1)) return rs(t, e, M, null);
  if (a.data === "$!") {
    if (((i = a.nextSibling && a.nextSibling.dataset), i)) var O = i.dgst;
    return (
      (i = O), (d = Error(mt(419))), (i = jo(d, i, void 0)), rs(t, e, M, i)
    );
  }
  if (((O = (M & t.childLanes) !== 0), oe || O)) {
    if (((i = Wt), i !== null)) {
      switch (M & -M) {
        case 4:
          a = 2;
          break;
        case 16:
          a = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          a = 32;
          break;
        case 536870912:
          a = 268435456;
          break;
        default:
          a = 0;
      }
      (a = a & (i.suspendedLanes | M) ? 0 : a),
        a !== 0 &&
          a !== d.retryLane &&
          ((d.retryLane = a), Ge(t, a), Te(i, t, a, -1));
    }
    return Sa(), (i = jo(Error(mt(421)))), rs(t, e, M, i);
  }
  return a.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = kp.bind(null, t)),
      (a._reactRetry = e),
      null)
    : ((t = d.treeContext),
      (ce = ei(a.nextSibling)),
      (de = e),
      (jt = !0),
      (Pe = null),
      t !== null &&
        ((me[ye++] = Re),
        (me[ye++] = ze),
        (me[ye++] = vi),
        (Re = t.id),
        (ze = t.overflow),
        (vi = e)),
      (e = fa(e, i.children)),
      (e.flags |= 4096),
      e);
}
function Cl(t, e, n) {
  t.lanes |= e;
  var i = t.alternate;
  i !== null && (i.lanes |= e), ur(t.return, e, n);
}
function No(t, e, n, i, a) {
  var d = t.memoizedState;
  d === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: n,
        tailMode: a,
      })
    : ((d.isBackwards = e),
      (d.rendering = null),
      (d.renderingStartTime = 0),
      (d.last = i),
      (d.tail = n),
      (d.tailMode = a));
}
function Nc(t, e, n) {
  var i = e.pendingProps,
    a = i.revealOrder,
    d = i.tail;
  if ((te(t, e, i.children, n), (i = Ot.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      t: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && Cl(t, n, e);
        else if (t.tag === 19) Cl(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break t;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break t;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    i &= 1;
  }
  if ((Tt(Ot, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (a) {
      case "forwards":
        for (n = e.child, a = null; n !== null; )
          (t = n.alternate),
            t !== null && Fs(t) === null && (a = n),
            (n = n.sibling);
        (n = a),
          n === null
            ? ((a = e.child), (e.child = null))
            : ((a = n.sibling), (n.sibling = null)),
          No(e, !1, a, n, d);
        break;
      case "backwards":
        for (n = null, a = e.child, e.child = null; a !== null; ) {
          if (((t = a.alternate), t !== null && Fs(t) === null)) {
            e.child = a;
            break;
          }
          (t = a.sibling), (a.sibling = n), (n = a), (a = t);
        }
        No(e, !0, n, null, d);
        break;
      case "together":
        No(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function vs(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Xe(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (wi |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(mt(153));
  if (e.child !== null) {
    for (
      t = e.child, n = oi(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = oi(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function cp(t, e, n) {
  switch (e.tag) {
    case 3:
      Dc(e), qi();
      break;
    case 5:
      rc(e);
      break;
    case 1:
      ae(e.type) && Ns(e);
      break;
    case 4:
      ra(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        a = e.memoizedProps.value;
      Tt(Bs, i._currentValue), (i._currentValue = a);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (Tt(Ot, Ot.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? jc(t, e, n)
          : (Tt(Ot, Ot.current & 1),
            (t = Xe(t, e, n)),
            t !== null ? t.sibling : null);
      Tt(Ot, Ot.current & 1);
      break;
    case 19:
      if (((i = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (i) return Nc(t, e, n);
        e.flags |= 128;
      }
      if (
        ((a = e.memoizedState),
        a !== null &&
          ((a.rendering = null), (a.tail = null), (a.lastEffect = null)),
        Tt(Ot, Ot.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), Ec(t, e, n);
  }
  return Xe(t, e, n);
}
var Oc, Sr, Ic, Bc;
Oc = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
Sr = function () {};
Ic = function (t, e, n, i) {
  var a = t.memoizedProps;
  if (a !== i) {
    (t = e.stateNode), gi(Oe.current);
    var d = null;
    switch (n) {
      case "input":
        (a = Go(t, a)), (i = Go(t, i)), (d = []);
        break;
      case "select":
        (a = Bt({}, a, { value: void 0 })),
          (i = Bt({}, i, { value: void 0 })),
          (d = []);
        break;
      case "textarea":
        (a = Yo(t, a)), (i = Yo(t, i)), (d = []);
        break;
      default:
        typeof a.onClick != "function" &&
          typeof i.onClick == "function" &&
          (t.onclick = Ds);
    }
    Vo(n, i);
    var M;
    n = null;
    for (G in a)
      if (!i.hasOwnProperty(G) && a.hasOwnProperty(G) && a[G] != null)
        if (G === "style") {
          var O = a[G];
          for (M in O) O.hasOwnProperty(M) && (n || (n = {}), (n[M] = ""));
        } else
          G !== "dangerouslySetInnerHTML" &&
            G !== "children" &&
            G !== "suppressContentEditableWarning" &&
            G !== "suppressHydrationWarning" &&
            G !== "autoFocus" &&
            (bn.hasOwnProperty(G)
              ? d || (d = [])
              : (d = d || []).push(G, null));
    for (G in i) {
      var B = i[G];
      if (
        ((O = a != null ? a[G] : void 0),
        i.hasOwnProperty(G) && B !== O && (B != null || O != null))
      )
        if (G === "style")
          if (O) {
            for (M in O)
              !O.hasOwnProperty(M) ||
                (B && B.hasOwnProperty(M)) ||
                (n || (n = {}), (n[M] = ""));
            for (M in B)
              B.hasOwnProperty(M) &&
                O[M] !== B[M] &&
                (n || (n = {}), (n[M] = B[M]));
          } else n || (d || (d = []), d.push(G, n)), (n = B);
        else
          G === "dangerouslySetInnerHTML"
            ? ((B = B ? B.__html : void 0),
              (O = O ? O.__html : void 0),
              B != null && O !== B && (d = d || []).push(G, B))
            : G === "children"
            ? (typeof B != "string" && typeof B != "number") ||
              (d = d || []).push(G, "" + B)
            : G !== "suppressContentEditableWarning" &&
              G !== "suppressHydrationWarning" &&
              (bn.hasOwnProperty(G)
                ? (B != null && G === "onScroll" && Et("scroll", t),
                  d || O === B || (d = []))
                : (d = d || []).push(G, B));
    }
    n && (d = d || []).push("style", n);
    var G = d;
    (e.updateQueue = G) && (e.flags |= 4);
  }
};
Bc = function (t, e, n, i) {
  n !== i && (e.flags |= 4);
};
function hn(t, e) {
  if (!jt)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var i = null; n !== null; )
          n.alternate !== null && (i = n), (n = n.sibling);
        i === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (i.sibling = null);
    }
}
function $t(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    i = 0;
  if (e)
    for (var a = t.child; a !== null; )
      (n |= a.lanes | a.childLanes),
        (i |= a.subtreeFlags & 14680064),
        (i |= a.flags & 14680064),
        (a.return = t),
        (a = a.sibling);
  else
    for (a = t.child; a !== null; )
      (n |= a.lanes | a.childLanes),
        (i |= a.subtreeFlags),
        (i |= a.flags),
        (a.return = t),
        (a = a.sibling);
  return (t.subtreeFlags |= i), (t.childLanes = n), e;
}
function dp(t, e, n) {
  var i = e.pendingProps;
  switch ((Jr(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return $t(e), null;
    case 1:
      return ae(e.type) && js(), $t(e), null;
    case 3:
      return (
        (i = e.stateNode),
        $i(),
        Lt(re),
        Lt(Qt),
        la(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (t === null || t.child === null) &&
          (ss(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Pe !== null && (Tr(Pe), (Pe = null)))),
        Sr(t, e),
        $t(e),
        null
      );
    case 5:
      aa(e);
      var a = gi(Bn.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        Ic(t, e, n, i, a),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(mt(166));
          return $t(e), null;
        }
        if (((t = gi(Oe.current)), ss(e))) {
          (i = e.stateNode), (n = e.type);
          var d = e.memoizedProps;
          switch (((i[je] = e), (i[On] = d), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              Et("cancel", i), Et("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              Et("load", i);
              break;
            case "video":
            case "audio":
              for (a = 0; a < fn.length; a++) Et(fn[a], i);
              break;
            case "source":
              Et("error", i);
              break;
            case "img":
            case "image":
            case "link":
              Et("error", i), Et("load", i);
              break;
            case "details":
              Et("toggle", i);
              break;
            case "input":
              ja(i, d), Et("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!d.multiple }),
                Et("invalid", i);
              break;
            case "textarea":
              Oa(i, d), Et("invalid", i);
          }
          Vo(n, d), (a = null);
          for (var M in d)
            if (d.hasOwnProperty(M)) {
              var O = d[M];
              M === "children"
                ? typeof O == "string"
                  ? i.textContent !== O &&
                    (d.suppressHydrationWarning !== !0 &&
                      ns(i.textContent, O, t),
                    (a = ["children", O]))
                  : typeof O == "number" &&
                    i.textContent !== "" + O &&
                    (d.suppressHydrationWarning !== !0 &&
                      ns(i.textContent, O, t),
                    (a = ["children", "" + O]))
                : bn.hasOwnProperty(M) &&
                  O != null &&
                  M === "onScroll" &&
                  Et("scroll", i);
            }
          switch (n) {
            case "input":
              Kn(i), Na(i, d, !0);
              break;
            case "textarea":
              Kn(i), Ia(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof d.onClick == "function" && (i.onclick = Ds);
          }
          (i = a), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (M = a.nodeType === 9 ? a : a.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = hh(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = M.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof i.is == "string"
                ? (t = M.createElement(n, { is: i.is }))
                : ((t = M.createElement(n)),
                  n === "select" &&
                    ((M = t),
                    i.multiple
                      ? (M.multiple = !0)
                      : i.size && (M.size = i.size)))
              : (t = M.createElementNS(t, n)),
            (t[je] = e),
            (t[On] = i),
            Oc(t, e, !1, !1),
            (e.stateNode = t);
          t: {
            switch (((M = qo(n, i)), n)) {
              case "dialog":
                Et("cancel", t), Et("close", t), (a = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                Et("load", t), (a = i);
                break;
              case "video":
              case "audio":
                for (a = 0; a < fn.length; a++) Et(fn[a], t);
                a = i;
                break;
              case "source":
                Et("error", t), (a = i);
                break;
              case "img":
              case "image":
              case "link":
                Et("error", t), Et("load", t), (a = i);
                break;
              case "details":
                Et("toggle", t), (a = i);
                break;
              case "input":
                ja(t, i), (a = Go(t, i)), Et("invalid", t);
                break;
              case "option":
                a = i;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!i.multiple }),
                  (a = Bt({}, i, { value: void 0 })),
                  Et("invalid", t);
                break;
              case "textarea":
                Oa(t, i), (a = Yo(t, i)), Et("invalid", t);
                break;
              default:
                a = i;
            }
            Vo(n, a), (O = a);
            for (d in O)
              if (O.hasOwnProperty(d)) {
                var B = O[d];
                d === "style"
                  ? uh(t, B)
                  : d === "dangerouslySetInnerHTML"
                  ? ((B = B ? B.__html : void 0), B != null && ch(t, B))
                  : d === "children"
                  ? typeof B == "string"
                    ? (n !== "textarea" || B !== "") && Mn(t, B)
                    : typeof B == "number" && Mn(t, "" + B)
                  : d !== "suppressContentEditableWarning" &&
                    d !== "suppressHydrationWarning" &&
                    d !== "autoFocus" &&
                    (bn.hasOwnProperty(d)
                      ? B != null && d === "onScroll" && Et("scroll", t)
                      : B != null && zr(t, d, B, M));
              }
            switch (n) {
              case "input":
                Kn(t), Na(t, i, !1);
                break;
              case "textarea":
                Kn(t), Ia(t);
                break;
              case "option":
                i.value != null && t.setAttribute("value", "" + ri(i.value));
                break;
              case "select":
                (t.multiple = !!i.multiple),
                  (d = i.value),
                  d != null
                    ? Hi(t, !!i.multiple, d, !1)
                    : i.defaultValue != null &&
                      Hi(t, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof a.onClick == "function" && (t.onclick = Ds);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break t;
              case "img":
                i = !0;
                break t;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return $t(e), null;
    case 6:
      if (t && e.stateNode != null) Bc(t, e, t.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(mt(166));
        if (((n = gi(Bn.current)), gi(Oe.current), ss(e))) {
          if (
            ((i = e.stateNode),
            (n = e.memoizedProps),
            (i[je] = e),
            (d = i.nodeValue !== n) && ((t = de), t !== null))
          )
            switch (t.tag) {
              case 3:
                ns(i.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  ns(i.nodeValue, n, (t.mode & 1) !== 0);
            }
          d && (e.flags |= 4);
        } else
          (i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i)),
            (i[je] = e),
            (e.stateNode = i);
      }
      return $t(e), null;
    case 13:
      if (
        (Lt(Ot),
        (i = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (jt && ce !== null && e.mode & 1 && !(e.flags & 128))
          Jh(), qi(), (e.flags |= 98560), (d = !1);
        else if (((d = ss(e)), i !== null && i.dehydrated !== null)) {
          if (t === null) {
            if (!d) throw Error(mt(318));
            if (
              ((d = e.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(mt(317));
            d[je] = e;
          } else
            qi(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          $t(e), (d = !1);
        } else Pe !== null && (Tr(Pe), (Pe = null)), (d = !0);
        if (!d) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((i = i !== null),
          i !== (t !== null && t.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || Ot.current & 1 ? Gt === 0 && (Gt = 3) : Sa())),
          e.updateQueue !== null && (e.flags |= 4),
          $t(e),
          null);
    case 4:
      return (
        $i(), Sr(t, e), t === null && jn(e.stateNode.containerInfo), $t(e), null
      );
    case 10:
      return na(e.type._context), $t(e), null;
    case 17:
      return ae(e.type) && js(), $t(e), null;
    case 19:
      if ((Lt(Ot), (d = e.memoizedState), d === null)) return $t(e), null;
      if (((i = (e.flags & 128) !== 0), (M = d.rendering), M === null))
        if (i) hn(d, !1);
        else {
          if (Gt !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((M = Fs(t)), M !== null)) {
                for (
                  e.flags |= 128,
                    hn(d, !1),
                    i = M.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = n,
                    n = e.child;
                  n !== null;

                )
                  (d = n),
                    (t = i),
                    (d.flags &= 14680066),
                    (M = d.alternate),
                    M === null
                      ? ((d.childLanes = 0),
                        (d.lanes = t),
                        (d.child = null),
                        (d.subtreeFlags = 0),
                        (d.memoizedProps = null),
                        (d.memoizedState = null),
                        (d.updateQueue = null),
                        (d.dependencies = null),
                        (d.stateNode = null))
                      : ((d.childLanes = M.childLanes),
                        (d.lanes = M.lanes),
                        (d.child = M.child),
                        (d.subtreeFlags = 0),
                        (d.deletions = null),
                        (d.memoizedProps = M.memoizedProps),
                        (d.memoizedState = M.memoizedState),
                        (d.updateQueue = M.updateQueue),
                        (d.type = M.type),
                        (t = M.dependencies),
                        (d.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return Tt(Ot, (Ot.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          d.tail !== null &&
            zt() > Qi &&
            ((e.flags |= 128), (i = !0), hn(d, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((t = Fs(M)), t !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              hn(d, !0),
              d.tail === null && d.tailMode === "hidden" && !M.alternate && !jt)
            )
              return $t(e), null;
          } else
            2 * zt() - d.renderingStartTime > Qi &&
              n !== 1073741824 &&
              ((e.flags |= 128), (i = !0), hn(d, !1), (e.lanes = 4194304));
        d.isBackwards
          ? ((M.sibling = e.child), (e.child = M))
          : ((n = d.last),
            n !== null ? (n.sibling = M) : (e.child = M),
            (d.last = M));
      }
      return d.tail !== null
        ? ((e = d.tail),
          (d.rendering = e),
          (d.tail = e.sibling),
          (d.renderingStartTime = zt()),
          (e.sibling = null),
          (n = Ot.current),
          Tt(Ot, i ? (n & 1) | 2 : n & 1),
          e)
        : ($t(e), null);
    case 22:
    case 23:
      return (
        va(),
        (i = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? he & 1073741824 && ($t(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : $t(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(mt(156, e.tag));
}
function up(t, e) {
  switch ((Jr(e), e.tag)) {
    case 1:
      return (
        ae(e.type) && js(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        $i(),
        Lt(re),
        Lt(Qt),
        la(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return aa(e), null;
    case 13:
      if (
        (Lt(Ot), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(mt(340));
        qi();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return Lt(Ot), null;
    case 4:
      return $i(), null;
    case 10:
      return na(e.type._context), null;
    case 22:
    case 23:
      return va(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var as = !1,
  Zt = !1,
  pp = typeof WeakSet == "function" ? WeakSet : Set,
  vt = null;
function Ri(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (i) {
        Rt(t, e, i);
      }
    else n.current = null;
}
function wr(t, e, n) {
  try {
    n();
  } catch (i) {
    Rt(t, e, i);
  }
}
var bl = !1;
function fp(t, e) {
  if (((sr = Ts), (t = Hh()), Zr(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      t: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var i = n.getSelection && n.getSelection();
        if (i && i.rangeCount !== 0) {
          n = i.anchorNode;
          var a = i.anchorOffset,
            d = i.focusNode;
          i = i.focusOffset;
          try {
            n.nodeType, d.nodeType;
          } catch {
            n = null;
            break t;
          }
          var M = 0,
            O = -1,
            B = -1,
            G = 0,
            Y = 0,
            L = t,
            E = null;
          e: for (;;) {
            for (
              var z;
              L !== n || (a !== 0 && L.nodeType !== 3) || (O = M + a),
                L !== d || (i !== 0 && L.nodeType !== 3) || (B = M + i),
                L.nodeType === 3 && (M += L.nodeValue.length),
                (z = L.firstChild) !== null;

            )
              (E = L), (L = z);
            for (;;) {
              if (L === t) break e;
              if (
                (E === n && ++G === a && (O = M),
                E === d && ++Y === i && (B = M),
                (z = L.nextSibling) !== null)
              )
                break;
              (L = E), (E = L.parentNode);
            }
            L = z;
          }
          n = O === -1 || B === -1 ? null : { start: O, end: B };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    or = { focusedElem: t, selectionRange: n }, Ts = !1, vt = e;
    vt !== null;

  )
    if (((e = vt), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (vt = t);
    else
      for (; vt !== null; ) {
        e = vt;
        try {
          var S = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (S !== null) {
                  var x = S.memoizedProps,
                    P = S.memoizedState,
                    h = e.stateNode,
                    s = h.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? x : be(e.type, x),
                      P
                    );
                  h.__reactInternalSnapshotBeforeUpdate = s;
                }
                break;
              case 3:
                var l = e.stateNode.containerInfo;
                l.nodeType === 1
                  ? (l.textContent = "")
                  : l.nodeType === 9 &&
                    l.documentElement &&
                    l.removeChild(l.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(mt(163));
            }
        } catch (p) {
          Rt(e, e.return, p);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (vt = t);
          break;
        }
        vt = e.return;
      }
  return (S = bl), (bl = !1), S;
}
function wn(t, e, n) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var a = (i = i.next);
    do {
      if ((a.tag & t) === t) {
        var d = a.destroy;
        (a.destroy = void 0), d !== void 0 && wr(e, n, d);
      }
      a = a.next;
    } while (a !== i);
  }
}
function io(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var i = n.create;
        n.destroy = i();
      }
      n = n.next;
    } while (n !== e);
  }
}
function kr(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function Rc(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), Rc(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[je], delete e[On], delete e[lr], delete e[$u], delete e[Zu])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function zc(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function Ml(t) {
  t: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || zc(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue t;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function Cr(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = Ds));
  else if (i !== 4 && ((t = t.child), t !== null))
    for (Cr(t, e, n), t = t.sibling; t !== null; ) Cr(t, e, n), (t = t.sibling);
}
function br(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (i !== 4 && ((t = t.child), t !== null))
    for (br(t, e, n), t = t.sibling; t !== null; ) br(t, e, n), (t = t.sibling);
}
var Yt = null,
  Me = !1;
function Ye(t, e, n) {
  for (n = n.child; n !== null; ) Fc(t, e, n), (n = n.sibling);
}
function Fc(t, e, n) {
  if (Ne && typeof Ne.onCommitFiberUnmount == "function")
    try {
      Ne.onCommitFiberUnmount(qs, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Zt || Ri(n, e);
    case 6:
      var i = Yt,
        a = Me;
      (Yt = null),
        Ye(t, e, n),
        (Yt = i),
        (Me = a),
        Yt !== null &&
          (Me
            ? ((t = Yt),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Yt.removeChild(n.stateNode));
      break;
    case 18:
      Yt !== null &&
        (Me
          ? ((t = Yt),
            (n = n.stateNode),
            t.nodeType === 8
              ? Po(t.parentNode, n)
              : t.nodeType === 1 && Po(t, n),
            En(t))
          : Po(Yt, n.stateNode));
      break;
    case 4:
      (i = Yt),
        (a = Me),
        (Yt = n.stateNode.containerInfo),
        (Me = !0),
        Ye(t, e, n),
        (Yt = i),
        (Me = a);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Zt &&
        ((i = n.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        a = i = i.next;
        do {
          var d = a,
            M = d.destroy;
          (d = d.tag),
            M !== void 0 && (d & 2 || d & 4) && wr(n, e, M),
            (a = a.next);
        } while (a !== i);
      }
      Ye(t, e, n);
      break;
    case 1:
      if (
        !Zt &&
        (Ri(n, e),
        (i = n.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = n.memoizedProps),
            (i.state = n.memoizedState),
            i.componentWillUnmount();
        } catch (O) {
          Rt(n, e, O);
        }
      Ye(t, e, n);
      break;
    case 21:
      Ye(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((Zt = (i = Zt) || n.memoizedState !== null), Ye(t, e, n), (Zt = i))
        : Ye(t, e, n);
      break;
    default:
      Ye(t, e, n);
  }
}
function Pl(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new pp()),
      e.forEach(function (i) {
        var a = Cp.bind(null, t, i);
        n.has(i) || (n.add(i), i.then(a, a));
      });
  }
}
function Ce(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      try {
        var d = t,
          M = e,
          O = M;
        t: for (; O !== null; ) {
          switch (O.tag) {
            case 5:
              (Yt = O.stateNode), (Me = !1);
              break t;
            case 3:
              (Yt = O.stateNode.containerInfo), (Me = !0);
              break t;
            case 4:
              (Yt = O.stateNode.containerInfo), (Me = !0);
              break t;
          }
          O = O.return;
        }
        if (Yt === null) throw Error(mt(160));
        Fc(d, M, a), (Yt = null), (Me = !1);
        var B = a.alternate;
        B !== null && (B.return = null), (a.return = null);
      } catch (G) {
        Rt(a, e, G);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) Hc(e, t), (e = e.sibling);
}
function Hc(t, e) {
  var n = t.alternate,
    i = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Ce(e, t), Le(t), i & 4)) {
        try {
          wn(3, t, t.return), io(3, t);
        } catch (x) {
          Rt(t, t.return, x);
        }
        try {
          wn(5, t, t.return);
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      break;
    case 1:
      Ce(e, t), Le(t), i & 512 && n !== null && Ri(n, n.return);
      break;
    case 5:
      if (
        (Ce(e, t),
        Le(t),
        i & 512 && n !== null && Ri(n, n.return),
        t.flags & 32)
      ) {
        var a = t.stateNode;
        try {
          Mn(a, "");
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      if (i & 4 && ((a = t.stateNode), a != null)) {
        var d = t.memoizedProps,
          M = n !== null ? n.memoizedProps : d,
          O = t.type,
          B = t.updateQueue;
        if (((t.updateQueue = null), B !== null))
          try {
            O === "input" && d.type === "radio" && d.name != null && ah(a, d),
              qo(O, M);
            var G = qo(O, d);
            for (M = 0; M < B.length; M += 2) {
              var Y = B[M],
                L = B[M + 1];
              Y === "style"
                ? uh(a, L)
                : Y === "dangerouslySetInnerHTML"
                ? ch(a, L)
                : Y === "children"
                ? Mn(a, L)
                : zr(a, Y, L, G);
            }
            switch (O) {
              case "input":
                Xo(a, d);
                break;
              case "textarea":
                lh(a, d);
                break;
              case "select":
                var E = a._wrapperState.wasMultiple;
                a._wrapperState.wasMultiple = !!d.multiple;
                var z = d.value;
                z != null
                  ? Hi(a, !!d.multiple, z, !1)
                  : E !== !!d.multiple &&
                    (d.defaultValue != null
                      ? Hi(a, !!d.multiple, d.defaultValue, !0)
                      : Hi(a, !!d.multiple, d.multiple ? [] : "", !1));
            }
            a[On] = d;
          } catch (x) {
            Rt(t, t.return, x);
          }
      }
      break;
    case 6:
      if ((Ce(e, t), Le(t), i & 4)) {
        if (t.stateNode === null) throw Error(mt(162));
        (a = t.stateNode), (d = t.memoizedProps);
        try {
          a.nodeValue = d;
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      break;
    case 3:
      if (
        (Ce(e, t), Le(t), i & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          En(e.containerInfo);
        } catch (x) {
          Rt(t, t.return, x);
        }
      break;
    case 4:
      Ce(e, t), Le(t);
      break;
    case 13:
      Ce(e, t),
        Le(t),
        (a = t.child),
        a.flags & 8192 &&
          ((d = a.memoizedState !== null),
          (a.stateNode.isHidden = d),
          !d ||
            (a.alternate !== null && a.alternate.memoizedState !== null) ||
            (ya = zt())),
        i & 4 && Pl(t);
      break;
    case 22:
      if (
        ((Y = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((Zt = (G = Zt) || Y), Ce(e, t), (Zt = G)) : Ce(e, t),
        Le(t),
        i & 8192)
      ) {
        if (
          ((G = t.memoizedState !== null),
          (t.stateNode.isHidden = G) && !Y && t.mode & 1)
        )
          for (vt = t, Y = t.child; Y !== null; ) {
            for (L = vt = Y; vt !== null; ) {
              switch (((E = vt), (z = E.child), E.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  wn(4, E, E.return);
                  break;
                case 1:
                  Ri(E, E.return);
                  var S = E.stateNode;
                  if (typeof S.componentWillUnmount == "function") {
                    (i = E), (n = E.return);
                    try {
                      (e = i),
                        (S.props = e.memoizedProps),
                        (S.state = e.memoizedState),
                        S.componentWillUnmount();
                    } catch (x) {
                      Rt(i, n, x);
                    }
                  }
                  break;
                case 5:
                  Ri(E, E.return);
                  break;
                case 22:
                  if (E.memoizedState !== null) {
                    Tl(L);
                    continue;
                  }
              }
              z !== null ? ((z.return = E), (vt = z)) : Tl(L);
            }
            Y = Y.sibling;
          }
        t: for (Y = null, L = t; ; ) {
          if (L.tag === 5) {
            if (Y === null) {
              Y = L;
              try {
                (a = L.stateNode),
                  G
                    ? ((d = a.style),
                      typeof d.setProperty == "function"
                        ? d.setProperty("display", "none", "important")
                        : (d.display = "none"))
                    : ((O = L.stateNode),
                      (B = L.memoizedProps.style),
                      (M =
                        B != null && B.hasOwnProperty("display")
                          ? B.display
                          : null),
                      (O.style.display = dh("display", M)));
              } catch (x) {
                Rt(t, t.return, x);
              }
            }
          } else if (L.tag === 6) {
            if (Y === null)
              try {
                L.stateNode.nodeValue = G ? "" : L.memoizedProps;
              } catch (x) {
                Rt(t, t.return, x);
              }
          } else if (
            ((L.tag !== 22 && L.tag !== 23) ||
              L.memoizedState === null ||
              L === t) &&
            L.child !== null
          ) {
            (L.child.return = L), (L = L.child);
            continue;
          }
          if (L === t) break t;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === t) break t;
            Y === L && (Y = null), (L = L.return);
          }
          Y === L && (Y = null), (L.sibling.return = L.return), (L = L.sibling);
        }
      }
      break;
    case 19:
      Ce(e, t), Le(t), i & 4 && Pl(t);
      break;
    case 21:
      break;
    default:
      Ce(e, t), Le(t);
  }
}
function Le(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      t: {
        for (var n = t.return; n !== null; ) {
          if (zc(n)) {
            var i = n;
            break t;
          }
          n = n.return;
        }
        throw Error(mt(160));
      }
      switch (i.tag) {
        case 5:
          var a = i.stateNode;
          i.flags & 32 && (Mn(a, ""), (i.flags &= -33));
          var d = Ml(t);
          br(t, d, a);
          break;
        case 3:
        case 4:
          var M = i.stateNode.containerInfo,
            O = Ml(t);
          Cr(t, O, M);
          break;
        default:
          throw Error(mt(161));
      }
    } catch (B) {
      Rt(t, t.return, B);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function gp(t, e, n) {
  (vt = t), Uc(t);
}
function Uc(t, e, n) {
  for (var i = (t.mode & 1) !== 0; vt !== null; ) {
    var a = vt,
      d = a.child;
    if (a.tag === 22 && i) {
      var M = a.memoizedState !== null || as;
      if (!M) {
        var O = a.alternate,
          B = (O !== null && O.memoizedState !== null) || Zt;
        O = as;
        var G = Zt;
        if (((as = M), (Zt = B) && !G))
          for (vt = a; vt !== null; )
            (M = vt),
              (B = M.child),
              M.tag === 22 && M.memoizedState !== null
                ? El(a)
                : B !== null
                ? ((B.return = M), (vt = B))
                : El(a);
        for (; d !== null; ) (vt = d), Uc(d), (d = d.sibling);
        (vt = a), (as = O), (Zt = G);
      }
      Al(t);
    } else
      a.subtreeFlags & 8772 && d !== null ? ((d.return = a), (vt = d)) : Al(t);
  }
}
function Al(t) {
  for (; vt !== null; ) {
    var e = vt;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Zt || io(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !Zt)
                if (n === null) i.componentDidMount();
                else {
                  var a =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : be(e.type, n.memoizedProps);
                  i.componentDidUpdate(
                    a,
                    n.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var d = e.updateQueue;
              d !== null && cl(e, d, i);
              break;
            case 3:
              var M = e.updateQueue;
              if (M !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                cl(e, M, n);
              }
              break;
            case 5:
              var O = e.stateNode;
              if (n === null && e.flags & 4) {
                n = O;
                var B = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    B.autoFocus && n.focus();
                    break;
                  case "img":
                    B.src && (n.src = B.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var G = e.alternate;
                if (G !== null) {
                  var Y = G.memoizedState;
                  if (Y !== null) {
                    var L = Y.dehydrated;
                    L !== null && En(L);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(mt(163));
          }
        Zt || (e.flags & 512 && kr(e));
      } catch (E) {
        Rt(e, e.return, E);
      }
    }
    if (e === t) {
      vt = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (vt = n);
      break;
    }
    vt = e.return;
  }
}
function Tl(t) {
  for (; vt !== null; ) {
    var e = vt;
    if (e === t) {
      vt = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (vt = n);
      break;
    }
    vt = e.return;
  }
}
function El(t) {
  for (; vt !== null; ) {
    var e = vt;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            io(4, e);
          } catch (B) {
            Rt(e, n, B);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var a = e.return;
            try {
              i.componentDidMount();
            } catch (B) {
              Rt(e, a, B);
            }
          }
          var d = e.return;
          try {
            kr(e);
          } catch (B) {
            Rt(e, d, B);
          }
          break;
        case 5:
          var M = e.return;
          try {
            kr(e);
          } catch (B) {
            Rt(e, M, B);
          }
      }
    } catch (B) {
      Rt(e, e.return, B);
    }
    if (e === t) {
      vt = null;
      break;
    }
    var O = e.sibling;
    if (O !== null) {
      (O.return = e.return), (vt = O);
      break;
    }
    vt = e.return;
  }
}
var mp = Math.ceil,
  Gs = We.ReactCurrentDispatcher,
  ga = We.ReactCurrentOwner,
  ve = We.ReactCurrentBatchConfig,
  Pt = 0,
  Wt = null,
  Ht = null,
  _t = 0,
  he = 0,
  zi = hi(0),
  Gt = 0,
  Hn = null,
  wi = 0,
  no = 0,
  ma = 0,
  kn = null,
  se = null,
  ya = 0,
  Qi = 1 / 0,
  Ie = null,
  Xs = !1,
  Mr = null,
  ni = null,
  ls = !1,
  Ze = null,
  Ws = 0,
  Cn = 0,
  Pr = null,
  Ss = -1,
  ws = 0;
function ee() {
  return Pt & 6 ? zt() : Ss !== -1 ? Ss : (Ss = zt());
}
function si(t) {
  return t.mode & 1
    ? Pt & 2 && _t !== 0
      ? _t & -_t
      : Ju.transition !== null
      ? (ws === 0 && (ws = bh()), ws)
      : ((t = At),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : Dh(t.type))),
        t)
    : 1;
}
function Te(t, e, n, i) {
  if (50 < Cn) throw ((Cn = 0), (Pr = null), Error(mt(185)));
  Gn(t, n, i),
    (!(Pt & 2) || t !== Wt) &&
      (t === Wt && (!(Pt & 2) && (no |= n), Gt === 4 && Ke(t, _t)),
      le(t, i),
      n === 1 && Pt === 0 && !(e.mode & 1) && ((Qi = zt() + 500), Js && ci()));
}
function le(t, e) {
  var n = t.callbackNode;
  Jd(t, e);
  var i = As(t, t === Wt ? _t : 0);
  if (i === 0)
    n !== null && za(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = i & -i), t.callbackPriority !== e)) {
    if ((n != null && za(n), e === 1))
      t.tag === 0 ? Qu(Ll.bind(null, t)) : $h(Ll.bind(null, t)),
        qu(function () {
          !(Pt & 6) && ci();
        }),
        (n = null);
    else {
      switch (Mh(i)) {
        case 1:
          n = Xr;
          break;
        case 4:
          n = kh;
          break;
        case 16:
          n = Ps;
          break;
        case 536870912:
          n = Ch;
          break;
        default:
          n = Ps;
      }
      n = Kc(n, Gc.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function Gc(t, e) {
  if (((Ss = -1), (ws = 0), Pt & 6)) throw Error(mt(327));
  var n = t.callbackNode;
  if (Yi() && t.callbackNode !== n) return null;
  var i = As(t, t === Wt ? _t : 0);
  if (i === 0) return null;
  if (i & 30 || i & t.expiredLanes || e) e = Ys(t, i);
  else {
    e = i;
    var a = Pt;
    Pt |= 2;
    var d = Wc();
    (Wt !== t || _t !== e) && ((Ie = null), (Qi = zt() + 500), mi(t, e));
    do
      try {
        vp();
        break;
      } catch (O) {
        Xc(t, O);
      }
    while (1);
    ia(),
      (Gs.current = d),
      (Pt = a),
      Ht !== null ? (e = 0) : ((Wt = null), (_t = 0), (e = Gt));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((a = Jo(t)), a !== 0 && ((i = a), (e = Ar(t, a)))), e === 1)
    )
      throw ((n = Hn), mi(t, 0), Ke(t, i), le(t, zt()), n);
    if (e === 6) Ke(t, i);
    else {
      if (
        ((a = t.current.alternate),
        !(i & 30) &&
          !yp(a) &&
          ((e = Ys(t, i)),
          e === 2 && ((d = Jo(t)), d !== 0 && ((i = d), (e = Ar(t, d)))),
          e === 1))
      )
        throw ((n = Hn), mi(t, 0), Ke(t, i), le(t, zt()), n);
      switch (((t.finishedWork = a), (t.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(mt(345));
        case 2:
          ui(t, se, Ie);
          break;
        case 3:
          if (
            (Ke(t, i), (i & 130023424) === i && ((e = ya + 500 - zt()), 10 < e))
          ) {
            if (As(t, 0) !== 0) break;
            if (((a = t.suspendedLanes), (a & i) !== i)) {
              ee(), (t.pingedLanes |= t.suspendedLanes & a);
              break;
            }
            t.timeoutHandle = ar(ui.bind(null, t, se, Ie), e);
            break;
          }
          ui(t, se, Ie);
          break;
        case 4:
          if ((Ke(t, i), (i & 4194240) === i)) break;
          for (e = t.eventTimes, a = -1; 0 < i; ) {
            var M = 31 - Ae(i);
            (d = 1 << M), (M = e[M]), M > a && (a = M), (i &= ~d);
          }
          if (
            ((i = a),
            (i = zt() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * mp(i / 1960)) - i),
            10 < i)
          ) {
            t.timeoutHandle = ar(ui.bind(null, t, se, Ie), i);
            break;
          }
          ui(t, se, Ie);
          break;
        case 5:
          ui(t, se, Ie);
          break;
        default:
          throw Error(mt(329));
      }
    }
  }
  return le(t, zt()), t.callbackNode === n ? Gc.bind(null, t) : null;
}
function Ar(t, e) {
  var n = kn;
  return (
    t.current.memoizedState.isDehydrated && (mi(t, e).flags |= 256),
    (t = Ys(t, e)),
    t !== 2 && ((e = se), (se = n), e !== null && Tr(e)),
    t
  );
}
function Tr(t) {
  se === null ? (se = t) : se.push.apply(se, t);
}
function yp(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var i = 0; i < n.length; i++) {
          var a = n[i],
            d = a.getSnapshot;
          a = a.value;
          try {
            if (!Ee(d(), a)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Ke(t, e) {
  for (
    e &= ~ma,
      e &= ~no,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - Ae(e),
      i = 1 << n;
    (t[n] = -1), (e &= ~i);
  }
}
function Ll(t) {
  if (Pt & 6) throw Error(mt(327));
  Yi();
  var e = As(t, 0);
  if (!(e & 1)) return le(t, zt()), null;
  var n = Ys(t, e);
  if (t.tag !== 0 && n === 2) {
    var i = Jo(t);
    i !== 0 && ((e = i), (n = Ar(t, i)));
  }
  if (n === 1) throw ((n = Hn), mi(t, 0), Ke(t, e), le(t, zt()), n);
  if (n === 6) throw Error(mt(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    ui(t, se, Ie),
    le(t, zt()),
    null
  );
}
function xa(t, e) {
  var n = Pt;
  Pt |= 1;
  try {
    return t(e);
  } finally {
    (Pt = n), Pt === 0 && ((Qi = zt() + 500), Js && ci());
  }
}
function ki(t) {
  Ze !== null && Ze.tag === 0 && !(Pt & 6) && Yi();
  var e = Pt;
  Pt |= 1;
  var n = ve.transition,
    i = At;
  try {
    if (((ve.transition = null), (At = 1), t)) return t();
  } finally {
    (At = i), (ve.transition = n), (Pt = e), !(Pt & 6) && ci();
  }
}
function va() {
  (he = zi.current), Lt(zi);
}
function mi(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), Vu(n)), Ht !== null))
    for (n = Ht.return; n !== null; ) {
      var i = n;
      switch ((Jr(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && js();
          break;
        case 3:
          $i(), Lt(re), Lt(Qt), la();
          break;
        case 5:
          aa(i);
          break;
        case 4:
          $i();
          break;
        case 13:
          Lt(Ot);
          break;
        case 19:
          Lt(Ot);
          break;
        case 10:
          na(i.type._context);
          break;
        case 22:
        case 23:
          va();
      }
      n = n.return;
    }
  if (
    ((Wt = t),
    (Ht = t = oi(t.current, null)),
    (_t = he = e),
    (Gt = 0),
    (Hn = null),
    (ma = no = wi = 0),
    (se = kn = null),
    fi !== null)
  ) {
    for (e = 0; e < fi.length; e++)
      if (((n = fi[e]), (i = n.interleaved), i !== null)) {
        n.interleaved = null;
        var a = i.next,
          d = n.pending;
        if (d !== null) {
          var M = d.next;
          (d.next = a), (i.next = M);
        }
        n.pending = i;
      }
    fi = null;
  }
  return t;
}
function Xc(t, e) {
  do {
    var n = Ht;
    try {
      if ((ia(), (ys.current = Us), Hs)) {
        for (var i = It.memoizedState; i !== null; ) {
          var a = i.queue;
          a !== null && (a.pending = null), (i = i.next);
        }
        Hs = !1;
      }
      if (
        ((Si = 0),
        (Xt = Ut = It = null),
        (Sn = !1),
        (Rn = 0),
        (ga.current = null),
        n === null || n.return === null)
      ) {
        (Gt = 1), (Hn = e), (Ht = null);
        break;
      }
      t: {
        var d = t,
          M = n.return,
          O = n,
          B = e;
        if (
          ((e = _t),
          (O.flags |= 32768),
          B !== null && typeof B == "object" && typeof B.then == "function")
        ) {
          var G = B,
            Y = O,
            L = Y.tag;
          if (!(Y.mode & 1) && (L === 0 || L === 11 || L === 15)) {
            var E = Y.alternate;
            E
              ? ((Y.updateQueue = E.updateQueue),
                (Y.memoizedState = E.memoizedState),
                (Y.lanes = E.lanes))
              : ((Y.updateQueue = null), (Y.memoizedState = null));
          }
          var z = yl(M);
          if (z !== null) {
            (z.flags &= -257),
              xl(z, M, O, d, e),
              z.mode & 1 && ml(d, G, e),
              (e = z),
              (B = G);
            var S = e.updateQueue;
            if (S === null) {
              var x = new Set();
              x.add(B), (e.updateQueue = x);
            } else S.add(B);
            break t;
          } else {
            if (!(e & 1)) {
              ml(d, G, e), Sa();
              break t;
            }
            B = Error(mt(426));
          }
        } else if (jt && O.mode & 1) {
          var P = yl(M);
          if (P !== null) {
            !(P.flags & 65536) && (P.flags |= 256),
              xl(P, M, O, d, e),
              ta(Zi(B, O));
            break t;
          }
        }
        (d = B = Zi(B, O)),
          Gt !== 4 && (Gt = 2),
          kn === null ? (kn = [d]) : kn.push(d),
          (d = M);
        do {
          switch (d.tag) {
            case 3:
              (d.flags |= 65536), (e &= -e), (d.lanes |= e);
              var h = Pc(d, B, e);
              hl(d, h);
              break t;
            case 1:
              O = B;
              var s = d.type,
                l = d.stateNode;
              if (
                !(d.flags & 128) &&
                (typeof s.getDerivedStateFromError == "function" ||
                  (l !== null &&
                    typeof l.componentDidCatch == "function" &&
                    (ni === null || !ni.has(l))))
              ) {
                (d.flags |= 65536), (e &= -e), (d.lanes |= e);
                var p = Ac(d, O, e);
                hl(d, p);
                break t;
              }
          }
          d = d.return;
        } while (d !== null);
      }
      _c(n);
    } catch (g) {
      (e = g), Ht === n && n !== null && (Ht = n = n.return);
      continue;
    }
    break;
  } while (1);
}
function Wc() {
  var t = Gs.current;
  return (Gs.current = Us), t === null ? Us : t;
}
function Sa() {
  (Gt === 0 || Gt === 3 || Gt === 2) && (Gt = 4),
    Wt === null || (!(wi & 268435455) && !(no & 268435455)) || Ke(Wt, _t);
}
function Ys(t, e) {
  var n = Pt;
  Pt |= 2;
  var i = Wc();
  (Wt !== t || _t !== e) && ((Ie = null), mi(t, e));
  do
    try {
      xp();
      break;
    } catch (a) {
      Xc(t, a);
    }
  while (1);
  if ((ia(), (Pt = n), (Gs.current = i), Ht !== null)) throw Error(mt(261));
  return (Wt = null), (_t = 0), Gt;
}
function xp() {
  for (; Ht !== null; ) Yc(Ht);
}
function vp() {
  for (; Ht !== null && !Wd(); ) Yc(Ht);
}
function Yc(t) {
  var e = qc(t.alternate, t, he);
  (t.memoizedProps = t.pendingProps),
    e === null ? _c(t) : (Ht = e),
    (ga.current = null);
}
function _c(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = up(n, e)), n !== null)) {
        (n.flags &= 32767), (Ht = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (Gt = 6), (Ht = null);
        return;
      }
    } else if (((n = dp(n, e, he)), n !== null)) {
      Ht = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ht = e;
      return;
    }
    Ht = e = t;
  } while (e !== null);
  Gt === 0 && (Gt = 5);
}
function ui(t, e, n) {
  var i = At,
    a = ve.transition;
  try {
    (ve.transition = null), (At = 1), Sp(t, e, n, i);
  } finally {
    (ve.transition = a), (At = i);
  }
  return null;
}
function Sp(t, e, n, i) {
  do Yi();
  while (Ze !== null);
  if (Pt & 6) throw Error(mt(327));
  n = t.finishedWork;
  var a = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(mt(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var d = n.lanes | n.childLanes;
  if (
    (tu(t, d),
    t === Wt && ((Ht = Wt = null), (_t = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      ls ||
      ((ls = !0),
      Kc(Ps, function () {
        return Yi(), null;
      })),
    (d = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || d)
  ) {
    (d = ve.transition), (ve.transition = null);
    var M = At;
    At = 1;
    var O = Pt;
    (Pt |= 4),
      (ga.current = null),
      fp(t, n),
      Hc(n, t),
      Hu(or),
      (Ts = !!sr),
      (or = sr = null),
      (t.current = n),
      gp(n),
      Yd(),
      (Pt = O),
      (At = M),
      (ve.transition = d);
  } else t.current = n;
  if (
    (ls && ((ls = !1), (Ze = t), (Ws = a)),
    (d = t.pendingLanes),
    d === 0 && (ni = null),
    qd(n.stateNode),
    le(t, zt()),
    e !== null)
  )
    for (i = t.onRecoverableError, n = 0; n < e.length; n++)
      (a = e[n]), i(a.value, { componentStack: a.stack, digest: a.digest });
  if (Xs) throw ((Xs = !1), (t = Mr), (Mr = null), t);
  return (
    Ws & 1 && t.tag !== 0 && Yi(),
    (d = t.pendingLanes),
    d & 1 ? (t === Pr ? Cn++ : ((Cn = 0), (Pr = t))) : (Cn = 0),
    ci(),
    null
  );
}
function Yi() {
  if (Ze !== null) {
    var t = Mh(Ws),
      e = ve.transition,
      n = At;
    try {
      if (((ve.transition = null), (At = 16 > t ? 16 : t), Ze === null))
        var i = !1;
      else {
        if (((t = Ze), (Ze = null), (Ws = 0), Pt & 6)) throw Error(mt(331));
        var a = Pt;
        for (Pt |= 4, vt = t.current; vt !== null; ) {
          var d = vt,
            M = d.child;
          if (vt.flags & 16) {
            var O = d.deletions;
            if (O !== null) {
              for (var B = 0; B < O.length; B++) {
                var G = O[B];
                for (vt = G; vt !== null; ) {
                  var Y = vt;
                  switch (Y.tag) {
                    case 0:
                    case 11:
                    case 15:
                      wn(8, Y, d);
                  }
                  var L = Y.child;
                  if (L !== null) (L.return = Y), (vt = L);
                  else
                    for (; vt !== null; ) {
                      Y = vt;
                      var E = Y.sibling,
                        z = Y.return;
                      if ((Rc(Y), Y === G)) {
                        vt = null;
                        break;
                      }
                      if (E !== null) {
                        (E.return = z), (vt = E);
                        break;
                      }
                      vt = z;
                    }
                }
              }
              var S = d.alternate;
              if (S !== null) {
                var x = S.child;
                if (x !== null) {
                  S.child = null;
                  do {
                    var P = x.sibling;
                    (x.sibling = null), (x = P);
                  } while (x !== null);
                }
              }
              vt = d;
            }
          }
          if (d.subtreeFlags & 2064 && M !== null) (M.return = d), (vt = M);
          else
            t: for (; vt !== null; ) {
              if (((d = vt), d.flags & 2048))
                switch (d.tag) {
                  case 0:
                  case 11:
                  case 15:
                    wn(9, d, d.return);
                }
              var h = d.sibling;
              if (h !== null) {
                (h.return = d.return), (vt = h);
                break t;
              }
              vt = d.return;
            }
        }
        var s = t.current;
        for (vt = s; vt !== null; ) {
          M = vt;
          var l = M.child;
          if (M.subtreeFlags & 2064 && l !== null) (l.return = M), (vt = l);
          else
            t: for (M = s; vt !== null; ) {
              if (((O = vt), O.flags & 2048))
                try {
                  switch (O.tag) {
                    case 0:
                    case 11:
                    case 15:
                      io(9, O);
                  }
                } catch (g) {
                  Rt(O, O.return, g);
                }
              if (O === M) {
                vt = null;
                break t;
              }
              var p = O.sibling;
              if (p !== null) {
                (p.return = O.return), (vt = p);
                break t;
              }
              vt = O.return;
            }
        }
        if (
          ((Pt = a), ci(), Ne && typeof Ne.onPostCommitFiberRoot == "function")
        )
          try {
            Ne.onPostCommitFiberRoot(qs, t);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (At = n), (ve.transition = e);
    }
  }
  return !1;
}
function Dl(t, e, n) {
  (e = Zi(n, e)),
    (e = Pc(t, e, 1)),
    (t = ii(t, e, 1)),
    (e = ee()),
    t !== null && (Gn(t, 1, e), le(t, e));
}
function Rt(t, e, n) {
  if (t.tag === 3) Dl(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Dl(e, t, n);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (ni === null || !ni.has(i)))
        ) {
          (t = Zi(n, t)),
            (t = Ac(e, t, 1)),
            (e = ii(e, t, 1)),
            (t = ee()),
            e !== null && (Gn(e, 1, t), le(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function wp(t, e, n) {
  var i = t.pingCache;
  i !== null && i.delete(e),
    (e = ee()),
    (t.pingedLanes |= t.suspendedLanes & n),
    Wt === t &&
      (_t & n) === n &&
      (Gt === 4 || (Gt === 3 && (_t & 130023424) === _t && 500 > zt() - ya)
        ? mi(t, 0)
        : (ma |= n)),
    le(t, e);
}
function Vc(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = Qn), (Qn <<= 1), !(Qn & 130023424) && (Qn = 4194304))
      : (e = 1));
  var n = ee();
  (t = Ge(t, e)), t !== null && (Gn(t, e, n), le(t, n));
}
function kp(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), Vc(t, n);
}
function Cp(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var i = t.stateNode,
        a = t.memoizedState;
      a !== null && (n = a.retryLane);
      break;
    case 19:
      i = t.stateNode;
      break;
    default:
      throw Error(mt(314));
  }
  i !== null && i.delete(e), Vc(t, n);
}
var qc;
qc = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || re.current) oe = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (oe = !1), cp(t, e, n);
      oe = !!(t.flags & 131072);
    }
  else (oe = !1), jt && e.flags & 1048576 && Zh(e, Is, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      vs(t, e), (t = e.pendingProps);
      var a = Vi(e, Qt.current);
      Wi(e, n), (a = ca(null, e, i, t, a, n));
      var d = da();
      return (
        (e.flags |= 1),
        typeof a == "object" &&
        a !== null &&
        typeof a.render == "function" &&
        a.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            ae(i) ? ((d = !0), Ns(e)) : (d = !1),
            (e.memoizedState =
              a.state !== null && a.state !== void 0 ? a.state : null),
            oa(e),
            (a.updater = to),
            (e.stateNode = a),
            (a._reactInternals = e),
            fr(e, i, t, n),
            (e = yr(null, e, i, !0, d, n)))
          : ((e.tag = 0), jt && d && Qr(e), te(null, e, a, n), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      t: {
        switch (
          (vs(t, e),
          (t = e.pendingProps),
          (a = i._init),
          (i = a(i._payload)),
          (e.type = i),
          (a = e.tag = Mp(i)),
          (t = be(i, t)),
          a)
        ) {
          case 0:
            e = mr(null, e, i, t, n);
            break t;
          case 1:
            e = wl(null, e, i, t, n);
            break t;
          case 11:
            e = vl(null, e, i, t, n);
            break t;
          case 14:
            e = Sl(null, e, i, be(i.type, t), n);
            break t;
        }
        throw Error(mt(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (a = e.pendingProps),
        (a = e.elementType === i ? a : be(i, a)),
        mr(t, e, i, a, n)
      );
    case 1:
      return (
        (i = e.type),
        (a = e.pendingProps),
        (a = e.elementType === i ? a : be(i, a)),
        wl(t, e, i, a, n)
      );
    case 3:
      t: {
        if ((Dc(e), t === null)) throw Error(mt(387));
        (i = e.pendingProps),
          (d = e.memoizedState),
          (a = d.element),
          ec(t, e),
          zs(e, i, null, n);
        var M = e.memoizedState;
        if (((i = M.element), d.isDehydrated))
          if (
            ((d = {
              element: i,
              isDehydrated: !1,
              cache: M.cache,
              pendingSuspenseBoundaries: M.pendingSuspenseBoundaries,
              transitions: M.transitions,
            }),
            (e.updateQueue.baseState = d),
            (e.memoizedState = d),
            e.flags & 256)
          ) {
            (a = Zi(Error(mt(423)), e)), (e = kl(t, e, i, n, a));
            break t;
          } else if (i !== a) {
            (a = Zi(Error(mt(424)), e)), (e = kl(t, e, i, n, a));
            break t;
          } else
            for (
              ce = ei(e.stateNode.containerInfo.firstChild),
                de = e,
                jt = !0,
                Pe = null,
                n = oc(e, null, i, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((qi(), i === a)) {
            e = Xe(t, e, n);
            break t;
          }
          te(t, e, i, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        rc(e),
        t === null && dr(e),
        (i = e.type),
        (a = e.pendingProps),
        (d = t !== null ? t.memoizedProps : null),
        (M = a.children),
        rr(i, a) ? (M = null) : d !== null && rr(i, d) && (e.flags |= 32),
        Lc(t, e),
        te(t, e, M, n),
        e.child
      );
    case 6:
      return t === null && dr(e), null;
    case 13:
      return jc(t, e, n);
    case 4:
      return (
        ra(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        t === null ? (e.child = Ki(e, null, i, n)) : te(t, e, i, n),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (a = e.pendingProps),
        (a = e.elementType === i ? a : be(i, a)),
        vl(t, e, i, a, n)
      );
    case 7:
      return te(t, e, e.pendingProps, n), e.child;
    case 8:
      return te(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return te(t, e, e.pendingProps.children, n), e.child;
    case 10:
      t: {
        if (
          ((i = e.type._context),
          (a = e.pendingProps),
          (d = e.memoizedProps),
          (M = a.value),
          Tt(Bs, i._currentValue),
          (i._currentValue = M),
          d !== null)
        )
          if (Ee(d.value, M)) {
            if (d.children === a.children && !re.current) {
              e = Xe(t, e, n);
              break t;
            }
          } else
            for (d = e.child, d !== null && (d.return = e); d !== null; ) {
              var O = d.dependencies;
              if (O !== null) {
                M = d.child;
                for (var B = O.firstContext; B !== null; ) {
                  if (B.context === i) {
                    if (d.tag === 1) {
                      (B = Fe(-1, n & -n)), (B.tag = 2);
                      var G = d.updateQueue;
                      if (G !== null) {
                        G = G.shared;
                        var Y = G.pending;
                        Y === null
                          ? (B.next = B)
                          : ((B.next = Y.next), (Y.next = B)),
                          (G.pending = B);
                      }
                    }
                    (d.lanes |= n),
                      (B = d.alternate),
                      B !== null && (B.lanes |= n),
                      ur(d.return, n, e),
                      (O.lanes |= n);
                    break;
                  }
                  B = B.next;
                }
              } else if (d.tag === 10) M = d.type === e.type ? null : d.child;
              else if (d.tag === 18) {
                if (((M = d.return), M === null)) throw Error(mt(341));
                (M.lanes |= n),
                  (O = M.alternate),
                  O !== null && (O.lanes |= n),
                  ur(M, n, e),
                  (M = d.sibling);
              } else M = d.child;
              if (M !== null) M.return = d;
              else
                for (M = d; M !== null; ) {
                  if (M === e) {
                    M = null;
                    break;
                  }
                  if (((d = M.sibling), d !== null)) {
                    (d.return = M.return), (M = d);
                    break;
                  }
                  M = M.return;
                }
              d = M;
            }
        te(t, e, a.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (a = e.type),
        (i = e.pendingProps.children),
        Wi(e, n),
        (a = Se(a)),
        (i = i(a)),
        (e.flags |= 1),
        te(t, e, i, n),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (a = be(i, e.pendingProps)),
        (a = be(i.type, a)),
        Sl(t, e, i, a, n)
      );
    case 15:
      return Tc(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (i = e.type),
        (a = e.pendingProps),
        (a = e.elementType === i ? a : be(i, a)),
        vs(t, e),
        (e.tag = 1),
        ae(i) ? ((t = !0), Ns(e)) : (t = !1),
        Wi(e, n),
        nc(e, i, a),
        fr(e, i, a, n),
        yr(null, e, i, !0, t, n)
      );
    case 19:
      return Nc(t, e, n);
    case 22:
      return Ec(t, e, n);
  }
  throw Error(mt(156, e.tag));
};
function Kc(t, e) {
  return wh(t, e);
}
function bp(t, e, n, i) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function xe(t, e, n, i) {
  return new bp(t, e, n, i);
}
function wa(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function Mp(t) {
  if (typeof t == "function") return wa(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === Hr)) return 11;
    if (t === Ur) return 14;
  }
  return 2;
}
function oi(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = xe(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function ks(t, e, n, i, a, d) {
  var M = 2;
  if (((i = t), typeof t == "function")) wa(t) && (M = 1);
  else if (typeof t == "string") M = 5;
  else
    t: switch (t) {
      case Ti:
        return yi(n.children, a, d, e);
      case Fr:
        (M = 8), (a |= 8);
        break;
      case zo:
        return (
          (t = xe(12, n, e, a | 2)), (t.elementType = zo), (t.lanes = d), t
        );
      case Fo:
        return (t = xe(13, n, e, a)), (t.elementType = Fo), (t.lanes = d), t;
      case Ho:
        return (t = xe(19, n, e, a)), (t.elementType = Ho), (t.lanes = d), t;
      case sh:
        return so(n, a, d, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case ih:
              M = 10;
              break t;
            case nh:
              M = 9;
              break t;
            case Hr:
              M = 11;
              break t;
            case Ur:
              M = 14;
              break t;
            case _e:
              (M = 16), (i = null);
              break t;
          }
        throw Error(mt(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = xe(M, n, e, a)), (e.elementType = t), (e.type = i), (e.lanes = d), e
  );
}
function yi(t, e, n, i) {
  return (t = xe(7, t, i, e)), (t.lanes = n), t;
}
function so(t, e, n, i) {
  return (
    (t = xe(22, t, i, e)),
    (t.elementType = sh),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function Oo(t, e, n) {
  return (t = xe(6, t, null, e)), (t.lanes = n), t;
}
function Io(t, e, n) {
  return (
    (e = xe(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function Pp(t, e, n, i, a) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = go(0)),
    (this.expirationTimes = go(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = go(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = a),
    (this.mutableSourceEagerHydrationData = null);
}
function ka(t, e, n, i, a, d, M, O, B) {
  return (
    (t = new Pp(t, e, n, O, B)),
    e === 1 ? ((e = 1), d === !0 && (e |= 8)) : (e = 0),
    (d = xe(3, null, null, e)),
    (t.current = d),
    (d.stateNode = t),
    (d.memoizedState = {
      element: i,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    oa(d),
    t
  );
}
function Ap(t, e, n) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Ai,
    key: i == null ? null : "" + i,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function $c(t) {
  if (!t) return ai;
  t = t._reactInternals;
  t: {
    if (Mi(t) !== t || t.tag !== 1) throw Error(mt(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break t;
        case 1:
          if (ae(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break t;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(mt(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (ae(n)) return Kh(t, n, e);
  }
  return e;
}
function Zc(t, e, n, i, a, d, M, O, B) {
  return (
    (t = ka(n, i, !0, t, a, d, M, O, B)),
    (t.context = $c(null)),
    (n = t.current),
    (i = ee()),
    (a = si(n)),
    (d = Fe(i, a)),
    (d.callback = e ?? null),
    ii(n, d, a),
    (t.current.lanes = a),
    Gn(t, a, i),
    le(t, i),
    t
  );
}
function oo(t, e, n, i) {
  var a = e.current,
    d = ee(),
    M = si(a);
  return (
    (n = $c(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = Fe(d, M)),
    (e.payload = { element: t }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (t = ii(a, e, M)),
    t !== null && (Te(t, a, M, d), ms(t, a, M)),
    M
  );
}
function _s(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function jl(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function Ca(t, e) {
  jl(t, e), (t = t.alternate) && jl(t, e);
}
function Tp() {
  return null;
}
var Qc =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function ba(t) {
  this._internalRoot = t;
}
ro.prototype.render = ba.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(mt(409));
  oo(t, e, null, null);
};
ro.prototype.unmount = ba.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    ki(function () {
      oo(null, t, null, null);
    }),
      (e[Ue] = null);
  }
};
function ro(t) {
  this._internalRoot = t;
}
ro.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = Th();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < qe.length && e !== 0 && e < qe[n].priority; n++);
    qe.splice(n, 0, t), n === 0 && Lh(t);
  }
};
function Ma(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function ao(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function Nl() {}
function Ep(t, e, n, i, a) {
  if (a) {
    if (typeof i == "function") {
      var d = i;
      i = function () {
        var G = _s(M);
        d.call(G);
      };
    }
    var M = Zc(e, i, t, 0, null, !1, !1, "", Nl);
    return (
      (t._reactRootContainer = M),
      (t[Ue] = M.current),
      jn(t.nodeType === 8 ? t.parentNode : t),
      ki(),
      M
    );
  }
  for (; (a = t.lastChild); ) t.removeChild(a);
  if (typeof i == "function") {
    var O = i;
    i = function () {
      var G = _s(B);
      O.call(G);
    };
  }
  var B = ka(t, 0, !1, null, null, !1, !1, "", Nl);
  return (
    (t._reactRootContainer = B),
    (t[Ue] = B.current),
    jn(t.nodeType === 8 ? t.parentNode : t),
    ki(function () {
      oo(e, B, n, i);
    }),
    B
  );
}
function lo(t, e, n, i, a) {
  var d = n._reactRootContainer;
  if (d) {
    var M = d;
    if (typeof a == "function") {
      var O = a;
      a = function () {
        var B = _s(M);
        O.call(B);
      };
    }
    oo(e, M, t, a);
  } else M = Ep(n, e, t, a, i);
  return _s(M);
}
Ph = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = pn(e.pendingLanes);
        n !== 0 &&
          (Wr(e, n | 1), le(e, zt()), !(Pt & 6) && ((Qi = zt() + 500), ci()));
      }
      break;
    case 13:
      ki(function () {
        var i = Ge(t, 1);
        if (i !== null) {
          var a = ee();
          Te(i, t, 1, a);
        }
      }),
        Ca(t, 1);
  }
};
Yr = function (t) {
  if (t.tag === 13) {
    var e = Ge(t, 134217728);
    if (e !== null) {
      var n = ee();
      Te(e, t, 134217728, n);
    }
    Ca(t, 134217728);
  }
};
Ah = function (t) {
  if (t.tag === 13) {
    var e = si(t),
      n = Ge(t, e);
    if (n !== null) {
      var i = ee();
      Te(n, t, e, i);
    }
    Ca(t, e);
  }
};
Th = function () {
  return At;
};
Eh = function (t, e) {
  var n = At;
  try {
    return (At = t), e();
  } finally {
    At = n;
  }
};
$o = function (t, e, n) {
  switch (e) {
    case "input":
      if ((Xo(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var i = n[e];
          if (i !== t && i.form === t.form) {
            var a = Qs(i);
            if (!a) throw Error(mt(90));
            rh(i), Xo(i, a);
          }
        }
      }
      break;
    case "textarea":
      lh(t, n);
      break;
    case "select":
      (e = n.value), e != null && Hi(t, !!n.multiple, e, !1);
  }
};
gh = xa;
mh = ki;
var Lp = { usingClientEntryPoint: !1, Events: [Wn, ji, Qs, ph, fh, xa] },
  cn = {
    findFiberByHostInstance: pi,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  Dp = {
    bundleType: cn.bundleType,
    version: cn.version,
    rendererPackageName: cn.rendererPackageName,
    rendererConfig: cn.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: We.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = vh(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: cn.findFiberByHostInstance || Tp,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var hs = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!hs.isDisabled && hs.supportsFiber)
    try {
      (qs = hs.inject(Dp)), (Ne = hs);
    } catch {}
}
pe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Lp;
pe.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Ma(e)) throw Error(mt(200));
  return Ap(t, e, null, n);
};
pe.createRoot = function (t, e) {
  if (!Ma(t)) throw Error(mt(299));
  var n = !1,
    i = "",
    a = Qc;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (a = e.onRecoverableError)),
    (e = ka(t, 1, !1, null, null, n, !1, i, a)),
    (t[Ue] = e.current),
    jn(t.nodeType === 8 ? t.parentNode : t),
    new ba(e)
  );
};
pe.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(mt(188))
      : ((t = Object.keys(t).join(",")), Error(mt(268, t)));
  return (t = vh(e)), (t = t === null ? null : t.stateNode), t;
};
pe.flushSync = function (t) {
  return ki(t);
};
pe.hydrate = function (t, e, n) {
  if (!ao(e)) throw Error(mt(200));
  return lo(null, t, e, !0, n);
};
pe.hydrateRoot = function (t, e, n) {
  if (!Ma(t)) throw Error(mt(405));
  var i = (n != null && n.hydratedSources) || null,
    a = !1,
    d = "",
    M = Qc;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (a = !0),
      n.identifierPrefix !== void 0 && (d = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (M = n.onRecoverableError)),
    (e = Zc(e, null, t, 1, n ?? null, a, !1, d, M)),
    (t[Ue] = e.current),
    jn(t),
    i)
  )
    for (t = 0; t < i.length; t++)
      (n = i[t]),
        (a = n._getVersion),
        (a = a(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, a])
          : e.mutableSourceEagerHydrationData.push(n, a);
  return new ro(e);
};
pe.render = function (t, e, n) {
  if (!ao(e)) throw Error(mt(200));
  return lo(null, t, e, !1, n);
};
pe.unmountComponentAtNode = function (t) {
  if (!ao(t)) throw Error(mt(40));
  return t._reactRootContainer
    ? (ki(function () {
        lo(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[Ue] = null);
        });
      }),
      !0)
    : !1;
};
pe.unstable_batchedUpdates = xa;
pe.unstable_renderSubtreeIntoContainer = function (t, e, n, i) {
  if (!ao(n)) throw Error(mt(200));
  if (t == null || t._reactInternals === void 0) throw Error(mt(38));
  return lo(t, e, n, !1, i);
};
pe.version = "18.2.0-next-9e3b772b8-20220608";
function Jc() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Jc);
    } catch (t) {
      console.error(t);
    }
}
Jc(), (Zl.exports = pe);
var jp = Zl.exports,
  Ol = jp;
(Bo.createRoot = Ol.createRoot), (Bo.hydrateRoot = Ol.hydrateRoot);
var td = { exports: {} };
(function (t) {
  (function (e, n) {
    t.exports
      ? ((n.default = n), (t.exports = e.document ? n(e) : n))
      : (e.Highcharts && e.Highcharts.error(16, !0), (e.Highcharts = n(e)));
  })(typeof window < "u" ? window : Hl, function (e) {
    function n(a, d, M, O) {
      a.hasOwnProperty(d) ||
        ((a[d] = O.apply(null, M)),
        typeof CustomEvent == "function" &&
          e.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: d, module: a[d] },
            })
          ));
    }
    var i = {};
    return (
      n(i, "Core/Globals.js", [], function () {
        var a;
        return (
          (function (d) {
            (d.SVG_NS = "http://www.w3.org/2000/svg"),
              (d.product = "Highcharts"),
              (d.version = "11.1.0"),
              (d.win = typeof e < "u" ? e : {}),
              (d.doc = d.win.document),
              (d.svg =
                d.doc &&
                d.doc.createElementNS &&
                !!d.doc.createElementNS(d.SVG_NS, "svg").createSVGRect),
              (d.userAgent =
                (d.win.navigator && d.win.navigator.userAgent) || ""),
              (d.isChrome = d.userAgent.indexOf("Chrome") !== -1),
              (d.isFirefox = d.userAgent.indexOf("Firefox") !== -1),
              (d.isMS =
                /(edge|msie|trident)/i.test(d.userAgent) && !d.win.opera),
              (d.isSafari =
                !d.isChrome && d.userAgent.indexOf("Safari") !== -1),
              (d.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(
                d.userAgent
              )),
              (d.isWebKit = d.userAgent.indexOf("AppleWebKit") !== -1),
              (d.deg2rad = (2 * Math.PI) / 360),
              (d.hasBidiBug =
                d.isFirefox &&
                4 > parseInt(d.userAgent.split("Firefox/")[1], 10)),
              (d.hasTouch = !!d.win.TouchEvent),
              (d.marginNames = [
                "plotTop",
                "marginRight",
                "marginBottom",
                "plotLeft",
              ]),
              (d.noop = function () {}),
              (d.supportsPassiveEvents = (function () {
                let M = !1;
                if (!d.isMS) {
                  const O = Object.defineProperty({}, "passive", {
                    get: function () {
                      M = !0;
                    },
                  });
                  d.win.addEventListener &&
                    d.win.removeEventListener &&
                    (d.win.addEventListener("testPassive", d.noop, O),
                    d.win.removeEventListener("testPassive", d.noop, O));
                }
                return M;
              })()),
              (d.charts = []),
              (d.dateFormats = {}),
              (d.seriesTypes = {}),
              (d.symbolSizes = {}),
              (d.chartCount = 0);
          })(a || (a = {})),
          a
        );
      }),
      n(i, "Core/Utilities.js", [i["Core/Globals.js"]], function (a) {
        function d(r, c, u, v) {
          const N = c ? "Highcharts error" : "Highcharts warning";
          r === 32 && (r = `${N}: Deprecated member`);
          const w = E(r);
          let R = w
            ? `${N} #${r}: www.highcharts.com/errors/${r}/`
            : r.toString();
          if (typeof v < "u") {
            let X = "";
            w && (R += "?"),
              T(v, function (J, K) {
                (X += `
 - ${K}: ${J}`),
                  w && (R += encodeURI(K) + "=" + encodeURI(J));
              }),
              (R += X);
          }
          A(
            a,
            "displayError",
            { chart: u, code: r, message: R, params: v },
            function () {
              if (c) throw Error(R);
              b.console && d.messages.indexOf(R) === -1 && console.warn(R);
            }
          ),
            d.messages.push(R);
        }
        function M(r, c) {
          return parseInt(r, c || 10);
        }
        function O(r) {
          return typeof r == "string";
        }
        function B(r) {
          return (
            (r = Object.prototype.toString.call(r)),
            r === "[object Array]" || r === "[object Array Iterator]"
          );
        }
        function G(r, c) {
          return !!r && typeof r == "object" && (!c || !B(r));
        }
        function Y(r) {
          return G(r) && typeof r.nodeType == "number";
        }
        function L(r) {
          const c = r && r.constructor;
          return !(!G(r, !0) || Y(r) || !c || !c.name || c.name === "Object");
        }
        function E(r) {
          return typeof r == "number" && !isNaN(r) && 1 / 0 > r && -1 / 0 < r;
        }
        function z(r) {
          return typeof r < "u" && r !== null;
        }
        function S(r, c, u) {
          const v = O(c) && !z(u);
          let N;
          const w = (R, X) => {
            z(R)
              ? r.setAttribute(X, R)
              : v
              ? (N = r.getAttribute(X)) ||
                X !== "class" ||
                (N = r.getAttribute(X + "Name"))
              : r.removeAttribute(X);
          };
          return O(c) ? w(u, c) : T(c, w), N;
        }
        function x(r) {
          return B(r) ? r : [r];
        }
        function P(r, c) {
          let u;
          r || (r = {});
          for (u in c) r[u] = c[u];
          return r;
        }
        function h() {
          const r = arguments,
            c = r.length;
          for (let u = 0; u < c; u++) {
            const v = r[u];
            if (typeof v < "u" && v !== null) return v;
          }
        }
        function s(r, c) {
          a.isMS &&
            !a.svg &&
            c &&
            z(c.opacity) &&
            (c.filter = `alpha(opacity=${100 * c.opacity})`),
            P(r.style, c);
        }
        function l(r) {
          return Math.pow(10, Math.floor(Math.log(r) / Math.LN10));
        }
        function p(r, c) {
          return 1e14 < r ? r : parseFloat(r.toPrecision(c || 14));
        }
        function g(r, c, u) {
          let v;
          return c === "width"
            ? ((c = Math.min(r.offsetWidth, r.scrollWidth)),
              (u = r.getBoundingClientRect && r.getBoundingClientRect().width),
              u < c && u >= c - 1 && (c = Math.floor(u)),
              Math.max(
                0,
                c -
                  (g(r, "padding-left", !0) || 0) -
                  (g(r, "padding-right", !0) || 0)
              ))
            : c === "height"
            ? Math.max(
                0,
                Math.min(r.offsetHeight, r.scrollHeight) -
                  (g(r, "padding-top", !0) || 0) -
                  (g(r, "padding-bottom", !0) || 0)
              )
            : ((r = b.getComputedStyle(r, void 0)) &&
                ((v = r.getPropertyValue(c)),
                h(u, c !== "opacity") && (v = M(v))),
              v);
        }
        function T(r, c, u) {
          for (const v in r)
            Object.hasOwnProperty.call(r, v) && c.call(u || r[v], r[v], v, r);
        }
        function D(r, c, u) {
          function v(R, X) {
            const J = r.removeEventListener;
            J && J.call(r, R, X, !1);
          }
          function N(R) {
            let X, J;
            r.nodeName &&
              (c ? ((X = {}), (X[c] = !0)) : (X = R),
              T(X, function (K, H) {
                if (R[H]) for (J = R[H].length; J--; ) v(H, R[H][J].fn);
              }));
          }
          var w = (typeof r == "function" && r.prototype) || r;
          if (Object.hasOwnProperty.call(w, "hcEvents")) {
            const R = w.hcEvents;
            c
              ? ((w = R[c] || []),
                u
                  ? ((R[c] = w.filter(function (X) {
                      return u !== X.fn;
                    })),
                    v(c, u))
                  : (N(R), (R[c] = [])))
              : (N(R), delete w.hcEvents);
          }
        }
        function A(r, c, u, v) {
          if (
            ((u = u || {}),
            f.createEvent && (r.dispatchEvent || (r.fireEvent && r !== a)))
          ) {
            var N = f.createEvent("Events");
            N.initEvent(c, !0, !0),
              (u = P(N, u)),
              r.dispatchEvent ? r.dispatchEvent(u) : r.fireEvent(c, u);
          } else if (r.hcEvents) {
            u.target ||
              P(u, {
                preventDefault: function () {
                  u.defaultPrevented = !0;
                },
                target: r,
                type: c,
              }),
              (N = []);
            let w = r,
              R = !1;
            for (; w.hcEvents; )
              Object.hasOwnProperty.call(w, "hcEvents") &&
                w.hcEvents[c] &&
                (N.length && (R = !0), N.unshift.apply(N, w.hcEvents[c])),
                (w = Object.getPrototypeOf(w));
            R && N.sort((X, J) => X.order - J.order),
              N.forEach((X) => {
                X.fn.call(r, u) === !1 && u.preventDefault();
              });
          }
          v && !u.defaultPrevented && v.call(r, u);
        }
        const { charts: m, doc: f, win: b } = a;
        ((d || (d = {})).messages = []),
          (Math.easeInOutSine = function (r) {
            return -0.5 * (Math.cos(Math.PI * r) - 1);
          });
        var y = Array.prototype.find
          ? function (r, c) {
              return r.find(c);
            }
          : function (r, c) {
              let u;
              const v = r.length;
              for (u = 0; u < v; u++) if (c(r[u], u)) return r[u];
            };
        T(
          {
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some",
          },
          function (r, c) {
            a[c] = function (u) {
              return (
                d(32, !1, void 0, { [`Highcharts.${c}`]: `use Array.${r}` }),
                Array.prototype[r].apply(u, [].slice.call(arguments, 1))
              );
            };
          }
        );
        let C;
        const o = (function () {
          const r = Math.random().toString(36).substring(2, 9) + "-";
          let c = 0;
          return function () {
            return "highcharts-" + (C ? "" : r) + c++;
          };
        })();
        return (
          b.jQuery &&
            (b.jQuery.fn.highcharts = function () {
              const r = [].slice.call(arguments);
              if (this[0])
                return r[0]
                  ? (new a[O(r[0]) ? r.shift() : "Chart"](this[0], r[0], r[1]),
                    this)
                  : m[S(this[0], "data-highcharts-chart")];
            }),
          (y = {
            addEvent: function (r, c, u, v = {}) {
              var N = (typeof r == "function" && r.prototype) || r;
              Object.hasOwnProperty.call(N, "hcEvents") || (N.hcEvents = {}),
                (N = N.hcEvents),
                a.Point &&
                  r instanceof a.Point &&
                  r.series &&
                  r.series.chart &&
                  (r.series.chart.runTrackerClick = !0);
              const w = r.addEventListener;
              return (
                w &&
                  w.call(
                    r,
                    c,
                    u,
                    a.supportsPassiveEvents
                      ? {
                          passive:
                            v.passive === void 0
                              ? c.indexOf("touch") !== -1
                              : v.passive,
                          capture: !1,
                        }
                      : !1
                  ),
                N[c] || (N[c] = []),
                N[c].push({
                  fn: u,
                  order: typeof v.order == "number" ? v.order : 1 / 0,
                }),
                N[c].sort((R, X) => R.order - X.order),
                function () {
                  D(r, c, u);
                }
              );
            },
            arrayMax: function (r) {
              let c = r.length,
                u = r[0];
              for (; c--; ) r[c] > u && (u = r[c]);
              return u;
            },
            arrayMin: function (r) {
              let c = r.length,
                u = r[0];
              for (; c--; ) r[c] < u && (u = r[c]);
              return u;
            },
            attr: S,
            clamp: function (r, c, u) {
              return r > c ? (r < u ? r : u) : c;
            },
            clearTimeout: function (r) {
              z(r) && clearTimeout(r);
            },
            correctFloat: p,
            createElement: function (r, c, u, v, N) {
              return (
                (r = f.createElement(r)),
                c && P(r, c),
                N && s(r, { padding: "0", border: "none", margin: "0" }),
                u && s(r, u),
                v && v.appendChild(r),
                r
              );
            },
            css: s,
            defined: z,
            destroyObjectProperties: function (r, c) {
              T(r, function (u, v) {
                u && u !== c && u.destroy && u.destroy(), delete r[v];
              });
            },
            diffObjects: function (r, c, u, v) {
              function N(R, X, J, K) {
                const H = u ? X : R;
                T(R, function (k, U) {
                  if (!K && v && -1 < v.indexOf(U) && X[U]) {
                    (k = x(k)), (J[U] = []);
                    for (let _ = 0; _ < Math.max(k.length, X[U].length); _++)
                      X[U][_] &&
                        (k[_] === void 0
                          ? (J[U][_] = X[U][_])
                          : ((J[U][_] = {}), N(k[_], X[U][_], J[U][_], K + 1)));
                  } else G(k, !0) && !k.nodeType ? ((J[U] = B(k) ? [] : {}), N(k, X[U] || {}, J[U], K + 1), Object.keys(J[U]).length !== 0 || (U === "colorAxis" && K === 0) || delete J[U]) : (R[U] !== X[U] || (U in R && !(U in X))) && (J[U] = H[U]);
                });
              }
              const w = {};
              return N(r, c, w, 0), w;
            },
            discardElement: function (r) {
              r && r.parentElement && r.parentElement.removeChild(r);
            },
            erase: function (r, c) {
              let u = r.length;
              for (; u--; )
                if (r[u] === c) {
                  r.splice(u, 1);
                  break;
                }
            },
            error: d,
            extend: P,
            extendClass: function (r, c) {
              const u = function () {};
              return (u.prototype = new r()), P(u.prototype, c), u;
            },
            find: y,
            fireEvent: A,
            getClosestDistance: function (r, c) {
              const u = !c;
              let v, N, w;
              return (
                r.forEach((R) => {
                  if (1 < R.length)
                    for (w = R.length - 1; 0 < w; w--)
                      (N = R[w] - R[w - 1]),
                        0 > N && !u
                          ? (c == null || c(), (c = void 0))
                          : N && (typeof v > "u" || N < v) && (v = N);
                }),
                v
              );
            },
            getMagnitude: l,
            getNestedProperty: function (r, c) {
              for (r = r.split("."); r.length && z(c); ) {
                const u = r.shift();
                if (typeof u > "u" || u === "__proto__") return;
                if (u === "this") {
                  let v;
                  return G(c) && (v = c["@this"]), v ?? c;
                }
                if (
                  ((c = c[u]),
                  !z(c) ||
                    typeof c == "function" ||
                    typeof c.nodeType == "number" ||
                    c === b)
                )
                  return;
              }
              return c;
            },
            getStyle: g,
            inArray: function (r, c, u) {
              return (
                d(32, !1, void 0, {
                  "Highcharts.inArray": "use Array.indexOf",
                }),
                c.indexOf(r, u)
              );
            },
            insertItem: function (r, c) {
              const u = r.options.index,
                v = c.length;
              let N;
              for (N = r.options.isInternal ? v : 0; N < v + 1; N++)
                if (
                  !c[N] ||
                  (E(u) && u < h(c[N].options.index, c[N]._i)) ||
                  c[N].options.isInternal
                ) {
                  c.splice(N, 0, r);
                  break;
                }
              return N;
            },
            isArray: B,
            isClass: L,
            isDOMElement: Y,
            isFunction: function (r) {
              return typeof r == "function";
            },
            isNumber: E,
            isObject: G,
            isString: O,
            keys: function (r) {
              return (
                d(32, !1, void 0, { "Highcharts.keys": "use Object.keys" }),
                Object.keys(r)
              );
            },
            merge: function () {
              let r,
                c = arguments,
                u = {};
              const v = function (w, R) {
                return (
                  typeof w != "object" && (w = {}),
                  T(R, function (X, J) {
                    J !== "__proto__" &&
                      J !== "constructor" &&
                      (!G(X, !0) || L(X) || Y(X)
                        ? (w[J] = R[J])
                        : (w[J] = v(w[J] || {}, X)));
                  }),
                  w
                );
              };
              c[0] === !0 &&
                ((u = c[1]), (c = Array.prototype.slice.call(c, 2)));
              const N = c.length;
              for (r = 0; r < N; r++) u = v(u, c[r]);
              return u;
            },
            normalizeTickInterval: function (r, c, u, v, N) {
              let w = r;
              u = h(u, l(r));
              const R = r / u;
              for (
                c ||
                  ((c = N
                    ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
                    : [1, 2, 2.5, 5, 10]),
                  v === !1 &&
                    (u === 1
                      ? (c = c.filter(function (X) {
                          return X % 1 === 0;
                        }))
                      : 0.1 >= u && (c = [1 / u]))),
                  v = 0;
                v < c.length &&
                ((w = c[v]),
                !(
                  (N && w * u >= r) ||
                  (!N && R <= (c[v] + (c[v + 1] || c[v])) / 2)
                ));
                v++
              );
              return (w = p(w * u, -Math.round(Math.log(0.001) / Math.LN10)));
            },
            objectEach: T,
            offset: function (r) {
              const c = f.documentElement;
              return (
                (r =
                  r.parentElement || r.parentNode
                    ? r.getBoundingClientRect()
                    : { top: 0, left: 0, width: 0, height: 0 }),
                {
                  top:
                    r.top + (b.pageYOffset || c.scrollTop) - (c.clientTop || 0),
                  left:
                    r.left +
                    (b.pageXOffset || c.scrollLeft) -
                    (c.clientLeft || 0),
                  width: r.width,
                  height: r.height,
                }
              );
            },
            pad: function (r, c, u) {
              return (
                Array((c || 2) + 1 - String(r).replace("-", "").length).join(
                  u || "0"
                ) + r
              );
            },
            pick: h,
            pInt: M,
            pushUnique: function (r, c) {
              return 0 > r.indexOf(c) && !!r.push(c);
            },
            relativeLength: function (r, c, u) {
              return /%$/.test(r)
                ? (c * parseFloat(r)) / 100 + (u || 0)
                : parseFloat(r);
            },
            removeEvent: D,
            splat: x,
            stableSort: function (r, c) {
              const u = r.length;
              let v, N;
              for (N = 0; N < u; N++) r[N].safeI = N;
              for (
                r.sort(function (w, R) {
                  return (v = c(w, R)), v === 0 ? w.safeI - R.safeI : v;
                }),
                  N = 0;
                N < u;
                N++
              )
                delete r[N].safeI;
            },
            syncTimeout: function (r, c, u) {
              return 0 < c ? setTimeout(r, c, u) : (r.call(0, u), -1);
            },
            timeUnits: {
              millisecond: 1,
              second: 1e3,
              minute: 6e4,
              hour: 36e5,
              day: 864e5,
              week: 6048e5,
              month: 24192e5,
              year: 314496e5,
            },
            uniqueKey: o,
            useSerialIds: function (r) {
              return (C = h(r, C));
            },
            wrap: function (r, c, u) {
              const v = r[c];
              r[c] = function () {
                const N = arguments,
                  w = this;
                return u.apply(
                  this,
                  [
                    function () {
                      return v.apply(w, arguments.length ? arguments : N);
                    },
                  ].concat([].slice.call(arguments))
                );
              };
            },
          }),
          y
        );
      }),
      n(i, "Core/Chart/ChartDefaults.js", [], function () {
        return {
          alignThresholds: !1,
          panning: { enabled: !1, type: "x" },
          styledMode: !1,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: !0,
          ignoreHiddenSeries: !0,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: { zIndex: 6 },
            position: { align: "right", x: -10, y: 10 },
          },
          reflow: !0,
          type: "line",
          zooming: {
            singleTouch: !1,
            resetButton: {
              theme: { zIndex: 6 },
              position: { align: "right", x: -10, y: 10 },
            },
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc",
        };
      }),
      n(
        i,
        "Core/Color/Color.js",
        [i["Core/Globals.js"], i["Core/Utilities.js"]],
        function (a, d) {
          const { isNumber: M, merge: O, pInt: B } = d;
          class G {
            static parse(L) {
              return L ? new G(L) : G.None;
            }
            constructor(L) {
              (this.rgba = [NaN, NaN, NaN, NaN]), (this.input = L);
              const E = a.Color;
              if (E && E !== G) return new E(L);
              this.init(L);
            }
            init(L) {
              let E, z;
              if (typeof L == "object" && typeof L.stops < "u")
                this.stops = L.stops.map((P) => new G(P[1]));
              else if (typeof L == "string") {
                if (
                  ((this.input = L = G.names[L.toLowerCase()] || L),
                  L.charAt(0) === "#")
                ) {
                  var S = L.length,
                    x = parseInt(L.substr(1), 16);
                  S === 7
                    ? (E = [(x & 16711680) >> 16, (x & 65280) >> 8, x & 255, 1])
                    : S === 4 &&
                      (E = [
                        ((x & 3840) >> 4) | ((x & 3840) >> 8),
                        ((x & 240) >> 4) | (x & 240),
                        ((x & 15) << 4) | (x & 15),
                        1,
                      ]);
                }
                if (!E)
                  for (x = G.parsers.length; x-- && !E; )
                    (z = G.parsers[x]),
                      (S = z.regex.exec(L)) && (E = z.parse(S));
              }
              E && (this.rgba = E);
            }
            get(L) {
              const E = this.input,
                z = this.rgba;
              if (typeof E == "object" && typeof this.stops < "u") {
                const S = O(E);
                return (
                  (S.stops = [].slice.call(S.stops)),
                  this.stops.forEach((x, P) => {
                    S.stops[P] = [S.stops[P][0], x.get(L)];
                  }),
                  S
                );
              }
              return z && M(z[0])
                ? L === "rgb" || (!L && z[3] === 1)
                  ? "rgb(" + z[0] + "," + z[1] + "," + z[2] + ")"
                  : L === "a"
                  ? `${z[3]}`
                  : "rgba(" + z.join(",") + ")"
                : E;
            }
            brighten(L) {
              const E = this.rgba;
              if (this.stops)
                this.stops.forEach(function (z) {
                  z.brighten(L);
                });
              else if (M(L) && L !== 0)
                for (let z = 0; 3 > z; z++)
                  (E[z] += B(255 * L)),
                    0 > E[z] && (E[z] = 0),
                    255 < E[z] && (E[z] = 255);
              return this;
            }
            setOpacity(L) {
              return (this.rgba[3] = L), this;
            }
            tweenTo(L, E) {
              const z = this.rgba,
                S = L.rgba;
              return !M(z[0]) || !M(S[0])
                ? L.input || "none"
                : ((L = S[3] !== 1 || z[3] !== 1),
                  (L ? "rgba(" : "rgb(") +
                    Math.round(S[0] + (z[0] - S[0]) * (1 - E)) +
                    "," +
                    Math.round(S[1] + (z[1] - S[1]) * (1 - E)) +
                    "," +
                    Math.round(S[2] + (z[2] - S[2]) * (1 - E)) +
                    (L ? "," + (S[3] + (z[3] - S[3]) * (1 - E)) : "") +
                    ")");
            }
          }
          return (
            (G.names = { white: "#ffffff", black: "#000000" }),
            (G.parsers = [
              {
                regex:
                  /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function (Y) {
                  return [B(Y[1]), B(Y[2]), B(Y[3]), parseFloat(Y[4], 10)];
                },
              },
              {
                regex:
                  /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function (Y) {
                  return [B(Y[1]), B(Y[2]), B(Y[3]), 1];
                },
              },
            ]),
            (G.None = new G("")),
            G
          );
        }
      ),
      n(i, "Core/Color/Palettes.js", [], function () {
        return {
          colors:
            "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(
              " "
            ),
        };
      }),
      n(
        i,
        "Core/Time.js",
        [i["Core/Globals.js"], i["Core/Utilities.js"]],
        function (a, d) {
          const { win: M } = a,
            {
              defined: O,
              error: B,
              extend: G,
              isObject: Y,
              merge: L,
              objectEach: E,
              pad: z,
              pick: S,
              splat: x,
              timeUnits: P,
            } = d,
            h =
              a.isSafari &&
              M.Intl &&
              M.Intl.DateTimeFormat.prototype.formatRange,
            s =
              a.isSafari &&
              M.Intl &&
              !M.Intl.DateTimeFormat.prototype.formatRange;
          class l {
            constructor(g) {
              (this.options = {}),
                (this.variableTimezone = this.useUTC = !1),
                (this.Date = M.Date),
                (this.getTimezoneOffset = this.timezoneOffsetFunction()),
                this.update(g);
            }
            get(g, T) {
              if (this.variableTimezone || this.timezoneOffset) {
                const D = T.getTime(),
                  A = D - this.getTimezoneOffset(T);
                return T.setTime(A), (g = T["getUTC" + g]()), T.setTime(D), g;
              }
              return this.useUTC ? T["getUTC" + g]() : T["get" + g]();
            }
            set(g, T, D) {
              if (this.variableTimezone || this.timezoneOffset) {
                if (
                  g === "Milliseconds" ||
                  g === "Seconds" ||
                  (g === "Minutes" && this.getTimezoneOffset(T) % 36e5 === 0)
                )
                  return T["setUTC" + g](D);
                var A = this.getTimezoneOffset(T);
                return (
                  (A = T.getTime() - A),
                  T.setTime(A),
                  T["setUTC" + g](D),
                  (g = this.getTimezoneOffset(T)),
                  (A = T.getTime() + g),
                  T.setTime(A)
                );
              }
              return this.useUTC || (h && g === "FullYear")
                ? T["setUTC" + g](D)
                : T["set" + g](D);
            }
            update(g = {}) {
              const T = S(g.useUTC, !0);
              (this.options = g = L(!0, this.options, g)),
                (this.Date = g.Date || M.Date || Date),
                (this.timezoneOffset =
                  ((this.useUTC = T) && g.timezoneOffset) || void 0),
                (this.getTimezoneOffset = this.timezoneOffsetFunction()),
                (this.variableTimezone =
                  T && !(!g.getTimezoneOffset && !g.timezone));
            }
            makeTime(g, T, D, A, m, f) {
              let b, y, C;
              return (
                this.useUTC
                  ? ((b = this.Date.UTC.apply(0, arguments)),
                    (y = this.getTimezoneOffset(b)),
                    (b += y),
                    (C = this.getTimezoneOffset(b)),
                    y !== C
                      ? (b += C - y)
                      : y - 36e5 !== this.getTimezoneOffset(b - 36e5) ||
                        s ||
                        (b -= 36e5))
                  : (b = new this.Date(
                      g,
                      T,
                      S(D, 1),
                      S(A, 0),
                      S(m, 0),
                      S(f, 0)
                    ).getTime()),
                b
              );
            }
            timezoneOffsetFunction() {
              const g = this,
                T = this.options,
                D = T.getTimezoneOffset,
                A = T.moment || M.moment;
              if (!this.useUTC)
                return function (m) {
                  return 6e4 * new Date(m.toString()).getTimezoneOffset();
                };
              if (T.timezone) {
                if (A)
                  return function (m) {
                    return 6e4 * -A.tz(m, T.timezone).utcOffset();
                  };
                B(25);
              }
              return this.useUTC && D
                ? function (m) {
                    return 6e4 * D(m.valueOf());
                  }
                : function () {
                    return 6e4 * (g.timezoneOffset || 0);
                  };
            }
            dateFormat(g, T, D) {
              if (!O(T) || isNaN(T))
                return (
                  (a.defaultOptions.lang &&
                    a.defaultOptions.lang.invalidDate) ||
                  ""
                );
              g = S(g, "%Y-%m-%d %H:%M:%S");
              const A = this;
              var m = new this.Date(T);
              const f = this.get("Hours", m),
                b = this.get("Day", m),
                y = this.get("Date", m),
                C = this.get("Month", m),
                o = this.get("FullYear", m),
                r = a.defaultOptions.lang,
                c = r && r.weekdays,
                u = r && r.shortWeekdays;
              return (
                (m = G(
                  {
                    a: u ? u[b] : c[b].substr(0, 3),
                    A: c[b],
                    d: z(y),
                    e: z(y, 2, " "),
                    w: b,
                    b: r.shortMonths[C],
                    B: r.months[C],
                    m: z(C + 1),
                    o: C + 1,
                    y: o.toString().substr(2, 2),
                    Y: o,
                    H: z(f),
                    k: f,
                    I: z(f % 12 || 12),
                    l: f % 12 || 12,
                    M: z(this.get("Minutes", m)),
                    p: 12 > f ? "AM" : "PM",
                    P: 12 > f ? "am" : "pm",
                    S: z(m.getSeconds()),
                    L: z(Math.floor(T % 1e3), 3),
                  },
                  a.dateFormats
                )),
                E(m, function (v, N) {
                  for (; g.indexOf("%" + N) !== -1; )
                    g = g.replace(
                      "%" + N,
                      typeof v == "function" ? v.call(A, T) : v
                    );
                }),
                D ? g.substr(0, 1).toUpperCase() + g.substr(1) : g
              );
            }
            resolveDTLFormat(g) {
              return Y(g, !0)
                ? g
                : ((g = x(g)), { main: g[0], from: g[1], to: g[2] });
            }
            getTimeTicks(g, T, D, A) {
              const m = this,
                f = [],
                b = {};
              var y = new m.Date(T);
              const C = g.unitRange,
                o = g.count || 1;
              let r;
              if (((A = S(A, 1)), O(T))) {
                if (
                  (m.set(
                    "Milliseconds",
                    y,
                    C >= P.second
                      ? 0
                      : o * Math.floor(m.get("Milliseconds", y) / o)
                  ),
                  C >= P.second &&
                    m.set(
                      "Seconds",
                      y,
                      C >= P.minute
                        ? 0
                        : o * Math.floor(m.get("Seconds", y) / o)
                    ),
                  C >= P.minute &&
                    m.set(
                      "Minutes",
                      y,
                      C >= P.hour ? 0 : o * Math.floor(m.get("Minutes", y) / o)
                    ),
                  C >= P.hour &&
                    m.set(
                      "Hours",
                      y,
                      C >= P.day ? 0 : o * Math.floor(m.get("Hours", y) / o)
                    ),
                  C >= P.day &&
                    m.set(
                      "Date",
                      y,
                      C >= P.month
                        ? 1
                        : Math.max(1, o * Math.floor(m.get("Date", y) / o))
                    ),
                  C >= P.month)
                ) {
                  m.set(
                    "Month",
                    y,
                    C >= P.year ? 0 : o * Math.floor(m.get("Month", y) / o)
                  );
                  var c = m.get("FullYear", y);
                }
                C >= P.year && m.set("FullYear", y, c - (c % o)),
                  C === P.week &&
                    ((c = m.get("Day", y)),
                    m.set(
                      "Date",
                      y,
                      m.get("Date", y) - c + A + (c < A ? -7 : 0)
                    )),
                  (c = m.get("FullYear", y)),
                  (A = m.get("Month", y));
                const u = m.get("Date", y),
                  v = m.get("Hours", y);
                for (
                  T = y.getTime(),
                    (!m.variableTimezone && m.useUTC) ||
                      !O(D) ||
                      (r =
                        D - T > 4 * P.month ||
                        m.getTimezoneOffset(T) !== m.getTimezoneOffset(D)),
                    T = y.getTime(),
                    y = 1;
                  T < D;

                )
                  f.push(T),
                    (T =
                      C === P.year
                        ? m.makeTime(c + y * o, 0)
                        : C === P.month
                        ? m.makeTime(c, A + y * o)
                        : !r || (C !== P.day && C !== P.week)
                        ? r && C === P.hour && 1 < o
                          ? m.makeTime(c, A, u, v + y * o)
                          : T + C * o
                        : m.makeTime(c, A, u + y * o * (C === P.day ? 1 : 7))),
                    y++;
                f.push(T),
                  C <= P.hour &&
                    1e4 > f.length &&
                    f.forEach(function (N) {
                      N % 18e5 === 0 &&
                        m.dateFormat("%H%M%S%L", N) === "000000000" &&
                        (b[N] = "day");
                    });
              }
              return (f.info = G(g, { higherRanks: b, totalRange: C * o })), f;
            }
            getDateFormat(g, T, D, A) {
              const m = this.dateFormat("%m-%d %H:%M:%S.%L", T),
                f = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
              let b,
                y = "millisecond";
              for (b in P) {
                if (
                  g === P.week &&
                  +this.dateFormat("%w", T) === D &&
                  m.substr(6) === "00:00:00.000"
                ) {
                  b = "week";
                  break;
                }
                if (P[b] > g) {
                  b = y;
                  break;
                }
                if (
                  f[b] &&
                  m.substr(f[b]) !== "01-01 00:00:00.000".substr(f[b])
                )
                  break;
                b !== "week" && (y = b);
              }
              return this.resolveDTLFormat(A[b]).main;
            }
          }
          return l;
        }
      ),
      n(
        i,
        "Core/Defaults.js",
        [
          i["Core/Chart/ChartDefaults.js"],
          i["Core/Color/Color.js"],
          i["Core/Globals.js"],
          i["Core/Color/Palettes.js"],
          i["Core/Time.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G) {
          const { isTouchDevice: Y, svg: L } = M,
            { merge: E } = G,
            z = {
              colors: O.colors,
              symbols: [
                "circle",
                "diamond",
                "square",
                "triangle",
                "triangle-down",
              ],
              lang: {
                loading: "Loading...",
                months:
                  "January February March April May June July August September October November December".split(
                    " "
                  ),
                shortMonths:
                  "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays:
                  "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                    " "
                  ),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " ",
              },
              global: {},
              time: {
                Date: void 0,
                getTimezoneOffset: void 0,
                timezone: void 0,
                timezoneOffset: 0,
                useUTC: !0,
              },
              chart: a,
              title: {
                style: { color: "#333333", fontWeight: "bold" },
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44,
              },
              subtitle: {
                style: { color: "#666666", fontSize: "0.8em" },
                text: "",
                align: "center",
                widthAdjust: -44,
              },
              caption: {
                margin: 15,
                style: { color: "#666666", fontSize: "0.8em" },
                text: "",
                align: "left",
                verticalAlign: "bottom",
              },
              plotOptions: {},
              legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                className: "highcharts-no-tooltip",
                layout: "horizontal",
                itemMarginBottom: 2,
                itemMarginTop: 2,
                labelFormatter: function () {
                  return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                  style: { fontSize: "0.8em" },
                  activeColor: "#0022ff",
                  inactiveColor: "#cccccc",
                },
                itemStyle: {
                  color: "#333333",
                  cursor: "pointer",
                  fontSize: "0.8em",
                  textDecoration: "none",
                  textOverflow: "ellipsis",
                },
                itemHoverStyle: { color: "#000000" },
                itemHiddenStyle: {
                  color: "#666666",
                  textDecoration: "line-through",
                },
                shadow: !1,
                itemCheckboxStyle: {
                  position: "absolute",
                  width: "13px",
                  height: "13px",
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: { style: { fontSize: "0.8em", fontWeight: "bold" } },
              },
              loading: {
                labelStyle: {
                  fontWeight: "bold",
                  position: "relative",
                  top: "45%",
                },
                style: {
                  position: "absolute",
                  backgroundColor: "#ffffff",
                  opacity: 0.5,
                  textAlign: "center",
                },
              },
              tooltip: {
                enabled: !0,
                animation: L,
                borderRadius: 3,
                dateTimeLabelFormats: {
                  millisecond: "%A, %e %b, %H:%M:%S.%L",
                  second: "%A, %e %b, %H:%M:%S",
                  minute: "%A, %e %b, %H:%M",
                  hour: "%A, %e %b, %H:%M",
                  day: "%A, %e %b %Y",
                  week: "Week from %A, %e %b %Y",
                  month: "%B %Y",
                  year: "%Y",
                },
                footerFormat: "",
                headerShape: "callout",
                hideDelay: 500,
                padding: 8,
                shape: "callout",
                shared: !1,
                snap: Y ? 25 : 10,
                headerFormat:
                  '<span style="font-size: 0.8em">{point.key}</span><br/>',
                pointFormat:
                  '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: "#ffffff",
                borderWidth: void 0,
                shadow: !0,
                stickOnContact: !1,
                style: {
                  color: "#333333",
                  cursor: "default",
                  fontSize: "0.8em",
                },
                useHTML: !1,
              },
              credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                  align: "right",
                  x: -10,
                  verticalAlign: "bottom",
                  y: -5,
                },
                style: {
                  cursor: "pointer",
                  color: "#999999",
                  fontSize: "0.6em",
                },
                text: "Highcharts.com",
              },
            };
          z.chart.styledMode = !1;
          const S = new B(z.time);
          return (
            (a = {
              defaultOptions: z,
              defaultTime: S,
              getOptions: function () {
                return z;
              },
              setOptions: function (x) {
                return (
                  E(!0, z, x),
                  (x.time || x.global) &&
                    (M.time
                      ? M.time.update(E(z.global, z.time, x.global, x.time))
                      : (M.time = S)),
                  z
                );
              },
            }),
            a
          );
        }
      ),
      n(
        i,
        "Core/Animation/Fx.js",
        [
          i["Core/Color/Color.js"],
          i["Core/Globals.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { parse: O } = a,
            { win: B } = d,
            { isNumber: G, objectEach: Y } = M;
          class L {
            constructor(z, S, x) {
              (this.pos = NaN),
                (this.options = S),
                (this.elem = z),
                (this.prop = x);
            }
            dSetter() {
              var z = this.paths;
              const S = z && z[0];
              z = z && z[1];
              const x = this.now || 0;
              let P = [];
              if (x !== 1 && S && z)
                if (S.length === z.length && 1 > x)
                  for (let h = 0; h < z.length; h++) {
                    const s = S[h],
                      l = z[h],
                      p = [];
                    for (let g = 0; g < l.length; g++) {
                      const T = s[g],
                        D = l[g];
                      G(T) && G(D) && (l[0] !== "A" || (g !== 4 && g !== 5))
                        ? (p[g] = T + x * (D - T))
                        : (p[g] = D);
                    }
                    P.push(p);
                  }
                else P = z;
              else P = this.toD || [];
              this.elem.attr("d", P, void 0, !0);
            }
            update() {
              const z = this.elem,
                S = this.prop,
                x = this.now,
                P = this.options.step;
              this[S + "Setter"]
                ? this[S + "Setter"]()
                : z.attr
                ? z.element && z.attr(S, x, null, !0)
                : (z.style[S] = x + this.unit),
                P && P.call(z, x, this);
            }
            run(z, S, x) {
              const P = this,
                h = P.options,
                s = function (g) {
                  return s.stopped ? !1 : P.step(g);
                },
                l =
                  B.requestAnimationFrame ||
                  function (g) {
                    setTimeout(g, 13);
                  },
                p = function () {
                  for (let g = 0; g < L.timers.length; g++)
                    L.timers[g]() || L.timers.splice(g--, 1);
                  L.timers.length && l(p);
                };
              z !== S || this.elem["forceAnimate:" + this.prop]
                ? ((this.startTime = +new Date()),
                  (this.start = z),
                  (this.end = S),
                  (this.unit = x),
                  (this.now = this.start),
                  (this.pos = 0),
                  (s.elem = this.elem),
                  (s.prop = this.prop),
                  s() && L.timers.push(s) === 1 && l(p))
                : (delete h.curAnim[this.prop],
                  h.complete &&
                    Object.keys(h.curAnim).length === 0 &&
                    h.complete.call(this.elem));
            }
            step(z) {
              const S = +new Date(),
                x = this.options,
                P = this.elem,
                h = x.complete,
                s = x.duration,
                l = x.curAnim;
              let p;
              return (
                P.attr && !P.element
                  ? (z = !1)
                  : z || S >= s + this.startTime
                  ? ((this.now = this.end),
                    (this.pos = 1),
                    this.update(),
                    (p = l[this.prop] = !0),
                    Y(l, function (g) {
                      g !== !0 && (p = !1);
                    }),
                    p && h && h.call(P),
                    (z = !1))
                  : ((this.pos = x.easing((S - this.startTime) / s)),
                    (this.now =
                      this.start + (this.end - this.start) * this.pos),
                    this.update(),
                    (z = !0)),
                z
              );
            }
            initPath(z, S, x) {
              function P(m, f) {
                for (; m.length < D; ) {
                  var b = m[0];
                  const y = f[D - m.length];
                  y &&
                    b[0] === "M" &&
                    (m[0] =
                      y[0] === "C"
                        ? ["C", b[1], b[2], b[1], b[2], b[1], b[2]]
                        : ["L", b[1], b[2]]),
                    m.unshift(b),
                    p && ((b = m.pop()), m.push(m[m.length - 1], b));
                }
              }
              function h(m, f) {
                for (; m.length < D; )
                  if (
                    ((f = m[Math.floor(m.length / g) - 1].slice()),
                    f[0] === "C" && ((f[1] = f[5]), (f[2] = f[6])),
                    p)
                  ) {
                    const b = m[Math.floor(m.length / g)].slice();
                    m.splice(m.length / 2, 0, f, b);
                  } else m.push(f);
              }
              const s = z.startX,
                l = z.endX;
              x = x.slice();
              const p = z.isArea,
                g = p ? 2 : 1;
              let T, D, A;
              if (((S = S && S.slice()), !S)) return [x, x];
              if (s && l && l.length) {
                for (z = 0; z < s.length; z++)
                  if (s[z] === l[0]) {
                    T = z;
                    break;
                  } else if (s[0] === l[l.length - s.length + z]) {
                    (T = z), (A = !0);
                    break;
                  } else if (s[s.length - 1] === l[l.length - s.length + z]) {
                    T = s.length - z;
                    break;
                  }
                typeof T > "u" && (S = []);
              }
              return (
                S.length &&
                  G(T) &&
                  ((D = x.length + T * g),
                  A ? (P(S, x), h(x, S)) : (P(x, S), h(S, x))),
                [S, x]
              );
            }
            fillSetter() {
              L.prototype.strokeSetter.apply(this, arguments);
            }
            strokeSetter() {
              this.elem.attr(
                this.prop,
                O(this.start).tweenTo(O(this.end), this.pos),
                void 0,
                !0
              );
            }
          }
          return (L.timers = []), L;
        }
      ),
      n(
        i,
        "Core/Animation/AnimationUtilities.js",
        [i["Core/Animation/Fx.js"], i["Core/Utilities.js"]],
        function (a, d) {
          function M(P) {
            return E(P)
              ? z({ duration: 500, defer: 0 }, P)
              : { duration: P ? 500 : 0, defer: 0 };
          }
          function O(P, h) {
            let s = a.timers.length;
            for (; s--; )
              a.timers[s].elem !== P ||
                (h && h !== a.timers[s].prop) ||
                (a.timers[s].stopped = !0);
          }
          const {
            defined: B,
            getStyle: G,
            isArray: Y,
            isNumber: L,
            isObject: E,
            merge: z,
            objectEach: S,
            pick: x,
          } = d;
          return {
            animate: function (P, h, s) {
              let l,
                p = "",
                g,
                T,
                D;
              E(s) ||
                ((D = arguments),
                (s = { duration: D[2], easing: D[3], complete: D[4] })),
                L(s.duration) || (s.duration = 400),
                (s.easing =
                  typeof s.easing == "function"
                    ? s.easing
                    : Math[s.easing] || Math.easeInOutSine),
                (s.curAnim = z(h)),
                S(h, function (A, m) {
                  O(P, m),
                    (T = new a(P, s, m)),
                    (g = void 0),
                    m === "d" && Y(h.d)
                      ? ((T.paths = T.initPath(P, P.pathArray, h.d)),
                        (T.toD = h.d),
                        (l = 0),
                        (g = 1))
                      : P.attr
                      ? (l = P.attr(m))
                      : ((l = parseFloat(G(P, m)) || 0),
                        m !== "opacity" && (p = "px")),
                    g || (g = A),
                    typeof g == "string" &&
                      g.match("px") &&
                      (g = g.replace(/px/g, "")),
                    T.run(l, g, p);
                });
            },
            animObject: M,
            getDeferredAnimation: function (P, h, s) {
              const l = M(h);
              let p = 0,
                g = 0;
              return (
                (s ? [s] : P.series).forEach((T) => {
                  (T = M(T.options.animation)),
                    (p =
                      h && B(h.defer)
                        ? l.defer
                        : Math.max(p, T.duration + T.defer)),
                    (g = Math.min(l.duration, T.duration));
                }),
                P.renderer.forExport && (p = 0),
                { defer: Math.max(0, p - g), duration: Math.min(p, g) }
              );
            },
            setAnimation: function (P, h) {
              h.renderer.globalAnimation = x(P, h.options.chart.animation, !0);
            },
            stop: O,
          };
        }
      ),
      n(
        i,
        "Core/Renderer/HTML/AST.js",
        [i["Core/Globals.js"], i["Core/Utilities.js"]],
        function (a, d) {
          const { SVG_NS: M, win: O } = a,
            {
              attr: B,
              createElement: G,
              css: Y,
              error: L,
              isFunction: E,
              isString: z,
              objectEach: S,
              splat: x,
            } = d;
          ({ trustedTypes: d } = O);
          const P =
            d &&
            E(d.createPolicy) &&
            d.createPolicy("highcharts", { createHTML: (p) => p });
          d = P ? P.createHTML("") : "";
          try {
            var h = !!new DOMParser().parseFromString(d, "text/html");
          } catch {
            h = !1;
          }
          const s = h;
          class l {
            static filterUserAttributes(g) {
              return (
                S(g, (T, D) => {
                  let A = !0;
                  l.allowedAttributes.indexOf(D) === -1 && (A = !1),
                    ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(
                      D
                    ) !== -1 &&
                      (A =
                        z(T) &&
                        l.allowedReferences.some((m) => T.indexOf(m) === 0)),
                    A ||
                      (L(33, !1, void 0, {
                        "Invalid attribute in config": `${D}`,
                      }),
                      delete g[D]),
                    z(T) && g[D] && (g[D] = T.replace(/</g, "&lt;"));
                }),
                g
              );
            }
            static parseStyle(g) {
              return g.split(";").reduce((T, D) => {
                D = D.split(":").map((m) => m.trim());
                const A = D.shift();
                return (
                  A &&
                    D.length &&
                    (T[A.replace(/-([a-z])/g, (m) => m[1].toUpperCase())] =
                      D.join(":")),
                  T
                );
              }, {});
            }
            static setElementHTML(g, T) {
              (g.innerHTML = l.emptyHTML), T && new l(T).addToDOM(g);
            }
            constructor(g) {
              this.nodes = typeof g == "string" ? this.parseMarkup(g) : g;
            }
            addToDOM(g) {
              function T(D, A) {
                let m;
                return (
                  x(D).forEach(function (f) {
                    var b = f.tagName;
                    const y = f.textContent
                        ? a.doc.createTextNode(f.textContent)
                        : void 0,
                      C = l.bypassHTMLFiltering;
                    let o;
                    if (b)
                      if (b === "#text") o = y;
                      else if (l.allowedTags.indexOf(b) !== -1 || C) {
                        b = a.doc.createElementNS(
                          b === "svg" ? M : A.namespaceURI || M,
                          b
                        );
                        const r = f.attributes || {};
                        S(f, function (c, u) {
                          u !== "tagName" &&
                            u !== "attributes" &&
                            u !== "children" &&
                            u !== "style" &&
                            u !== "textContent" &&
                            (r[u] = c);
                        }),
                          B(b, C ? r : l.filterUserAttributes(r)),
                          f.style && Y(b, f.style),
                          y && b.appendChild(y),
                          T(f.children || [], b),
                          (o = b);
                      } else
                        L(33, !1, void 0, { "Invalid tagName in config": b });
                    o && A.appendChild(o), (m = o);
                  }),
                  m
                );
              }
              return T(this.nodes, g);
            }
            parseMarkup(g) {
              const T = [];
              if (
                ((g = g.trim().replace(/ style=(["'])/g, " data-style=$1")), s)
              )
                g = new DOMParser().parseFromString(
                  P ? P.createHTML(g) : g,
                  "text/html"
                );
              else {
                const A = G("div");
                (A.innerHTML = g), (g = { body: A });
              }
              const D = (A, m) => {
                var f = A.nodeName.toLowerCase();
                const b = { tagName: f };
                if (
                  (f === "#text" && (b.textContent = A.textContent || ""),
                  (f = A.attributes))
                ) {
                  const y = {};
                  [].forEach.call(f, (C) => {
                    C.name === "data-style"
                      ? (b.style = l.parseStyle(C.value))
                      : (y[C.name] = C.value);
                  }),
                    (b.attributes = y);
                }
                if (A.childNodes.length) {
                  const y = [];
                  [].forEach.call(A.childNodes, (C) => {
                    D(C, y);
                  }),
                    y.length && (b.children = y);
                }
                m.push(b);
              };
              return [].forEach.call(g.body.childNodes, (A) => D(A, T)), T;
            }
          }
          return (
            (l.allowedAttributes =
              "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(
                " "
              )),
            (l.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(
              " "
            )),
            (l.allowedTags =
              "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(
                " "
              )),
            (l.emptyHTML = d),
            (l.bypassHTMLFiltering = !1),
            l
          );
        }
      ),
      n(
        i,
        "Core/Templating.js",
        [i["Core/Defaults.js"], i["Core/Utilities.js"]],
        function (a, d) {
          function M(s = "", l, p) {
            const g = /\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g,
              T = /\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g,
              D = [],
              A = /f$/,
              m = /\.([0-9])/,
              f = B.lang,
              b = (p && p.time) || G,
              y = (p && p.numberFormatter) || O,
              C = (w = "") => {
                let R;
                return w === "true"
                  ? !0
                  : w === "false"
                  ? !1
                  : (R = Number(w)).toString() === w
                  ? R
                  : L(w, l);
              };
            let o,
              r,
              c = 0,
              u;
            for (; (o = g.exec(s)) !== null; ) {
              const w = T.exec(o[1]);
              w && ((o = w), (u = !0)),
                (r && r.isBlock) ||
                  (r = {
                    ctx: l,
                    expression: o[1],
                    find: o[0],
                    isBlock: o[1].charAt(0) === "#",
                    start: o.index,
                    startInner: o.index + o[0].length,
                    length: o[0].length,
                  });
              var v = o[1].split(" ")[0].replace("#", "");
              if (
                (h[v] && (r.isBlock && v === r.fn && c++, r.fn || (r.fn = v)),
                (v = o[1] === "else"),
                r.isBlock && r.fn && (o[1] === `/${r.fn}` || v))
              )
                if (c) v || c--;
                else {
                  var N = r.startInner;
                  (N = s.substr(N, o.index - N)),
                    r.body === void 0
                      ? ((r.body = N), (r.startInner = o.index + o[0].length))
                      : (r.elseBody = N),
                    (r.find += N + o[0]),
                    v || (D.push(r), (r = void 0));
                }
              else r.isBlock || D.push(r);
              if (w && (r == null || !r.isBlock)) break;
            }
            return (
              D.forEach((w) => {
                const { body: R, elseBody: X, expression: J, fn: K } = w;
                var H;
                if (K) {
                  var k = [w],
                    U = J.split(" ");
                  for (H = h[K].length; H--; ) k.unshift(C(U[H + 1]));
                  (H = h[K].apply(l, k)),
                    w.isBlock && typeof H == "boolean" && (H = M(H ? R : X, l));
                } else
                  (k = J.split(":")),
                    (H = C(k.shift() || "")),
                    k.length &&
                      typeof H == "number" &&
                      ((k = k.join(":")),
                      A.test(k)
                        ? ((U = parseInt((k.match(m) || ["", "-1"])[1], 10)),
                          H !== null &&
                            (H = y(
                              H,
                              U,
                              f.decimalPoint,
                              -1 < k.indexOf(",") ? f.thousandsSep : ""
                            )))
                        : (H = b.dateFormat(k, H)));
                s = s.replace(w.find, x(H, ""));
              }),
              u ? M(s, l, p) : s
            );
          }
          function O(s, l, p, g) {
            (s = +s || 0), (l = +l);
            const T = B.lang;
            var D = (s.toString().split(".")[1] || "").split("e")[0].length;
            const A = s.toString().split("e"),
              m = l;
            if (l === -1) l = Math.min(D, 20);
            else if (!z(l)) l = 2;
            else if (l && A[1] && 0 > A[1]) {
              var f = l + +A[1];
              0 <= f
                ? ((A[0] = (+A[0]).toExponential(f).split("e")[0]), (l = f))
                : ((A[0] = A[0].split(".")[0] || 0),
                  (s = 20 > l ? (A[0] * Math.pow(10, A[1])).toFixed(l) : 0),
                  (A[1] = 0));
            }
            (f = (
              Math.abs(A[1] ? A[0] : s) + Math.pow(10, -Math.max(l, D) - 1)
            ).toFixed(l)),
              (D = String(P(f)));
            const b = 3 < D.length ? D.length % 3 : 0;
            return (
              (p = x(p, T.decimalPoint)),
              (g = x(g, T.thousandsSep)),
              (s = (0 > s ? "-" : "") + (b ? D.substr(0, b) + g : "")),
              (s =
                0 > +A[1] && !m
                  ? "0"
                  : s + D.substr(b).replace(/(\d{3})(?=\d)/g, "$1" + g)),
              l && (s += p + f.slice(-l)),
              A[1] && +s != 0 && (s += "e" + A[1]),
              s
            );
          }
          const { defaultOptions: B, defaultTime: G } = a,
            {
              extend: Y,
              getNestedProperty: L,
              isArray: E,
              isNumber: z,
              isObject: S,
              pick: x,
              pInt: P,
            } = d,
            h = {
              add: (s, l) => s + l,
              divide: (s, l) => (l !== 0 ? s / l : ""),
              eq: (s, l) => s == l,
              each: function (s) {
                const l = arguments[arguments.length - 1];
                return E(s)
                  ? s
                      .map((p, g) =>
                        M(
                          l.body,
                          Y(S(p) ? p : { "@this": p }, {
                            "@index": g,
                            "@first": g === 0,
                            "@last": g === s.length - 1,
                          })
                        )
                      )
                      .join("")
                  : !1;
              },
              ge: (s, l) => s >= l,
              gt: (s, l) => s > l,
              if: (s) => !!s,
              le: (s, l) => s <= l,
              lt: (s, l) => s < l,
              multiply: (s, l) => s * l,
              ne: (s, l) => s != l,
              subtract: (s, l) => s - l,
              unless: (s) => !s,
            };
          return {
            dateFormat: function (s, l, p) {
              return G.dateFormat(s, l, p);
            },
            format: M,
            helpers: h,
            numberFormat: O,
          };
        }
      ),
      n(
        i,
        "Core/Renderer/RendererUtilities.js",
        [i["Core/Utilities.js"]],
        function (a) {
          const { clamp: d, pick: M, stableSort: O } = a;
          var B;
          return (
            (function (G) {
              function Y(L, E, z) {
                const S = L;
                var x = S.reducedLen || E,
                  P = (T, D) => (D.rank || 0) - (T.rank || 0);
                const h = (T, D) => T.target - D.target;
                let s,
                  l = !0,
                  p = [],
                  g = 0;
                for (s = L.length; s--; ) g += L[s].size;
                if (g > x) {
                  for (O(L, P), g = s = 0; g <= x; ) (g += L[s].size), s++;
                  p = L.splice(s - 1, L.length);
                }
                for (
                  O(L, h),
                    L = L.map((T) => ({
                      size: T.size,
                      targets: [T.target],
                      align: M(T.align, 0.5),
                    }));
                  l;

                ) {
                  for (s = L.length; s--; )
                    (x = L[s]),
                      (P =
                        (Math.min.apply(0, x.targets) +
                          Math.max.apply(0, x.targets)) /
                        2),
                      (x.pos = d(P - x.size * x.align, 0, E - x.size));
                  for (s = L.length, l = !1; s--; )
                    0 < s &&
                      L[s - 1].pos + L[s - 1].size > L[s].pos &&
                      ((L[s - 1].size += L[s].size),
                      (L[s - 1].targets = L[s - 1].targets.concat(
                        L[s].targets
                      )),
                      (L[s - 1].align = 0.5),
                      L[s - 1].pos + L[s - 1].size > E &&
                        (L[s - 1].pos = E - L[s - 1].size),
                      L.splice(s, 1),
                      (l = !0));
                }
                return (
                  S.push.apply(S, p),
                  (s = 0),
                  L.some((T) => {
                    let D = 0;
                    return (T.targets || []).some(
                      () => (
                        (S[s].pos = T.pos + D),
                        typeof z < "u" && Math.abs(S[s].pos - S[s].target) > z
                          ? (S.slice(0, s + 1).forEach((A) => delete A.pos),
                            (S.reducedLen = (S.reducedLen || E) - 0.1 * E),
                            S.reducedLen > 0.1 * E && Y(S, E, z),
                            !0)
                          : ((D += S[s].size), s++, !1)
                      )
                    );
                  }),
                  O(S, h),
                  S
                );
              }
              G.distribute = Y;
            })(B || (B = {})),
            B
          );
        }
      ),
      n(
        i,
        "Core/Renderer/SVG/SVGElement.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Color/Color.js"],
          i["Core/Globals.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O) {
          const { animate: B, animObject: G, stop: Y } = a,
            { deg2rad: L, doc: E, svg: z, SVG_NS: S, win: x } = M,
            {
              addEvent: P,
              attr: h,
              createElement: s,
              css: l,
              defined: p,
              erase: g,
              extend: T,
              fireEvent: D,
              isArray: A,
              isFunction: m,
              isObject: f,
              isString: b,
              merge: y,
              objectEach: C,
              pick: o,
              pInt: r,
              syncTimeout: c,
              uniqueKey: u,
            } = O;
          class v {
            constructor() {
              (this.element = void 0),
                (this.onEvents = {}),
                (this.opacity = 1),
                (this.renderer = void 0),
                (this.SVG_NS = S);
            }
            _defaultGetter(w) {
              return (
                (w = o(
                  this[w + "Value"],
                  this[w],
                  this.element ? this.element.getAttribute(w) : null,
                  0
                )),
                /^[\-0-9\.]+$/.test(w) && (w = parseFloat(w)),
                w
              );
            }
            _defaultSetter(w, R, X) {
              X.setAttribute(R, w);
            }
            add(w) {
              const R = this.renderer,
                X = this.element;
              let J;
              return (
                w && (this.parentGroup = w),
                typeof this.textStr < "u" &&
                  this.element.nodeName === "text" &&
                  R.buildText(this),
                (this.added = !0),
                (!w || w.handleZ || this.zIndex) && (J = this.zIndexSetter()),
                J || (w ? w.element : R.box).appendChild(X),
                this.onAdd && this.onAdd(),
                this
              );
            }
            addClass(w, R) {
              const X = R ? "" : this.attr("class") || "";
              return (
                (w = (w || "")
                  .split(/ /g)
                  .reduce(
                    function (J, K) {
                      return X.indexOf(K) === -1 && J.push(K), J;
                    },
                    X ? [X] : []
                  )
                  .join(" ")),
                w !== X && this.attr("class", w),
                this
              );
            }
            afterSetters() {
              this.doTransform &&
                (this.updateTransform(), (this.doTransform = !1));
            }
            align(w, R, X) {
              const J = {};
              var K = this.renderer,
                H = K.alignedObjects,
                k;
              let U, _;
              w
                ? ((this.alignOptions = w),
                  (this.alignByTranslate = R),
                  (!X || b(X)) &&
                    ((this.alignTo = k = X || "renderer"),
                    g(H, this),
                    H.push(this),
                    (X = void 0)))
                : ((w = this.alignOptions),
                  (R = this.alignByTranslate),
                  (k = this.alignTo)),
                (X = o(
                  X,
                  K[k],
                  k === "scrollablePlotBox" ? K.plotBox : void 0,
                  K
                )),
                (k = w.align);
              const W = w.verticalAlign;
              return (
                (K = (X.x || 0) + (w.x || 0)),
                (H = (X.y || 0) + (w.y || 0)),
                k === "right" ? (U = 1) : k === "center" && (U = 2),
                U && (K += (X.width - (w.width || 0)) / U),
                (J[R ? "translateX" : "x"] = Math.round(K)),
                W === "bottom" ? (_ = 1) : W === "middle" && (_ = 2),
                _ && (H += (X.height - (w.height || 0)) / _),
                (J[R ? "translateY" : "y"] = Math.round(H)),
                this[this.placed ? "animate" : "attr"](J),
                (this.placed = !0),
                (this.alignAttr = J),
                this
              );
            }
            alignSetter(w) {
              const R = { left: "start", center: "middle", right: "end" };
              R[w] &&
                ((this.alignValue = w),
                this.element.setAttribute("text-anchor", R[w]));
            }
            animate(w, R, X) {
              const J = G(o(R, this.renderer.globalAnimation, !0));
              return (
                (R = J.defer),
                E.hidden && (J.duration = 0),
                J.duration !== 0
                  ? (X && (J.complete = X),
                    c(() => {
                      this.element && B(this, w, J);
                    }, R))
                  : (this.attr(w, void 0, X || J.complete),
                    C(
                      w,
                      function (K, H) {
                        J.step &&
                          J.step.call(this, K, { prop: H, pos: 1, elem: this });
                      },
                      this
                    )),
                this
              );
            }
            applyTextOutline(w) {
              const R = this.element;
              w.indexOf("contrast") !== -1 &&
                (w = w.replace(
                  /contrast/g,
                  this.renderer.getContrast(R.style.fill)
                ));
              var X = w.split(" ");
              if (
                ((w = X[X.length - 1]), (X = X[0]) && X !== "none" && M.svg)
              ) {
                (this.fakeTS = !0),
                  (X = X.replace(/(^[\d\.]+)(.*?)$/g, function (H, k, U) {
                    return 2 * Number(k) + U;
                  })),
                  this.removeTextOutline();
                const J = E.createElementNS(S, "tspan");
                h(J, {
                  class: "highcharts-text-outline",
                  fill: w,
                  stroke: w,
                  "stroke-width": X,
                  "stroke-linejoin": "round",
                }),
                  (w = R.querySelector("textPath") || R),
                  [].forEach.call(w.childNodes, (H) => {
                    const k = H.cloneNode(!0);
                    k.removeAttribute &&
                      ["fill", "stroke", "stroke-width", "stroke"].forEach(
                        (U) => k.removeAttribute(U)
                      ),
                      J.appendChild(k);
                  });
                let K = 0;
                [].forEach.call(w.querySelectorAll("text tspan"), (H) => {
                  K += Number(H.getAttribute("dy"));
                }),
                  (X = E.createElementNS(S, "tspan")),
                  (X.textContent = ""),
                  h(X, { x: Number(R.getAttribute("x")), dy: -K }),
                  J.appendChild(X),
                  w.insertBefore(J, w.firstChild);
              }
            }
            attr(w, R, X, J) {
              const K = this.element,
                H = v.symbolCustomAttribs;
              let k,
                U,
                _ = this,
                W,
                tt;
              return (
                typeof w == "string" &&
                  typeof R < "u" &&
                  ((k = w), (w = {}), (w[k] = R)),
                typeof w == "string"
                  ? (_ = (this[w + "Getter"] || this._defaultGetter).call(
                      this,
                      w,
                      K
                    ))
                  : (C(
                      w,
                      function (j, I) {
                        (W = !1),
                          J || Y(this, I),
                          this.symbolName &&
                            H.indexOf(I) !== -1 &&
                            (U || (this.symbolAttr(w), (U = !0)), (W = !0)),
                          !this.rotation ||
                            (I !== "x" && I !== "y") ||
                            (this.doTransform = !0),
                          W ||
                            ((tt = this[I + "Setter"] || this._defaultSetter),
                            tt.call(this, j, I, K));
                      },
                      this
                    ),
                    this.afterSetters()),
                X && X.call(this),
                _
              );
            }
            clip(w) {
              return this.attr(
                "clip-path",
                w ? "url(" + this.renderer.url + "#" + w.id + ")" : "none"
              );
            }
            crisp(w, R) {
              R = R || w.strokeWidth || 0;
              const X = (Math.round(R) % 2) / 2;
              return (
                (w.x = Math.floor(w.x || this.x || 0) + X),
                (w.y = Math.floor(w.y || this.y || 0) + X),
                (w.width = Math.floor((w.width || this.width || 0) - 2 * X)),
                (w.height = Math.floor((w.height || this.height || 0) - 2 * X)),
                p(w.strokeWidth) && (w.strokeWidth = R),
                w
              );
            }
            complexColor(w, R, X) {
              const J = this.renderer;
              let K,
                H,
                k,
                U,
                _,
                W,
                tt,
                j,
                I,
                F,
                V = [],
                Q;
              D(
                this.renderer,
                "complexColor",
                { args: arguments },
                function () {
                  if (
                    (w.radialGradient
                      ? (H = "radialGradient")
                      : w.linearGradient && (H = "linearGradient"),
                    H)
                  ) {
                    if (
                      ((k = w[H]),
                      (_ = J.gradients),
                      (W = w.stops),
                      (I = X.radialReference),
                      A(k) &&
                        (w[H] = k =
                          {
                            x1: k[0],
                            y1: k[1],
                            x2: k[2],
                            y2: k[3],
                            gradientUnits: "userSpaceOnUse",
                          }),
                      H === "radialGradient" &&
                        I &&
                        !p(k.gradientUnits) &&
                        ((U = k),
                        (k = y(k, J.getRadialAttr(I, U), {
                          gradientUnits: "userSpaceOnUse",
                        }))),
                      C(k, function ($, et) {
                        et !== "id" && V.push(et, $);
                      }),
                      C(W, function ($) {
                        V.push($);
                      }),
                      (V = V.join(",")),
                      _[V])
                    )
                      F = _[V].attr("id");
                    else {
                      k.id = F = u();
                      const $ = (_[V] = J.createElement(H).attr(k).add(J.defs));
                      ($.radAttr = U),
                        ($.stops = []),
                        W.forEach(function (et) {
                          et[1].indexOf("rgba") === 0
                            ? ((K = d.parse(et[1])),
                              (tt = K.get("rgb")),
                              (j = K.get("a")))
                            : ((tt = et[1]), (j = 1)),
                            (et = J.createElement("stop")
                              .attr({
                                offset: et[0],
                                "stop-color": tt,
                                "stop-opacity": j,
                              })
                              .add($)),
                            $.stops.push(et);
                        });
                    }
                    (Q = "url(" + J.url + "#" + F + ")"),
                      X.setAttribute(R, Q),
                      (X.gradient = V),
                      (w.toString = function () {
                        return Q;
                      });
                  }
                }
              );
            }
            css(w) {
              const R = this.styles,
                X = {},
                J = this.element;
              let K,
                H = !R;
              if (
                (R &&
                  C(w, function (k, U) {
                    R && R[U] !== k && ((X[U] = k), (H = !0));
                  }),
                H)
              ) {
                R && (w = T(R, X)),
                  w.width === null || w.width === "auto"
                    ? delete this.textWidth
                    : J.nodeName.toLowerCase() === "text" &&
                      w.width &&
                      (K = this.textWidth = r(w.width)),
                  (this.styles = w),
                  K && !z && this.renderer.forExport && delete w.width;
                const k = y(w);
                J.namespaceURI === this.SVG_NS &&
                  (["textOutline", "textOverflow", "width"].forEach(
                    (U) => k && delete k[U]
                  ),
                  k.color && (k.fill = k.color)),
                  l(J, k);
              }
              return (
                this.added &&
                  (this.element.nodeName === "text" &&
                    this.renderer.buildText(this),
                  w.textOutline && this.applyTextOutline(w.textOutline)),
                this
              );
            }
            dashstyleSetter(w) {
              let R = this["stroke-width"];
              if ((R === "inherit" && (R = 1), (w = w && w.toLowerCase()))) {
                const X = w
                  .replace("shortdashdotdot", "3,1,1,1,1,1,")
                  .replace("shortdashdot", "3,1,1,1")
                  .replace("shortdot", "1,1,")
                  .replace("shortdash", "3,1,")
                  .replace("longdash", "8,3,")
                  .replace(/dot/g, "1,3,")
                  .replace("dash", "4,3,")
                  .replace(/,$/, "")
                  .split(",");
                for (w = X.length; w--; ) X[w] = "" + r(X[w]) * o(R, NaN);
                (w = X.join(",").replace(/NaN/g, "none")),
                  this.element.setAttribute("stroke-dasharray", w);
              }
            }
            destroy() {
              const w = this;
              var R = w.element || {};
              const X = w.renderer;
              var J = R.ownerSVGElement;
              let K = (R.nodeName === "SPAN" && w.parentGroup) || void 0;
              if (
                ((R.onclick =
                  R.onmouseout =
                  R.onmouseover =
                  R.onmousemove =
                  R.point =
                    null),
                Y(w),
                w.clipPath && J)
              ) {
                const H = w.clipPath;
                [].forEach.call(
                  J.querySelectorAll("[clip-path],[CLIP-PATH]"),
                  function (k) {
                    -1 < k.getAttribute("clip-path").indexOf(H.element.id) &&
                      k.removeAttribute("clip-path");
                  }
                ),
                  (w.clipPath = H.destroy());
              }
              if (w.stops) {
                for (J = 0; J < w.stops.length; J++) w.stops[J].destroy();
                (w.stops.length = 0), (w.stops = void 0);
              }
              for (
                w.safeRemoveChild(R);
                K && K.div && K.div.childNodes.length === 0;

              )
                (R = K.parentGroup),
                  w.safeRemoveChild(K.div),
                  delete K.div,
                  (K = R);
              w.alignTo && g(X.alignedObjects, w),
                C(w, function (H, k) {
                  w[k] &&
                    w[k].parentGroup === w &&
                    w[k].destroy &&
                    w[k].destroy(),
                    delete w[k];
                });
            }
            dSetter(w, R, X) {
              A(w) &&
                (typeof w[0] == "string" &&
                  (w = this.renderer.pathToSegments(w)),
                (this.pathArray = w),
                (w = w.reduce(
                  (J, K, H) =>
                    K && K.join
                      ? (H ? J + " " : "") + K.join(" ")
                      : (K || "").toString(),
                  ""
                ))),
                /(NaN| {2}|^$)/.test(w) && (w = "M 0 0"),
                this[R] !== w && (X.setAttribute(R, w), (this[R] = w));
            }
            fadeOut(w) {
              const R = this;
              R.animate(
                { opacity: 0 },
                {
                  duration: o(w, 150),
                  complete: function () {
                    R.hide();
                  },
                }
              );
            }
            fillSetter(w, R, X) {
              typeof w == "string"
                ? X.setAttribute(R, w)
                : w && this.complexColor(w, R, X);
            }
            getBBox(w, R) {
              const {
                  alignValue: X,
                  element: J,
                  renderer: K,
                  styles: H,
                  textStr: k,
                } = this,
                { cache: U, cacheKeys: _ } = K;
              var W = J.namespaceURI === this.SVG_NS;
              R = o(R, this.rotation, 0);
              var tt = K.styledMode
                ? J && v.prototype.getStyle.call(J, "font-size")
                : H && H.fontSize;
              let j, I;
              if (
                (p(k) &&
                  ((I = k.toString()),
                  I.indexOf("<") === -1 && (I = I.replace(/[0-9]/g, "0")),
                  (I += [
                    "",
                    K.rootFontSize,
                    tt,
                    R,
                    this.textWidth,
                    X,
                    H && H.textOverflow,
                    H && H.fontWeight,
                  ].join())),
                I && !w && (j = U[I]),
                !j)
              ) {
                if (W || K.forExport) {
                  try {
                    var F =
                      this.fakeTS &&
                      function (st) {
                        const ot = J.querySelector(".highcharts-text-outline");
                        ot && l(ot, { display: st });
                      };
                    m(F) && F("none"),
                      (j = J.getBBox
                        ? T({}, J.getBBox())
                        : {
                            width: J.offsetWidth,
                            height: J.offsetHeight,
                            x: 0,
                            y: 0,
                          }),
                      m(F) && F("");
                  } catch {}
                  (!j || 0 > j.width) &&
                    (j = { x: 0, y: 0, width: 0, height: 0 });
                } else j = this.htmlGetBBox();
                if (
                  ((F = j.width),
                  (w = j.height),
                  W &&
                    (j.height = w =
                      { "11px,17": 14, "13px,20": 16 }[
                        `${tt || ""},${Math.round(w)}`
                      ] || w),
                  R)
                ) {
                  (W = Number(J.getAttribute("y") || 0) - j.y),
                    (tt = { right: 1, center: 0.5 }[X || 0] || 0);
                  var V = R * L,
                    Q = (R - 90) * L,
                    $ = F * Math.cos(V);
                  R = F * Math.sin(V);
                  var et = Math.cos(Q);
                  (V = Math.sin(Q)),
                    (F = j.x + tt * (F - $) + W * et),
                    (Q = F + $),
                    (et = Q - w * et),
                    ($ = et - $),
                    (W = j.y + W - tt * R + W * V),
                    (tt = W + R),
                    (w = tt - w * V),
                    (R = w - R),
                    (j.x = Math.min(F, Q, et, $)),
                    (j.y = Math.min(W, tt, w, R)),
                    (j.width = Math.max(F, Q, et, $) - j.x),
                    (j.height = Math.max(W, tt, w, R) - j.y);
                }
              }
              if (I && (k === "" || 0 < j.height)) {
                for (; 250 < _.length; ) delete U[_.shift()];
                U[I] || _.push(I), (U[I] = j);
              }
              return j;
            }
            getStyle(w) {
              return x
                .getComputedStyle(this.element || this, "")
                .getPropertyValue(w);
            }
            hasClass(w) {
              return ("" + this.attr("class")).split(" ").indexOf(w) !== -1;
            }
            hide() {
              return this.attr({ visibility: "hidden" });
            }
            htmlGetBBox() {
              return { height: 0, width: 0, x: 0, y: 0 };
            }
            init(w, R) {
              (this.element =
                R === "span" ? s(R) : E.createElementNS(this.SVG_NS, R)),
                (this.renderer = w),
                D(this, "afterInit");
            }
            on(w, R) {
              const { onEvents: X } = this;
              return X[w] && X[w](), (X[w] = P(this.element, w, R)), this;
            }
            opacitySetter(w, R, X) {
              (this.opacity = w = Number(Number(w).toFixed(3))),
                X.setAttribute(R, w);
            }
            removeClass(w) {
              return this.attr(
                "class",
                ("" + this.attr("class"))
                  .replace(b(w) ? new RegExp(`(^| )${w}( |$)`) : w, " ")
                  .replace(/ +/g, " ")
                  .trim()
              );
            }
            removeTextOutline() {
              const w = this.element.querySelector(
                "tspan.highcharts-text-outline"
              );
              w && this.safeRemoveChild(w);
            }
            safeRemoveChild(w) {
              const R = w.parentNode;
              R && R.removeChild(w);
            }
            setRadialReference(w) {
              const R =
                this.element.gradient &&
                this.renderer.gradients[this.element.gradient];
              return (
                (this.element.radialReference = w),
                R &&
                  R.radAttr &&
                  R.animate(this.renderer.getRadialAttr(w, R.radAttr)),
                this
              );
            }
            setTextPath(w, R) {
              R = y(
                !0,
                {
                  enabled: !0,
                  attributes: {
                    dy: -5,
                    startOffset: "50%",
                    textAnchor: "middle",
                  },
                },
                R
              );
              const X = this.renderer.url,
                J = this.text || this,
                K = J.textPath,
                { attributes: H, enabled: k } = R;
              return (
                (w = w || (K && K.path)),
                K && K.undo(),
                w && k
                  ? ((R = P(J, "afterModifyTree", (U) => {
                      if (w && k) {
                        let W = w.attr("id");
                        W || w.attr("id", (W = u()));
                        var _ = { x: 0, y: 0 };
                        p(H.dx) && ((_.dx = H.dx), delete H.dx),
                          p(H.dy) && ((_.dy = H.dy), delete H.dy),
                          J.attr(_),
                          this.attr({ transform: "" }),
                          this.box && (this.box = this.box.destroy()),
                          (_ = U.nodes.slice(0)),
                          (U.nodes.length = 0),
                          (U.nodes[0] = {
                            tagName: "textPath",
                            attributes: T(H, {
                              "text-anchor": H.textAnchor,
                              href: `${X}#${W}`,
                            }),
                            children: _,
                          });
                      }
                    })),
                    (J.textPath = { path: w, undo: R }))
                  : (J.attr({ dx: 0, dy: 0 }), delete J.textPath),
                this.added && ((J.textCache = ""), this.renderer.buildText(J)),
                this
              );
            }
            shadow(w) {
              var R;
              const { renderer: X } = this,
                J = y(
                  ((R = this.parentGroup) === null || R === void 0
                    ? void 0
                    : R.rotation) === 90
                    ? { offsetX: -1, offsetY: -1 }
                    : {},
                  f(w) ? w : {}
                );
              return (
                (R = X.shadowDefinition(J)),
                this.attr({ filter: w ? `url(${X.url}#${R})` : "none" })
              );
            }
            show(w = !0) {
              return this.attr({ visibility: w ? "inherit" : "visible" });
            }
            "stroke-widthSetter"(w, R, X) {
              (this[R] = w), X.setAttribute(R, w);
            }
            strokeWidth() {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              const w = this.getStyle("stroke-width");
              let R = 0,
                X;
              return (
                w.indexOf("px") === w.length - 2
                  ? (R = r(w))
                  : w !== "" &&
                    ((X = E.createElementNS(S, "rect")),
                    h(X, { width: w, "stroke-width": 0 }),
                    this.element.parentNode.appendChild(X),
                    (R = X.getBBox().width),
                    X.parentNode.removeChild(X)),
                R
              );
            }
            symbolAttr(w) {
              const R = this;
              v.symbolCustomAttribs.forEach(function (X) {
                R[X] = o(w[X], R[X]);
              }),
                R.attr({
                  d: R.renderer.symbols[R.symbolName](
                    R.x,
                    R.y,
                    R.width,
                    R.height,
                    R
                  ),
                });
            }
            textSetter(w) {
              w !== this.textStr &&
                (delete this.textPxLength,
                (this.textStr = w),
                this.added && this.renderer.buildText(this));
            }
            titleSetter(w) {
              const R = this.element,
                X =
                  R.getElementsByTagName("title")[0] ||
                  E.createElementNS(this.SVG_NS, "title");
              R.insertBefore
                ? R.insertBefore(X, R.firstChild)
                : R.appendChild(X),
                (X.textContent = String(o(w, ""))
                  .replace(/<[^>]*>/g, "")
                  .replace(/&lt;/g, "<")
                  .replace(/&gt;/g, ">"));
            }
            toFront() {
              const w = this.element;
              return w.parentNode.appendChild(w), this;
            }
            translate(w, R) {
              return this.attr({ translateX: w, translateY: R });
            }
            updateTransform() {
              const {
                  element: w,
                  matrix: R,
                  rotation: X = 0,
                  scaleX: J,
                  scaleY: K,
                  translateX: H = 0,
                  translateY: k = 0,
                } = this,
                U = ["translate(" + H + "," + k + ")"];
              p(R) && U.push("matrix(" + R.join(",") + ")"),
                X &&
                  U.push(
                    "rotate(" +
                      X +
                      " " +
                      o(this.rotationOriginX, w.getAttribute("x"), 0) +
                      " " +
                      o(this.rotationOriginY, w.getAttribute("y") || 0) +
                      ")"
                  ),
                (p(J) || p(K)) &&
                  U.push("scale(" + o(J, 1) + " " + o(K, 1) + ")"),
                U.length &&
                  !(this.text || this).textPath &&
                  w.setAttribute("transform", U.join(" "));
            }
            visibilitySetter(w, R, X) {
              w === "inherit"
                ? X.removeAttribute(R)
                : this[R] !== w && X.setAttribute(R, w),
                (this[R] = w);
            }
            xGetter(w) {
              return (
                this.element.nodeName === "circle" &&
                  (w === "x" ? (w = "cx") : w === "y" && (w = "cy")),
                this._defaultGetter(w)
              );
            }
            zIndexSetter(w, R) {
              var X = this.renderer,
                J = this.parentGroup;
              const K = (J || X).element || X.box,
                H = this.element;
              X = K === X.box;
              let k = !1,
                U;
              var _ = this.added;
              let W;
              if (
                (p(w)
                  ? (H.setAttribute("data-z-index", w),
                    (w = +w),
                    this[R] === w && (_ = !1))
                  : p(this[R]) && H.removeAttribute("data-z-index"),
                (this[R] = w),
                _)
              ) {
                for (
                  (w = this.zIndex) && J && (J.handleZ = !0),
                    R = K.childNodes,
                    W = R.length - 1;
                  0 <= W && !k;
                  W--
                )
                  (J = R[W]),
                    (_ = J.getAttribute("data-z-index")),
                    (U = !p(_)),
                    J !== H &&
                      (0 > w && U && !X && !W
                        ? (K.insertBefore(H, R[W]), (k = !0))
                        : (r(_) <= w || (U && (!p(w) || 0 <= w))) &&
                          (K.insertBefore(H, R[W + 1]), (k = !0)));
                k || (K.insertBefore(H, R[X ? 3 : 0]), (k = !0));
              }
              return k;
            }
          }
          return (
            (v.symbolCustomAttribs =
              "anchorX anchorY clockwise end height innerR r start width x y".split(
                " "
              )),
            (v.prototype.strokeSetter = v.prototype.fillSetter),
            (v.prototype.yGetter = v.prototype.xGetter),
            (v.prototype.matrixSetter =
              v.prototype.rotationOriginXSetter =
              v.prototype.rotationOriginYSetter =
              v.prototype.rotationSetter =
              v.prototype.scaleXSetter =
              v.prototype.scaleYSetter =
              v.prototype.translateXSetter =
              v.prototype.translateYSetter =
              v.prototype.verticalAlignSetter =
                function (N, w) {
                  (this[w] = N), (this.doTransform = !0);
                }),
            v
          );
        }
      ),
      n(
        i,
        "Core/Renderer/RendererRegistry.js",
        [i["Core/Globals.js"]],
        function (a) {
          var d;
          return (
            (function (M) {
              M.rendererTypes = {};
              let O;
              (M.getRendererType = function (B = O) {
                return M.rendererTypes[B] || M.rendererTypes[O];
              }),
                (M.registerRendererType = function (B, G, Y) {
                  (M.rendererTypes[B] = G),
                    (!O || Y) && ((O = B), (a.Renderer = G));
                });
            })(d || (d = {})),
            d
          );
        }
      ),
      n(
        i,
        "Core/Renderer/SVG/SVGLabel.js",
        [i["Core/Renderer/SVG/SVGElement.js"], i["Core/Utilities.js"]],
        function (a, d) {
          const {
            defined: M,
            extend: O,
            isNumber: B,
            merge: G,
            pick: Y,
            removeEvent: L,
          } = d;
          class E extends a {
            constructor(S, x, P, h, s, l, p, g, T, D) {
              super(),
                (this.paddingRightSetter = this.paddingLeftSetter =
                  this.paddingSetter),
                this.init(S, "g"),
                (this.textStr = x),
                (this.x = P),
                (this.y = h),
                (this.anchorX = l),
                (this.anchorY = p),
                (this.baseline = T),
                (this.className = D),
                this.addClass(
                  D === "button" ? "highcharts-no-tooltip" : "highcharts-label"
                ),
                D && this.addClass("highcharts-" + D),
                (this.text = S.text(void 0, 0, 0, g).attr({ zIndex: 1 }));
              let A;
              typeof s == "string" &&
                ((A = /^url\((.*?)\)$/.test(s)) || this.renderer.symbols[s]) &&
                (this.symbolKey = s),
                (this.bBox = E.emptyBBox),
                (this.padding = 3),
                (this.baselineOffset = 0),
                (this.needsBox = S.styledMode || A),
                (this.deferredAttr = {}),
                (this.alignFactor = 0);
            }
            alignSetter(S) {
              (S = { left: 0, center: 0.5, right: 1 }[S]),
                S !== this.alignFactor &&
                  ((this.alignFactor = S),
                  this.bBox &&
                    B(this.xSetting) &&
                    this.attr({ x: this.xSetting }));
            }
            anchorXSetter(S, x) {
              (this.anchorX = S),
                this.boxAttr(
                  x,
                  Math.round(S) - this.getCrispAdjust() - this.xSetting
                );
            }
            anchorYSetter(S, x) {
              (this.anchorY = S), this.boxAttr(x, S - this.ySetting);
            }
            boxAttr(S, x) {
              this.box ? this.box.attr(S, x) : (this.deferredAttr[S] = x);
            }
            css(S) {
              if (S) {
                const x = {};
                (S = G(S)),
                  E.textProps.forEach((P) => {
                    typeof S[P] < "u" && ((x[P] = S[P]), delete S[P]);
                  }),
                  this.text.css(x),
                  "fontSize" in x || "fontWeight" in x
                    ? this.updateTextPadding()
                    : ("width" in x || "textOverflow" in x) &&
                      this.updateBoxSize();
              }
              return a.prototype.css.call(this, S);
            }
            destroy() {
              L(this.element, "mouseenter"),
                L(this.element, "mouseleave"),
                this.text && this.text.destroy(),
                this.box && (this.box = this.box.destroy()),
                a.prototype.destroy.call(this);
            }
            fillSetter(S, x) {
              S && (this.needsBox = !0), (this.fill = S), this.boxAttr(x, S);
            }
            getBBox() {
              this.textStr &&
                this.bBox.width === 0 &&
                this.bBox.height === 0 &&
                this.updateBoxSize();
              const S = this.padding,
                x = Y(this.paddingLeft, S);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - x,
                y: this.bBox.y - S,
              };
            }
            getCrispAdjust() {
              return this.renderer.styledMode && this.box
                ? (this.box.strokeWidth() % 2) / 2
                : ((this["stroke-width"]
                    ? parseInt(this["stroke-width"], 10)
                    : 0) %
                    2) /
                    2;
            }
            heightSetter(S) {
              this.heightSetting = S;
            }
            onAdd() {
              this.text.add(this),
                this.attr({
                  text: Y(this.textStr, ""),
                  x: this.x || 0,
                  y: this.y || 0,
                }),
                this.box &&
                  M(this.anchorX) &&
                  this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
            }
            paddingSetter(S, x) {
              B(S)
                ? S !== this[x] && ((this[x] = S), this.updateTextPadding())
                : (this[x] = void 0);
            }
            rSetter(S, x) {
              this.boxAttr(x, S);
            }
            strokeSetter(S, x) {
              (this.stroke = S), this.boxAttr(x, S);
            }
            "stroke-widthSetter"(S, x) {
              S && (this.needsBox = !0),
                (this["stroke-width"] = S),
                this.boxAttr(x, S);
            }
            "text-alignSetter"(S) {
              this.textAlign = S;
            }
            textSetter(S) {
              typeof S < "u" && this.text.attr({ text: S }),
                this.updateTextPadding();
            }
            updateBoxSize() {
              var S = this.text;
              const x = {},
                P = this.padding,
                h = (this.bBox =
                  (B(this.widthSetting) &&
                    B(this.heightSetting) &&
                    !this.textAlign) ||
                  !M(S.textStr)
                    ? E.emptyBBox
                    : S.getBBox());
              (this.width = this.getPaddedWidth()),
                (this.height = (this.heightSetting || h.height || 0) + 2 * P);
              const s = this.renderer.fontMetrics(S);
              (this.baselineOffset =
                P +
                Math.min(
                  (this.text.firstLineMetrics || s).b,
                  h.height || 1 / 0
                )),
                this.heightSetting &&
                  (this.baselineOffset += (this.heightSetting - s.h) / 2),
                this.needsBox &&
                  !S.textPath &&
                  (this.box ||
                    ((S = this.box =
                      this.symbolKey
                        ? this.renderer.symbol(this.symbolKey)
                        : this.renderer.rect()),
                    S.addClass(
                      (this.className === "button"
                        ? ""
                        : "highcharts-label-box") +
                        (this.className
                          ? " highcharts-" + this.className + "-box"
                          : "")
                    ),
                    S.add(this)),
                  (S = this.getCrispAdjust()),
                  (x.x = S),
                  (x.y = (this.baseline ? -this.baselineOffset : 0) + S),
                  (x.width = Math.round(this.width)),
                  (x.height = Math.round(this.height)),
                  this.box.attr(O(x, this.deferredAttr)),
                  (this.deferredAttr = {}));
            }
            updateTextPadding() {
              const S = this.text;
              if (!S.textPath) {
                this.updateBoxSize();
                const x = this.baseline ? 0 : this.baselineOffset;
                let P = Y(this.paddingLeft, this.padding);
                M(this.widthSetting) &&
                  this.bBox &&
                  (this.textAlign === "center" || this.textAlign === "right") &&
                  (P +=
                    { center: 0.5, right: 1 }[this.textAlign] *
                    (this.widthSetting - this.bBox.width)),
                  (P !== S.x || x !== S.y) &&
                    (S.attr("x", P),
                    S.hasBoxWidthChanged && (this.bBox = S.getBBox(!0)),
                    typeof x < "u" && S.attr("y", x)),
                  (S.x = P),
                  (S.y = x);
              }
            }
            widthSetter(S) {
              this.widthSetting = B(S) ? S : void 0;
            }
            getPaddedWidth() {
              var S = this.padding;
              const x = Y(this.paddingLeft, S);
              return (
                (S = Y(this.paddingRight, S)),
                (this.widthSetting || this.bBox.width || 0) + x + S
              );
            }
            xSetter(S) {
              (this.x = S),
                this.alignFactor &&
                  ((S -= this.alignFactor * this.getPaddedWidth()),
                  (this["forceAnimate:x"] = !0)),
                (this.xSetting = Math.round(S)),
                this.attr("translateX", this.xSetting);
            }
            ySetter(S) {
              (this.ySetting = this.y = Math.round(S)),
                this.attr("translateY", this.ySetting);
            }
          }
          return (
            (E.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }),
            (E.textProps =
              "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(
                " "
              )),
            E
          );
        }
      ),
      n(
        i,
        "Core/Renderer/SVG/Symbols.js",
        [i["Core/Utilities.js"]],
        function (a) {
          function d(L, E, z, S, x) {
            const P = [];
            if (x) {
              const h = x.start || 0,
                s = Y(x.r, z);
              (z = Y(x.r, S || z)), (S = (x.end || 0) - 0.001);
              const l = x.innerR,
                p = Y(x.open, 0.001 > Math.abs((x.end || 0) - h - 2 * Math.PI)),
                g = Math.cos(h),
                T = Math.sin(h),
                D = Math.cos(S),
                A = Math.sin(S),
                m = Y(x.longArc, 0.001 > S - h - Math.PI ? 0 : 1);
              let f = [
                "A",
                s,
                z,
                0,
                m,
                Y(x.clockwise, 1),
                L + s * D,
                E + z * A,
              ];
              (f.params = { start: h, end: S, cx: L, cy: E }),
                P.push(["M", L + s * g, E + z * T], f),
                B(l) &&
                  ((f = [
                    "A",
                    l,
                    l,
                    0,
                    m,
                    B(x.clockwise) ? 1 - x.clockwise : 0,
                    L + l * g,
                    E + l * T,
                  ]),
                  (f.params = { start: S, end: h, cx: L, cy: E }),
                  P.push(
                    p
                      ? ["M", L + l * D, E + l * A]
                      : ["L", L + l * D, E + l * A],
                    f
                  )),
                p || P.push(["Z"]);
            }
            return P;
          }
          function M(L, E, z, S, x) {
            return x && x.r
              ? O(L, E, z, S, x)
              : [
                  ["M", L, E],
                  ["L", L + z, E],
                  ["L", L + z, E + S],
                  ["L", L, E + S],
                  ["Z"],
                ];
          }
          function O(L, E, z, S, x) {
            return (
              (x = (x == null ? void 0 : x.r) || 0),
              [
                ["M", L + x, E],
                ["L", L + z - x, E],
                ["A", x, x, 0, 0, 1, L + z, E + x],
                ["L", L + z, E + S - x],
                ["A", x, x, 0, 0, 1, L + z - x, E + S],
                ["L", L + x, E + S],
                ["A", x, x, 0, 0, 1, L, E + S - x],
                ["L", L, E + x],
                ["A", x, x, 0, 0, 1, L + x, E],
                ["Z"],
              ]
            );
          }
          const { defined: B, isNumber: G, pick: Y } = a;
          return {
            arc: d,
            callout: function (L, E, z, S, x) {
              const P = Math.min((x && x.r) || 0, z, S),
                h = P + 6,
                s = x && x.anchorX;
              x = (x && x.anchorY) || 0;
              const l = O(L, E, z, S, { r: P });
              return (
                G(s) &&
                  (L + s >= z
                    ? x > E + h && x < E + S - h
                      ? l.splice(
                          3,
                          1,
                          ["L", L + z, x - 6],
                          ["L", L + z + 6, x],
                          ["L", L + z, x + 6],
                          ["L", L + z, E + S - P]
                        )
                      : l.splice(
                          3,
                          1,
                          ["L", L + z, S / 2],
                          ["L", s, x],
                          ["L", L + z, S / 2],
                          ["L", L + z, E + S - P]
                        )
                    : 0 >= L + s
                    ? x > E + h && x < E + S - h
                      ? l.splice(
                          7,
                          1,
                          ["L", L, x + 6],
                          ["L", L - 6, x],
                          ["L", L, x - 6],
                          ["L", L, E + P]
                        )
                      : l.splice(
                          7,
                          1,
                          ["L", L, S / 2],
                          ["L", s, x],
                          ["L", L, S / 2],
                          ["L", L, E + P]
                        )
                    : x && x > S && s > L + h && s < L + z - h
                    ? l.splice(
                        5,
                        1,
                        ["L", s + 6, E + S],
                        ["L", s, E + S + 6],
                        ["L", s - 6, E + S],
                        ["L", L + P, E + S]
                      )
                    : x &&
                      0 > x &&
                      s > L + h &&
                      s < L + z - h &&
                      l.splice(
                        1,
                        1,
                        ["L", s - 6, E],
                        ["L", s, E - 6],
                        ["L", s + 6, E],
                        ["L", z - P, E]
                      )),
                l
              );
            },
            circle: function (L, E, z, S) {
              return d(L + z / 2, E + S / 2, z / 2, S / 2, {
                start: 0.5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1,
              });
            },
            diamond: function (L, E, z, S) {
              return [
                ["M", L + z / 2, E],
                ["L", L + z, E + S / 2],
                ["L", L + z / 2, E + S],
                ["L", L, E + S / 2],
                ["Z"],
              ];
            },
            rect: M,
            roundedRect: O,
            square: M,
            triangle: function (L, E, z, S) {
              return [
                ["M", L + z / 2, E],
                ["L", L + z, E + S],
                ["L", L, E + S],
                ["Z"],
              ];
            },
            "triangle-down": function (L, E, z, S) {
              return [
                ["M", L, E],
                ["L", L + z, E],
                ["L", L + z / 2, E + S],
                ["Z"],
              ];
            },
          };
        }
      ),
      n(
        i,
        "Core/Renderer/SVG/TextBuilder.js",
        [
          i["Core/Renderer/HTML/AST.js"],
          i["Core/Globals.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { doc: O, SVG_NS: B, win: G } = d,
            {
              attr: Y,
              extend: L,
              fireEvent: E,
              isString: z,
              objectEach: S,
              pick: x,
            } = M;
          class P {
            constructor(s) {
              const l = s.styles;
              (this.renderer = s.renderer),
                (this.svgElement = s),
                (this.width = s.textWidth),
                (this.textLineHeight = l && l.lineHeight),
                (this.textOutline = l && l.textOutline),
                (this.ellipsis = !(!l || l.textOverflow !== "ellipsis")),
                (this.noWrap = !(!l || l.whiteSpace !== "nowrap"));
            }
            buildSVG() {
              const s = this.svgElement,
                l = s.element;
              var p = s.renderer,
                g = x(s.textStr, "").toString();
              const T = g.indexOf("<") !== -1,
                D = l.childNodes;
              p = !s.added && p.box;
              const A = /<br.*?>/g;
              var m = [
                g,
                this.ellipsis,
                this.noWrap,
                this.textLineHeight,
                this.textOutline,
                s.getStyle("font-size"),
                this.width,
              ].join();
              if (m !== s.textCache) {
                for (s.textCache = m, delete s.actualWidth, m = D.length; m--; )
                  l.removeChild(D[m]);
                T ||
                this.ellipsis ||
                this.width ||
                s.textPath ||
                (g.indexOf(" ") !== -1 && (!this.noWrap || A.test(g)))
                  ? g !== "" &&
                    (p && p.appendChild(l),
                    (g = new a(g)),
                    this.modifyTree(g.nodes),
                    g.addToDOM(l),
                    this.modifyDOM(),
                    this.ellipsis &&
                      (l.textContent || "").indexOf("") !== -1 &&
                      s.attr(
                        "title",
                        this.unescapeEntities(s.textStr || "", ["&lt;", "&gt;"])
                      ),
                    p && p.removeChild(l))
                  : l.appendChild(O.createTextNode(this.unescapeEntities(g))),
                  z(this.textOutline) &&
                    s.applyTextOutline &&
                    s.applyTextOutline(this.textOutline);
              }
            }
            modifyDOM() {
              const s = this.svgElement,
                l = Y(s.element, "x");
              s.firstLineMetrics = void 0;
              let p;
              for (
                ;
                (p = s.element.firstChild) &&
                /^[\s\u200B]*$/.test(p.textContent || " ");

              )
                s.element.removeChild(p);
              [].forEach.call(
                s.element.querySelectorAll("tspan.highcharts-br"),
                (A, m) => {
                  A.nextSibling &&
                    A.previousSibling &&
                    (m === 0 &&
                      A.previousSibling.nodeType === 1 &&
                      (s.firstLineMetrics = s.renderer.fontMetrics(
                        A.previousSibling
                      )),
                    Y(A, { dy: this.getLineHeight(A.nextSibling), x: l }));
                }
              );
              const g = this.width || 0;
              if (g) {
                var T = (A, m) => {
                    var f = A.textContent || "";
                    const b = f.replace(/([^\^])-/g, "$1- ").split(" ");
                    var y =
                      !this.noWrap &&
                      (1 < b.length || 1 < s.element.childNodes.length);
                    const C = this.getLineHeight(m);
                    let o = 0,
                      r = s.actualWidth;
                    if (this.ellipsis)
                      f &&
                        this.truncate(
                          A,
                          f,
                          void 0,
                          0,
                          Math.max(0, g - 0.8 * C),
                          (c, u) => c.substring(0, u) + ""
                        );
                    else if (y) {
                      for (f = [], y = []; m.firstChild && m.firstChild !== A; )
                        y.push(m.firstChild), m.removeChild(m.firstChild);
                      for (; b.length; )
                        b.length &&
                          !this.noWrap &&
                          0 < o &&
                          (f.push(A.textContent || ""),
                          (A.textContent = b.join(" ").replace(/- /g, "-"))),
                          this.truncate(
                            A,
                            void 0,
                            b,
                            (o === 0 && r) || 0,
                            g,
                            (c, u) =>
                              b.slice(0, u).join(" ").replace(/- /g, "-")
                          ),
                          (r = s.actualWidth),
                          o++;
                      y.forEach((c) => {
                        m.insertBefore(c, A);
                      }),
                        f.forEach((c) => {
                          m.insertBefore(O.createTextNode(c), A),
                            (c = O.createElementNS(B, "tspan")),
                            (c.textContent = ""),
                            Y(c, { dy: C, x: l }),
                            m.insertBefore(c, A);
                        });
                    }
                  },
                  D = (A) => {
                    [].slice.call(A.childNodes).forEach((m) => {
                      m.nodeType === G.Node.TEXT_NODE
                        ? T(m, A)
                        : (m.className.baseVal.indexOf("highcharts-br") !==
                            -1 && (s.actualWidth = 0),
                          D(m));
                    });
                  };
                D(s.element);
              }
            }
            getLineHeight(s) {
              return (
                (s = s.nodeType === G.Node.TEXT_NODE ? s.parentElement : s),
                this.textLineHeight
                  ? parseInt(this.textLineHeight.toString(), 10)
                  : this.renderer.fontMetrics(s || this.svgElement.element).h
              );
            }
            modifyTree(s) {
              const l = (p, g) => {
                const {
                    attributes: T = {},
                    children: D,
                    style: A = {},
                    tagName: m,
                  } = p,
                  f = this.renderer.styledMode;
                m === "b" || m === "strong"
                  ? f
                    ? (T.class = "highcharts-strong")
                    : (A.fontWeight = "bold")
                  : (m === "i" || m === "em") &&
                    (f
                      ? (T.class = "highcharts-emphasized")
                      : (A.fontStyle = "italic")),
                  A && A.color && (A.fill = A.color),
                  m === "br"
                    ? ((T.class = "highcharts-br"),
                      (p.textContent = ""),
                      (g = s[g + 1]) &&
                        g.textContent &&
                        (g.textContent = g.textContent.replace(/^ +/gm, "")))
                    : m === "a" &&
                      D &&
                      D.some((b) => b.tagName === "#text") &&
                      (p.children = [{ children: D, tagName: "tspan" }]),
                  m !== "#text" && m !== "a" && (p.tagName = "tspan"),
                  L(p, { attributes: T, style: A }),
                  D && D.filter((b) => b.tagName !== "#text").forEach(l);
              };
              s.forEach(l), E(this.svgElement, "afterModifyTree", { nodes: s });
            }
            truncate(s, l, p, g, T, D) {
              const A = this.svgElement,
                { rotation: m } = A,
                f = [];
              let b = p ? 1 : 0,
                y = (l || p || "").length,
                C = y,
                o,
                r;
              const c = function (u, v) {
                if (
                  ((u = v || u),
                  (v = s.parentNode) &&
                    typeof f[u] > "u" &&
                    v.getSubStringLength)
                )
                  try {
                    f[u] = g + v.getSubStringLength(0, p ? u + 1 : u);
                  } catch {}
                return f[u];
              };
              if (
                ((A.rotation = 0), (r = c(s.textContent.length)), g + r > T)
              ) {
                for (; b <= y; )
                  (C = Math.ceil((b + y) / 2)),
                    p && (o = D(p, C)),
                    (r = c(C, o && o.length - 1)),
                    b === y ? (b = y + 1) : r > T ? (y = C - 1) : (b = C);
                y === 0
                  ? (s.textContent = "")
                  : (l && y === l.length - 1) ||
                    (s.textContent = o || D(l || p, C));
              }
              p && p.splice(0, C), (A.actualWidth = r), (A.rotation = m);
            }
            unescapeEntities(s, l) {
              return (
                S(this.renderer.escapes, function (p, g) {
                  (l && l.indexOf(p) !== -1) ||
                    (s = s.toString().replace(new RegExp(p, "g"), g));
                }),
                s
              );
            }
          }
          return P;
        }
      ),
      n(
        i,
        "Core/Renderer/SVG/SVGRenderer.js",
        [
          i["Core/Renderer/HTML/AST.js"],
          i["Core/Color/Color.js"],
          i["Core/Globals.js"],
          i["Core/Renderer/RendererRegistry.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Renderer/SVG/SVGLabel.js"],
          i["Core/Renderer/SVG/Symbols.js"],
          i["Core/Renderer/SVG/TextBuilder.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G, Y, L, E) {
          const {
              charts: z,
              deg2rad: S,
              doc: x,
              isFirefox: P,
              isMS: h,
              isWebKit: s,
              noop: l,
              SVG_NS: p,
              symbolSizes: g,
              win: T,
            } = M,
            {
              addEvent: D,
              attr: A,
              createElement: m,
              css: f,
              defined: b,
              destroyObjectProperties: y,
              extend: C,
              isArray: o,
              isNumber: r,
              isObject: c,
              isString: u,
              merge: v,
              pick: N,
              pInt: w,
              uniqueKey: R,
            } = E;
          let X;
          class J {
            constructor(H, k, U, _, W, tt, j) {
              (this.width =
                this.url =
                this.style =
                this.imgCount =
                this.height =
                this.gradients =
                this.globalAnimation =
                this.defs =
                this.chartIndex =
                this.cacheKeys =
                this.cache =
                this.boxWrapper =
                this.box =
                this.alignedObjects =
                  void 0),
                this.init(H, k, U, _, W, tt, j);
            }
            init(H, k, U, _, W, tt, j) {
              const I = this.createElement("svg").attr({
                  version: "1.1",
                  class: "highcharts-root",
                }),
                F = I.element;
              j || I.css(this.getStyle(_)),
                H.appendChild(F),
                A(H, "dir", "ltr"),
                H.innerHTML.indexOf("xmlns") === -1 &&
                  A(F, "xmlns", this.SVG_NS),
                (this.box = F),
                (this.boxWrapper = I),
                (this.alignedObjects = []),
                (this.url = this.getReferenceURL()),
                this.createElement("desc")
                  .add()
                  .element.appendChild(
                    x.createTextNode("Created with Highcharts 11.1.0")
                  ),
                (this.defs = this.createElement("defs").add()),
                (this.allowHTML = tt),
                (this.forExport = W),
                (this.styledMode = j),
                (this.gradients = {}),
                (this.cache = {}),
                (this.cacheKeys = []),
                (this.imgCount = 0),
                (this.rootFontSize = I.getStyle("font-size")),
                this.setSize(k, U, !1);
              let V;
              P &&
                H.getBoundingClientRect &&
                ((k = function () {
                  f(H, { left: 0, top: 0 }),
                    (V = H.getBoundingClientRect()),
                    f(H, {
                      left: Math.ceil(V.left) - V.left + "px",
                      top: Math.ceil(V.top) - V.top + "px",
                    });
                }),
                k(),
                (this.unSubPixelFix = D(T, "resize", k)));
            }
            definition(H) {
              return new a([H]).addToDOM(this.defs.element);
            }
            getReferenceURL() {
              if ((P || s) && x.getElementsByTagName("base").length) {
                if (!b(X)) {
                  var H = R();
                  (H = new a([
                    {
                      tagName: "svg",
                      attributes: { width: 8, height: 8 },
                      children: [
                        {
                          tagName: "defs",
                          children: [
                            {
                              tagName: "clipPath",
                              attributes: { id: H },
                              children: [
                                {
                                  tagName: "rect",
                                  attributes: { width: 4, height: 4 },
                                },
                              ],
                            },
                          ],
                        },
                        {
                          tagName: "rect",
                          attributes: {
                            id: "hitme",
                            width: 8,
                            height: 8,
                            "clip-path": `url(#${H})`,
                            fill: "rgba(0,0,0,0.001)",
                          },
                        },
                      ],
                    },
                  ]).addToDOM(x.body)),
                    f(H, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                  const k = x.elementFromPoint(6, 6);
                  (X = (k && k.id) === "hitme"), x.body.removeChild(H);
                }
                if (X)
                  return T.location.href
                    .split("#")[0]
                    .replace(/<[^>]*>/g, "")
                    .replace(/([\('\)])/g, "\\$1")
                    .replace(/ /g, "%20");
              }
              return "";
            }
            getStyle(H) {
              return (this.style = C(
                {
                  fontFamily: "Helvetica, Arial, sans-serif",
                  fontSize: "1rem",
                },
                H
              ));
            }
            setStyle(H) {
              this.boxWrapper.css(this.getStyle(H));
            }
            isHidden() {
              return !this.boxWrapper.getBBox().width;
            }
            destroy() {
              const H = this.defs;
              return (
                (this.box = null),
                (this.boxWrapper = this.boxWrapper.destroy()),
                y(this.gradients || {}),
                (this.gradients = null),
                (this.defs = H.destroy()),
                this.unSubPixelFix && this.unSubPixelFix(),
                (this.alignedObjects = null)
              );
            }
            createElement(H) {
              const k = new this.Element();
              return k.init(this, H), k;
            }
            getRadialAttr(H, k) {
              return {
                cx: H[0] - H[2] / 2 + (k.cx || 0) * H[2],
                cy: H[1] - H[2] / 2 + (k.cy || 0) * H[2],
                r: (k.r || 0) * H[2],
              };
            }
            shadowDefinition(H) {
              const k = [
                  `highcharts-drop-shadow-${this.chartIndex}`,
                  ...Object.keys(H).map((_) => H[_]),
                ]
                  .join("-")
                  .replace(/[^a-z0-9\-]/g, ""),
                U = v(
                  {
                    color: "#000000",
                    offsetX: 1,
                    offsetY: 1,
                    opacity: 0.15,
                    width: 5,
                  },
                  H
                );
              return (
                this.defs.element.querySelector(`#${k}`) ||
                  this.definition({
                    tagName: "filter",
                    attributes: { id: k },
                    children: [
                      {
                        tagName: "feDropShadow",
                        attributes: {
                          dx: U.offsetX,
                          dy: U.offsetY,
                          "flood-color": U.color,
                          "flood-opacity": Math.min(5 * U.opacity, 1),
                          stdDeviation: U.width / 2,
                        },
                      },
                    ],
                  }),
                k
              );
            }
            buildText(H) {
              new L(H).buildSVG();
            }
            getContrast(H) {
              return (
                (H = d
                  .parse(H)
                  .rgba.map(
                    (k) => (
                      (k /= 255),
                      0.03928 >= k
                        ? k / 12.92
                        : Math.pow((k + 0.055) / 1.055, 2.4)
                    )
                  )),
                (H = 0.2126 * H[0] + 0.7152 * H[1] + 0.0722 * H[2]),
                1.05 / (H + 0.05) > (H + 0.05) / 0.05 ? "#FFFFFF" : "#000000"
              );
            }
            button(H, k, U, _, W = {}, tt, j, I, F, V) {
              const Q = this.label(
                  H,
                  k,
                  U,
                  F,
                  void 0,
                  void 0,
                  V,
                  void 0,
                  "button"
                ),
                $ = this.styledMode;
              H = W.states || {};
              let et = 0;
              (W = v(W)), delete W.states;
              const st = v(
                {
                  color: "#333333",
                  cursor: "pointer",
                  fontSize: "0.8em",
                  fontWeight: "normal",
                },
                W.style
              );
              delete W.style;
              let ot = a.filterUserAttributes(W);
              Q.attr(v({ padding: 8, r: 2 }, ot));
              let at, lt, Z;
              return (
                $ ||
                  ((ot = v(
                    { fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 },
                    ot
                  )),
                  (tt = v(
                    ot,
                    { fill: "#e6e6e6" },
                    a.filterUserAttributes(tt || H.hover || {})
                  )),
                  (at = tt.style),
                  delete tt.style,
                  (j = v(
                    ot,
                    {
                      fill: "#e6e9ff",
                      style: { color: "#000000", fontWeight: "bold" },
                    },
                    a.filterUserAttributes(j || H.select || {})
                  )),
                  (lt = j.style),
                  delete j.style,
                  (I = v(
                    ot,
                    { style: { color: "#cccccc" } },
                    a.filterUserAttributes(I || H.disabled || {})
                  )),
                  (Z = I.style),
                  delete I.style),
                D(Q.element, h ? "mouseover" : "mouseenter", function () {
                  et !== 3 && Q.setState(1);
                }),
                D(Q.element, h ? "mouseout" : "mouseleave", function () {
                  et !== 3 && Q.setState(et);
                }),
                (Q.setState = function (q) {
                  q !== 1 && (Q.state = et = q),
                    Q.removeClass(
                      /highcharts-button-(normal|hover|pressed|disabled)/
                    ).addClass(
                      "highcharts-button-" +
                        ["normal", "hover", "pressed", "disabled"][q || 0]
                    ),
                    $ ||
                      (Q.attr([ot, tt, j, I][q || 0]),
                      (q = [st, at, lt, Z][q || 0]),
                      c(q) && Q.css(q));
                }),
                $ ||
                  (Q.attr(ot).css(C({ cursor: "default" }, st)),
                  V && Q.text.css({ pointerEvents: "none" })),
                Q.on("touchstart", (q) => q.stopPropagation()).on(
                  "click",
                  function (q) {
                    et !== 3 && _.call(Q, q);
                  }
                )
              );
            }
            crispLine(H, k, U = "round") {
              const _ = H[0],
                W = H[1];
              return (
                b(_[1]) &&
                  _[1] === W[1] &&
                  (_[1] = W[1] = Math[U](_[1]) - (k % 2) / 2),
                b(_[2]) &&
                  _[2] === W[2] &&
                  (_[2] = W[2] = Math[U](_[2]) + (k % 2) / 2),
                H
              );
            }
            path(H) {
              const k = this.styledMode ? {} : { fill: "none" };
              return (
                o(H) ? (k.d = H) : c(H) && C(k, H),
                this.createElement("path").attr(k)
              );
            }
            circle(H, k, U) {
              return (
                (H = c(H) ? H : typeof H > "u" ? {} : { x: H, y: k, r: U }),
                (k = this.createElement("circle")),
                (k.xSetter = k.ySetter =
                  function (_, W, tt) {
                    tt.setAttribute("c" + W, _);
                  }),
                k.attr(H)
              );
            }
            arc(H, k, U, _, W, tt) {
              return (
                c(H)
                  ? ((_ = H), (k = _.y), (U = _.r), (H = _.x))
                  : (_ = { innerR: _, start: W, end: tt }),
                (H = this.symbol("arc", H, k, U, U, _)),
                (H.r = U),
                H
              );
            }
            rect(H, k, U, _, W, tt) {
              H = c(H)
                ? H
                : typeof H > "u"
                ? {}
                : {
                    x: H,
                    y: k,
                    r: W,
                    width: Math.max(U || 0, 0),
                    height: Math.max(_ || 0, 0),
                  };
              const j = this.createElement("rect");
              return (
                this.styledMode ||
                  (typeof tt < "u" &&
                    ((H["stroke-width"] = tt), C(H, j.crisp(H))),
                  (H.fill = "none")),
                (j.rSetter = function (I, F, V) {
                  (j.r = I), A(V, { rx: I, ry: I });
                }),
                (j.rGetter = function () {
                  return j.r || 0;
                }),
                j.attr(H)
              );
            }
            roundedRect(H) {
              return this.symbol("roundedRect").attr(H);
            }
            setSize(H, k, U) {
              (this.width = H),
                (this.height = k),
                this.boxWrapper.animate(
                  { width: H, height: k },
                  {
                    step: function () {
                      this.attr({
                        viewBox:
                          "0 0 " +
                          this.attr("width") +
                          " " +
                          this.attr("height"),
                      });
                    },
                    duration: N(U, !0) ? void 0 : 0,
                  }
                ),
                this.alignElements();
            }
            g(H) {
              const k = this.createElement("g");
              return H ? k.attr({ class: "highcharts-" + H }) : k;
            }
            image(H, k, U, _, W, tt) {
              const j = { preserveAspectRatio: "none" };
              r(k) && (j.x = k),
                r(U) && (j.y = U),
                r(_) && (j.width = _),
                r(W) && (j.height = W);
              const I = this.createElement("image").attr(j);
              return (
                (k = function (F) {
                  I.attr({ href: H }), tt.call(I, F);
                }),
                tt
                  ? (I.attr({
                      href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                    }),
                    (U = new T.Image()),
                    D(U, "load", k),
                    (U.src = H),
                    U.complete && k({}))
                  : I.attr({ href: H }),
                I
              );
            }
            symbol(H, k, U, _, W, tt) {
              const j = this,
                I = /^url\((.*?)\)$/,
                F = I.test(H),
                V = !F && (this.symbols[H] ? H : "circle"),
                Q = V && this.symbols[V];
              let $, et, st, ot;
              if (Q)
                typeof k == "number" &&
                  (et = Q.call(
                    this.symbols,
                    Math.round(k || 0),
                    Math.round(U || 0),
                    _ || 0,
                    W || 0,
                    tt
                  )),
                  ($ = this.path(et)),
                  j.styledMode || $.attr("fill", "none"),
                  C($, {
                    symbolName: V || void 0,
                    x: k,
                    y: U,
                    width: _,
                    height: W,
                  }),
                  tt && C($, tt);
              else if (F) {
                st = H.match(I)[1];
                const at = ($ = this.image(st));
                (at.imgwidth = N(tt && tt.width, g[st] && g[st].width)),
                  (at.imgheight = N(tt && tt.height, g[st] && g[st].height)),
                  (ot = (lt) =>
                    lt.attr({ width: lt.width, height: lt.height })),
                  ["width", "height"].forEach(function (lt) {
                    at[lt + "Setter"] = function (Z, q) {
                      this[q] = Z;
                      const {
                        alignByTranslate: nt,
                        element: it,
                        width: rt,
                        height: ht,
                        imgwidth: ct,
                        imgheight: ft,
                      } = this;
                      if (((Z = this["img" + q]), b(Z))) {
                        let yt = 1;
                        tt && tt.backgroundSize === "within" && rt && ht
                          ? ((yt = Math.min(rt / ct, ht / ft)),
                            A(it, {
                              width: Math.round(ct * yt),
                              height: Math.round(ft * yt),
                            }))
                          : it && it.setAttribute(q, Z),
                          nt ||
                            this.translate(
                              ((rt || 0) - ct * yt) / 2,
                              ((ht || 0) - ft * yt) / 2
                            );
                      }
                    };
                  }),
                  b(k) && at.attr({ x: k, y: U }),
                  (at.isImg = !0),
                  b(at.imgwidth) && b(at.imgheight)
                    ? ot(at)
                    : (at.attr({ width: 0, height: 0 }),
                      m("img", {
                        onload: function () {
                          const lt = z[j.chartIndex];
                          this.width === 0 &&
                            (f(this, { position: "absolute", top: "-999em" }),
                            x.body.appendChild(this)),
                            (g[st] = {
                              width: this.width,
                              height: this.height,
                            }),
                            (at.imgwidth = this.width),
                            (at.imgheight = this.height),
                            at.element && ot(at),
                            this.parentNode &&
                              this.parentNode.removeChild(this),
                            j.imgCount--,
                            !j.imgCount && lt && !lt.hasLoaded && lt.onload();
                        },
                        src: st,
                      }),
                      this.imgCount++);
              }
              return $;
            }
            clipRect(H, k, U, _) {
              const W = R() + "-",
                tt = this.createElement("clipPath")
                  .attr({ id: W })
                  .add(this.defs);
              return (
                (H = this.rect(H, k, U, _, 0).add(tt)),
                (H.id = W),
                (H.clipPath = tt),
                (H.count = 0),
                H
              );
            }
            text(H, k, U, _) {
              const W = {};
              return _ && (this.allowHTML || !this.forExport)
                ? this.html(H, k, U)
                : ((W.x = Math.round(k || 0)),
                  U && (W.y = Math.round(U)),
                  b(H) && (W.text = H),
                  (H = this.createElement("text").attr(W)),
                  (!_ || (this.forExport && !this.allowHTML)) &&
                    (H.xSetter = function (tt, j, I) {
                      const F = I.getElementsByTagName("tspan"),
                        V = I.getAttribute(j);
                      for (let Q = 0, $; Q < F.length; Q++)
                        ($ = F[Q]),
                          $.getAttribute(j) === V && $.setAttribute(j, tt);
                      I.setAttribute(j, tt);
                    }),
                  H);
            }
            fontMetrics(H) {
              H = w(B.prototype.getStyle.call(H, "font-size") || 0);
              const k = 24 > H ? H + 3 : Math.round(1.2 * H);
              return { h: k, b: Math.round(0.8 * k), f: H };
            }
            rotCorr(H, k, U) {
              let _ = H;
              return (
                k && U && (_ = Math.max(_ * Math.cos(k * S), 4)),
                { x: (-H / 3) * Math.sin(k * S), y: _ }
              );
            }
            pathToSegments(H) {
              const k = [],
                U = [],
                _ = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
              for (let W = 0; W < H.length; W++)
                u(U[0]) &&
                  r(H[W]) &&
                  U.length === _[U[0].toUpperCase()] &&
                  H.splice(W, 0, U[0].replace("M", "L").replace("m", "l")),
                  typeof H[W] == "string" &&
                    (U.length && k.push(U.slice(0)), (U.length = 0)),
                  U.push(H[W]);
              return k.push(U.slice(0)), k;
            }
            label(H, k, U, _, W, tt, j, I, F) {
              return new G(this, H, k, U, _, W, tt, j, I, F);
            }
            alignElements() {
              this.alignedObjects.forEach((H) => H.align());
            }
          }
          return (
            C(J.prototype, {
              Element: B,
              SVG_NS: p,
              escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;",
              },
              symbols: Y,
              draw: l,
            }),
            O.registerRendererType("svg", J, !0),
            J
          );
        }
      ),
      n(
        i,
        "Core/Renderer/HTML/HTMLElement.js",
        [
          i["Core/Globals.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { isFirefox: O, isMS: B, isWebKit: G, win: Y } = a,
            { css: L, defined: E, extend: z, pick: S, pInt: x } = M,
            P = [];
          class h extends d {
            static compose(l) {
              if (M.pushUnique(P, l)) {
                const p = h.prototype,
                  g = l.prototype;
                (g.getSpanCorrection = p.getSpanCorrection),
                  (g.htmlCss = p.htmlCss),
                  (g.htmlGetBBox = p.htmlGetBBox),
                  (g.htmlUpdateTransform = p.htmlUpdateTransform),
                  (g.setSpanRotation = p.setSpanRotation);
              }
              return l;
            }
            getSpanCorrection(l, p, g) {
              (this.xCorr = -l * g), (this.yCorr = -p);
            }
            htmlCss(l) {
              const p = this.element.tagName === "SPAN" && l && "width" in l,
                g = S(p && l.width, void 0);
              let T;
              return (
                p && (delete l.width, (this.textWidth = g), (T = !0)),
                l &&
                  l.textOverflow === "ellipsis" &&
                  ((l.whiteSpace = "nowrap"), (l.overflow = "hidden")),
                (this.styles = z(this.styles, l)),
                L(this.element, l),
                T && this.htmlUpdateTransform(),
                this
              );
            }
            htmlGetBBox() {
              const l = this.element;
              return {
                x: l.offsetLeft,
                y: l.offsetTop,
                width: l.offsetWidth,
                height: l.offsetHeight,
              };
            }
            htmlUpdateTransform() {
              if (this.added) {
                var l = this.renderer,
                  p = this.element,
                  g = this.x || 0,
                  T = this.y || 0,
                  D = this.textAlign || "left",
                  A = { left: 0, center: 0.5, right: 1 }[D],
                  m = this.styles,
                  f = m && m.whiteSpace;
                if (
                  (L(p, {
                    marginLeft: this.translateX || 0,
                    marginTop: this.translateY || 0,
                  }),
                  p.tagName === "SPAN")
                ) {
                  m = this.rotation;
                  const y = this.textWidth && x(this.textWidth),
                    C = [
                      m,
                      D,
                      p.innerHTML,
                      this.textWidth,
                      this.textAlign,
                    ].join();
                  let o = !1;
                  if (y !== this.oldTextWidth) {
                    if (this.textPxLength) var b = this.textPxLength;
                    else
                      L(p, { width: "", whiteSpace: f || "nowrap" }),
                        (b = p.offsetWidth);
                    (y > this.oldTextWidth || b > y) &&
                      (/[ \-]/.test(p.textContent || p.innerText) ||
                        p.style.textOverflow === "ellipsis") &&
                      (L(p, {
                        width: b > y || m ? y + "px" : "auto",
                        display: "block",
                        whiteSpace: f || "normal",
                      }),
                      (this.oldTextWidth = y),
                      (o = !0));
                  }
                  (this.hasBoxWidthChanged = o),
                    C !== this.cTT &&
                      ((l = l.fontMetrics(p).b),
                      !E(m) ||
                        (m === (this.oldRotation || 0) &&
                          D === this.oldAlign) ||
                        this.setSpanRotation(m, A, l),
                      this.getSpanCorrection(
                        (!E(m) && this.textPxLength) || p.offsetWidth,
                        l,
                        A,
                        m,
                        D
                      )),
                    L(p, {
                      left: g + (this.xCorr || 0) + "px",
                      top: T + (this.yCorr || 0) + "px",
                    }),
                    (this.cTT = C),
                    (this.oldRotation = m),
                    (this.oldAlign = D);
                }
              } else this.alignOnAdd = !0;
            }
            setSpanRotation(l, p, g) {
              const T = {},
                D =
                  B && !/Edge/.test(Y.navigator.userAgent)
                    ? "-ms-transform"
                    : G
                    ? "-webkit-transform"
                    : O
                    ? "MozTransform"
                    : Y.opera
                    ? "-o-transform"
                    : void 0;
              D &&
                ((T[D] = T.transform = "rotate(" + l + "deg)"),
                (T[D + (O ? "Origin" : "-origin")] = T.transformOrigin =
                  100 * p + "% " + g + "px"),
                L(this.element, T));
            }
          }
          return h;
        }
      ),
      n(
        i,
        "Core/Renderer/HTML/HTMLRenderer.js",
        [
          i["Core/Renderer/HTML/AST.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Renderer/SVG/SVGRenderer.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O) {
          const { attr: B, createElement: G, extend: Y, pick: L } = O,
            E = [];
          class z extends M {
            static compose(x) {
              return (
                O.pushUnique(E, x) && (x.prototype.html = z.prototype.html), x
              );
            }
            html(x, P, h) {
              const s = this.createElement("span"),
                l = s.element,
                p = s.renderer,
                g = function (T, D) {
                  ["opacity", "visibility"].forEach(function (A) {
                    T[A + "Setter"] = function (m, f, b) {
                      const y = T.div ? T.div.style : D;
                      d.prototype[A + "Setter"].call(this, m, f, b),
                        y && (y[f] = m);
                    };
                  }),
                    (T.addedSetters = !0);
                };
              return (
                (s.textSetter = function (T) {
                  T !== this.textStr &&
                    (delete this.bBox,
                    delete this.oldTextWidth,
                    a.setElementHTML(this.element, L(T, "")),
                    (this.textStr = T),
                    (s.doTransform = !0));
                }),
                g(s, s.element.style),
                (s.xSetter =
                  s.ySetter =
                  s.alignSetter =
                  s.rotationSetter =
                    function (T, D) {
                      D === "align"
                        ? (s.alignValue = s.textAlign = T)
                        : (s[D] = T),
                        (s.doTransform = !0);
                    }),
                (s.afterSetters = function () {
                  this.doTransform &&
                    (this.htmlUpdateTransform(), (this.doTransform = !1));
                }),
                s
                  .attr({ text: x, x: Math.round(P), y: Math.round(h) })
                  .css({ position: "absolute" }),
                p.styledMode ||
                  s.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize,
                  }),
                (l.style.whiteSpace = "nowrap"),
                (s.css = s.htmlCss),
                (s.add = function (T) {
                  const D = p.box.parentNode,
                    A = [];
                  let m;
                  if ((this.parentGroup = T)) {
                    if (((m = T.div), !m)) {
                      for (; T; ) A.push(T), (T = T.parentGroup);
                      A.reverse().forEach(function (f) {
                        function b(r, c) {
                          (f[c] = r),
                            c === "translateX"
                              ? (o.left = r + "px")
                              : (o.top = r + "px"),
                            (f.doTransform = !0);
                        }
                        const y = B(f.element, "class"),
                          C = f.styles || {};
                        m = f.div =
                          f.div ||
                          G(
                            "div",
                            y ? { className: y } : void 0,
                            {
                              position: "absolute",
                              left: (f.translateX || 0) + "px",
                              top: (f.translateY || 0) + "px",
                              display: f.display,
                              opacity: f.opacity,
                              visibility: f.visibility,
                            },
                            m || D
                          );
                        const o = m.style;
                        Y(f, {
                          classSetter: (function (r) {
                            return function (c) {
                              this.element.setAttribute("class", c),
                                (r.className = c);
                            };
                          })(m),
                          css: function (r) {
                            return (
                              s.css.call(f, r),
                              ["cursor", "pointerEvents"].forEach((c) => {
                                r[c] && (o[c] = r[c]);
                              }),
                              f
                            );
                          },
                          on: function () {
                            return (
                              A[0].div &&
                                s.on.apply(
                                  { element: A[0].div, onEvents: f.onEvents },
                                  arguments
                                ),
                              f
                            );
                          },
                          translateXSetter: b,
                          translateYSetter: b,
                        }),
                          f.addedSetters || g(f),
                          f.css(C);
                      });
                    }
                  } else m = D;
                  return (
                    m.appendChild(l),
                    (s.added = !0),
                    s.alignOnAdd && s.htmlUpdateTransform(),
                    s
                  );
                }),
                s
              );
            }
          }
          return z;
        }
      ),
      n(i, "Core/Axis/AxisDefaults.js", [], function () {
        var a;
        return (
          (function (d) {
            (d.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: { main: "%H:%M:%S.%L", range: !1 },
                second: { main: "%H:%M:%S", range: !1 },
                minute: { main: "%H:%M", range: !1 },
                hour: { main: "%H:%M", range: !1 },
                day: { main: "%e %b" },
                week: { main: "%e %b" },
                month: { main: "%b '%y" },
                year: { main: "%Y" },
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: 15,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                zIndex: 7,
                style: {
                  color: "#333333",
                  cursor: "default",
                  fontSize: "0.8em",
                },
              },
              maxPadding: 0.01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minorTicksPerMajor: 5,
              minPadding: 0.01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: { color: "#666666", fontSize: "0.8em" },
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: "#f2f2f2",
              minorGridLineWidth: 1,
              minorTickColor: "#999999",
              lineColor: "#333333",
              lineWidth: 1,
              gridLineColor: "#e6e6e6",
              gridLineWidth: void 0,
              tickColor: "#333333",
            }),
              (d.defaultYAxisOptions = {
                reversedStacks: !0,
                endOnTick: !0,
                maxPadding: 0.05,
                minPadding: 0.05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: { x: void 0 },
                startOnTick: !0,
                title: { rotation: 270, text: "Values" },
                stackLabels: {
                  animation: {},
                  allowOverlap: !1,
                  enabled: !1,
                  crop: !0,
                  overflow: "justify",
                  formatter: function () {
                    const { numberFormatter: M } = this.axis.chart;
                    return M(this.total || 0, -1);
                  },
                  style: {
                    color: "#000000",
                    fontSize: "0.7em",
                    fontWeight: "bold",
                    textOutline: "1px contrast",
                  },
                },
                gridLineWidth: 1,
                lineWidth: 0,
              }),
              (d.defaultLeftAxisOptions = { title: { rotation: 270 } }),
              (d.defaultRightAxisOptions = { title: { rotation: 90 } }),
              (d.defaultBottomAxisOptions = {
                labels: { autoRotation: [-45] },
                margin: 15,
                title: { rotation: 0 },
              }),
              (d.defaultTopAxisOptions = {
                labels: { autoRotation: [-45] },
                margin: 15,
                title: { rotation: 0 },
              });
          })(a || (a = {})),
          a
        );
      }),
      n(i, "Core/Foundation.js", [i["Core/Utilities.js"]], function (a) {
        const { addEvent: d, isFunction: M, objectEach: O, removeEvent: B } = a;
        var G;
        return (
          (function (Y) {
            Y.registerEventOptions = function (L, E) {
              (L.eventOptions = L.eventOptions || {}),
                O(E.events, function (z, S) {
                  L.eventOptions[S] !== z &&
                    (L.eventOptions[S] &&
                      (B(L, S, L.eventOptions[S]), delete L.eventOptions[S]),
                    M(z) &&
                      ((L.eventOptions[S] = z), d(L, S, z, { order: 0 })));
                });
            };
          })(G || (G = {})),
          G
        );
      }),
      n(
        i,
        "Core/Axis/Tick.js",
        [i["Core/Templating.js"], i["Core/Globals.js"], i["Core/Utilities.js"]],
        function (a, d, M) {
          const { deg2rad: O } = d,
            {
              clamp: B,
              correctFloat: G,
              defined: Y,
              destroyObjectProperties: L,
              extend: E,
              fireEvent: z,
              isNumber: S,
              merge: x,
              objectEach: P,
              pick: h,
            } = M;
          class s {
            constructor(p, g, T, D, A) {
              (this.isNewLabel = this.isNew = !0),
                (this.axis = p),
                (this.pos = g),
                (this.type = T || ""),
                (this.parameters = A || {}),
                (this.tickmarkOffset = this.parameters.tickmarkOffset),
                (this.options = this.parameters.options),
                z(this, "init"),
                T || D || this.addLabel();
            }
            addLabel() {
              const p = this,
                g = p.axis;
              var T = g.options;
              const D = g.chart;
              var A = g.categories;
              const m = g.logarithmic,
                f = g.names,
                b = p.pos,
                y = h(p.options && p.options.labels, T.labels);
              var C = g.tickPositions;
              const o = b === C[0],
                r = b === C[C.length - 1],
                c = (!y.step || y.step === 1) && g.tickInterval === 1;
              C = C.info;
              let u = p.label,
                v,
                N,
                w;
              (A = this.parameters.category || (A ? h(A[b], f[b], b) : b)),
                m && S(A) && (A = G(m.lin2log(A))),
                g.dateTime &&
                  (C
                    ? ((N = D.time.resolveDTLFormat(
                        T.dateTimeLabelFormats[
                          (!T.grid && C.higherRanks[b]) || C.unitName
                        ]
                      )),
                      (v = N.main))
                    : S(A) &&
                      (v = g.dateTime.getXDateFormat(
                        A,
                        T.dateTimeLabelFormats || {}
                      ))),
                (p.isFirst = o),
                (p.isLast = r);
              const R = {
                axis: g,
                chart: D,
                dateTimeLabelFormat: v,
                isFirst: o,
                isLast: r,
                pos: b,
                tick: p,
                tickPositionInfo: C,
                value: A,
              };
              z(this, "labelFormat", R);
              const X = (K) =>
                y.formatter
                  ? y.formatter.call(K, K)
                  : y.format
                  ? ((K.text = g.defaultLabelFormatter.call(K, K)),
                    a.format(y.format, K, D))
                  : g.defaultLabelFormatter.call(K, K);
              T = X.call(R, R);
              const J = N && N.list;
              (p.shortenLabel = J
                ? function () {
                    for (w = 0; w < J.length; w++)
                      if (
                        (E(R, { dateTimeLabelFormat: J[w] }),
                        u.attr({ text: X.call(R, R) }),
                        u.getBBox().width < g.getSlotWidth(p) - 2 * y.padding)
                      )
                        return;
                    u.attr({ text: "" });
                  }
                : void 0),
                c && g._addedPlotLB && p.moveLabel(T, y),
                Y(u) || p.movedLabel
                  ? u &&
                    u.textStr !== T &&
                    !c &&
                    (!u.textWidth ||
                      y.style.width ||
                      u.styles.width ||
                      u.css({ width: null }),
                    u.attr({ text: T }),
                    (u.textPxLength = u.getBBox().width))
                  : ((p.label = u = p.createLabel({ x: 0, y: 0 }, T, y)),
                    (p.rotation = 0));
            }
            createLabel(p, g, T) {
              const D = this.axis,
                A = D.chart;
              return (
                (p =
                  Y(g) && T.enabled
                    ? A.renderer.text(g, p.x, p.y, T.useHTML).add(D.labelGroup)
                    : null) &&
                  (A.styledMode || p.css(x(T.style)),
                  (p.textPxLength = p.getBBox().width)),
                p
              );
            }
            destroy() {
              L(this, this.axis);
            }
            getPosition(p, g, T, D) {
              const A = this.axis,
                m = A.chart,
                f = (D && m.oldChartHeight) || m.chartHeight;
              return (
                (p = {
                  x: p
                    ? G(A.translate(g + T, void 0, void 0, D) + A.transB)
                    : A.left +
                      A.offset +
                      (A.opposite
                        ? ((D && m.oldChartWidth) || m.chartWidth) -
                          A.right -
                          A.left
                        : 0),
                  y: p
                    ? f - A.bottom + A.offset - (A.opposite ? A.height : 0)
                    : G(f - A.translate(g + T, void 0, void 0, D) - A.transB),
                }),
                (p.y = B(p.y, -1e5, 1e5)),
                z(this, "afterGetPosition", { pos: p }),
                p
              );
            }
            getLabelPosition(p, g, T, D, A, m, f, b) {
              const y = this.axis,
                C = y.transA,
                o =
                  y.isLinked && y.linkedParent
                    ? y.linkedParent.reversed
                    : y.reversed,
                r = y.staggerLines,
                c = y.tickRotCorr || { x: 0, y: 0 },
                u =
                  D || y.reserveSpaceDefault
                    ? 0
                    : -y.labelOffset * (y.labelAlign === "center" ? 0.5 : 1),
                v = A.distance,
                N = {};
              return (
                (T =
                  y.side === 0
                    ? T.rotation
                      ? -v
                      : -T.getBBox().height
                    : y.side === 2
                    ? c.y + v
                    : Math.cos(T.rotation * O) *
                      (c.y - T.getBBox(!1, 0).height / 2)),
                Y(A.y) && (T = y.side === 0 && y.horiz ? A.y + T : A.y),
                (p =
                  p +
                  h(A.x, [0, 1, 0, -1][y.side] * v) +
                  u +
                  c.x -
                  (m && D ? m * C * (o ? -1 : 1) : 0)),
                (g = g + T - (m && !D ? m * C * (o ? 1 : -1) : 0)),
                r &&
                  ((D = (f / (b || 1)) % r),
                  y.opposite && (D = r - D - 1),
                  (g += (y.labelOffset / r) * D)),
                (N.x = p),
                (N.y = Math.round(g)),
                z(this, "afterGetLabelPosition", {
                  pos: N,
                  tickmarkOffset: m,
                  index: f,
                }),
                N
              );
            }
            getLabelSize() {
              return this.label
                ? this.label.getBBox()[this.axis.horiz ? "height" : "width"]
                : 0;
            }
            getMarkPath(p, g, T, D, A, m) {
              return m.crispLine(
                [
                  ["M", p, g],
                  ["L", p + (A ? 0 : -T), g + (A ? T : 0)],
                ],
                D
              );
            }
            handleOverflow(p) {
              const g = this.axis,
                T = g.options.labels,
                D = p.x;
              var A = g.chart.chartWidth,
                m = g.chart.spacing;
              const f = h(g.labelLeft, Math.min(g.pos, m[3]));
              m = h(
                g.labelRight,
                Math.max(g.isRadial ? 0 : g.pos + g.len, A - m[1])
              );
              const b = this.label,
                y = this.rotation,
                C = { left: 0, center: 0.5, right: 1 }[
                  g.labelAlign || b.attr("align")
                ],
                o = b.getBBox().width,
                r = g.getSlotWidth(this),
                c = {};
              let u = r,
                v = 1,
                N;
              y || T.overflow !== "justify"
                ? 0 > y && D - C * o < f
                  ? (N = Math.round(D / Math.cos(y * O) - f))
                  : 0 < y &&
                    D + C * o > m &&
                    (N = Math.round((A - D) / Math.cos(y * O)))
                : ((A = D + (1 - C) * o),
                  D - C * o < f
                    ? (u = p.x + u * (1 - C) - f)
                    : A > m && ((u = m - p.x + u * C), (v = -1)),
                  (u = Math.min(r, u)),
                  u < r &&
                    g.labelAlign === "center" &&
                    (p.x += v * (r - u - C * (r - Math.min(o, u)))),
                  (o > u || (g.autoRotation && (b.styles || {}).width)) &&
                    (N = u)),
                N &&
                  (this.shortenLabel
                    ? this.shortenLabel()
                    : ((c.width = Math.floor(N) + "px"),
                      (T.style || {}).textOverflow ||
                        (c.textOverflow = "ellipsis"),
                      b.css(c)));
            }
            moveLabel(p, g) {
              const T = this;
              var D = T.label;
              const A = T.axis;
              let m = !1;
              D && D.textStr === p
                ? ((T.movedLabel = D), (m = !0), delete T.label)
                : P(A.ticks, function (f) {
                    m ||
                      f.isNew ||
                      f === T ||
                      !f.label ||
                      f.label.textStr !== p ||
                      ((T.movedLabel = f.label),
                      (m = !0),
                      (f.labelPos = T.movedLabel.xy),
                      delete f.label);
                  }),
                m ||
                  (!T.labelPos && !D) ||
                  ((D = T.labelPos || D.xy),
                  (T.movedLabel = T.createLabel(D, p, g)),
                  T.movedLabel && T.movedLabel.attr({ opacity: 0 }));
            }
            render(p, g, T) {
              var D = this.axis,
                A = D.horiz,
                m = this.pos,
                f = h(this.tickmarkOffset, D.tickmarkOffset);
              (m = this.getPosition(A, m, f, g)), (f = m.x);
              const b = m.y;
              (D = (A && f === D.pos + D.len) || (!A && b === D.pos) ? -1 : 1),
                (A = h(T, this.label && this.label.newOpacity, 1)),
                (T = h(T, 1)),
                (this.isActive = !0),
                this.renderGridLine(g, T, D),
                this.renderMark(m, T, D),
                this.renderLabel(m, g, A, p),
                (this.isNew = !1),
                z(this, "afterRender");
            }
            renderGridLine(p, g, T) {
              const D = this.axis,
                A = D.options,
                m = {},
                f = this.pos,
                b = this.type,
                y = h(this.tickmarkOffset, D.tickmarkOffset),
                C = D.chart.renderer;
              let o = this.gridLine,
                r = A.gridLineWidth,
                c = A.gridLineColor,
                u = A.gridLineDashStyle;
              this.type === "minor" &&
                ((r = A.minorGridLineWidth),
                (c = A.minorGridLineColor),
                (u = A.minorGridLineDashStyle)),
                o ||
                  (D.chart.styledMode ||
                    ((m.stroke = c),
                    (m["stroke-width"] = r || 0),
                    (m.dashstyle = u)),
                  b || (m.zIndex = 1),
                  p && (g = 0),
                  (this.gridLine = o =
                    C.path()
                      .attr(m)
                      .addClass(
                        "highcharts-" + (b ? b + "-" : "") + "grid-line"
                      )
                      .add(D.gridGroup))),
                o &&
                  (T = D.getPlotLinePath({
                    value: f + y,
                    lineWidth: o.strokeWidth() * T,
                    force: "pass",
                    old: p,
                    acrossPanes: !1,
                  })) &&
                  o[p || this.isNew ? "attr" : "animate"]({ d: T, opacity: g });
            }
            renderMark(p, g, T) {
              const D = this.axis;
              var A = D.options;
              const m = D.chart.renderer,
                f = this.type,
                b = D.tickSize(f ? f + "Tick" : "tick"),
                y = p.x;
              p = p.y;
              const C = h(
                A[f !== "minor" ? "tickWidth" : "minorTickWidth"],
                !f && D.isXAxis ? 1 : 0
              );
              A = A[f !== "minor" ? "tickColor" : "minorTickColor"];
              let o = this.mark;
              const r = !o;
              b &&
                (D.opposite && (b[0] = -b[0]),
                o ||
                  ((this.mark = o =
                    m
                      .path()
                      .addClass("highcharts-" + (f ? f + "-" : "") + "tick")
                      .add(D.axisGroup)),
                  D.chart.styledMode ||
                    o.attr({ stroke: A, "stroke-width": C })),
                o[r ? "attr" : "animate"]({
                  d: this.getMarkPath(
                    y,
                    p,
                    b[0],
                    o.strokeWidth() * T,
                    D.horiz,
                    m
                  ),
                  opacity: g,
                }));
            }
            renderLabel(p, g, T, D) {
              var A = this.axis;
              const m = A.horiz,
                f = A.options,
                b = this.label,
                y = f.labels,
                C = y.step;
              A = h(this.tickmarkOffset, A.tickmarkOffset);
              const o = p.x;
              p = p.y;
              let r = !0;
              b &&
                S(o) &&
                ((b.xy = p = this.getLabelPosition(o, p, b, m, y, A, D, C)),
                (this.isFirst && !this.isLast && !f.showFirstLabel) ||
                (this.isLast && !this.isFirst && !f.showLastLabel)
                  ? (r = !1)
                  : !m ||
                    y.step ||
                    y.rotation ||
                    g ||
                    T === 0 ||
                    this.handleOverflow(p),
                C && D % C && (r = !1),
                r && S(p.y)
                  ? ((p.opacity = T),
                    b[this.isNewLabel ? "attr" : "animate"](p).show(!0),
                    (this.isNewLabel = !1))
                  : (b.hide(), (this.isNewLabel = !0)));
            }
            replaceMovedLabel() {
              const p = this.label,
                g = this.axis;
              p &&
                !this.isNew &&
                (p.animate({ opacity: 0 }, void 0, p.destroy),
                delete this.label),
                (g.isDirty = !0),
                (this.label = this.movedLabel),
                delete this.movedLabel;
            }
          }
          return s;
        }
      ),
      n(
        i,
        "Core/Axis/Axis.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Axis/AxisDefaults.js"],
          i["Core/Color/Color.js"],
          i["Core/Defaults.js"],
          i["Core/Foundation.js"],
          i["Core/Globals.js"],
          i["Core/Axis/Tick.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G, Y, L) {
          const { animObject: E } = a,
            { defaultOptions: z } = O,
            { registerEventOptions: S } = B,
            { deg2rad: x } = G,
            {
              arrayMax: P,
              arrayMin: h,
              clamp: s,
              correctFloat: l,
              defined: p,
              destroyObjectProperties: g,
              erase: T,
              error: D,
              extend: A,
              fireEvent: m,
              getClosestDistance: f,
              insertItem: b,
              isArray: y,
              isNumber: C,
              isString: o,
              merge: r,
              normalizeTickInterval: c,
              objectEach: u,
              pick: v,
              relativeLength: N,
              removeEvent: w,
              splat: R,
              syncTimeout: X,
            } = L,
            J = (H, k) =>
              c(
                k,
                void 0,
                void 0,
                v(H.options.allowDecimals, 0.5 > k || H.tickAmount !== void 0),
                !!H.tickAmount
              );
          class K {
            constructor(k, U, _) {
              (this.zoomEnabled =
                this.width =
                this.visible =
                this.userOptions =
                this.translationSlope =
                this.transB =
                this.transA =
                this.top =
                this.ticks =
                this.tickRotCorr =
                this.tickPositions =
                this.tickmarkOffset =
                this.tickInterval =
                this.tickAmount =
                this.side =
                this.series =
                this.right =
                this.positiveValuesOnly =
                this.pos =
                this.pointRangePadding =
                this.pointRange =
                this.plotLinesAndBandsGroups =
                this.plotLinesAndBands =
                this.paddedTicks =
                this.overlap =
                this.options =
                this.offset =
                this.names =
                this.minPixelPadding =
                this.minorTicks =
                this.minorTickInterval =
                this.min =
                this.maxLabelLength =
                this.max =
                this.len =
                this.left =
                this.labelFormatter =
                this.labelEdge =
                this.isLinked =
                this.index =
                this.height =
                this.hasVisibleSeries =
                this.hasNames =
                this.eventOptions =
                this.coll =
                this.closestPointRange =
                this.chart =
                this.bottom =
                this.alternateBands =
                  void 0),
                this.init(k, U, _);
            }
            init(k, U, _ = this.coll) {
              const W = _ === "xAxis";
              (this.chart = k),
                (this.horiz = this.isZAxis || (k.inverted ? !W : W)),
                (this.isXAxis = W),
                (this.coll = _),
                m(this, "init", { userOptions: U }),
                (this.opposite = v(U.opposite, this.opposite)),
                (this.side = v(
                  U.side,
                  this.side,
                  this.horiz ? (this.opposite ? 0 : 2) : this.opposite ? 1 : 3
                )),
                this.setOptions(U),
                (_ = this.options);
              const tt = _.labels,
                j = _.type;
              (this.userOptions = U),
                (this.minPixelPadding = 0),
                (this.reversed = v(_.reversed, this.reversed)),
                (this.visible = _.visible),
                (this.zoomEnabled = _.zoomEnabled),
                (this.hasNames = j === "category" || _.categories === !0),
                (this.categories =
                  _.categories || (this.hasNames ? [] : void 0)),
                this.names || ((this.names = []), (this.names.keys = {})),
                (this.plotLinesAndBandsGroups = {}),
                (this.positiveValuesOnly = !!this.logarithmic),
                (this.isLinked = p(_.linkedTo)),
                (this.ticks = {}),
                (this.labelEdge = []),
                (this.minorTicks = {}),
                (this.plotLinesAndBands = []),
                (this.alternateBands = {}),
                (this.len = 0),
                (this.minRange = this.userMinRange = _.minRange || _.maxZoom),
                (this.range = _.range),
                (this.offset = _.offset || 0),
                (this.min = this.max = null),
                (U = v(
                  _.crosshair,
                  R(k.options.tooltip.crosshairs)[W ? 0 : 1]
                )),
                (this.crosshair = U === !0 ? {} : U),
                k.axes.indexOf(this) === -1 &&
                  (W
                    ? k.axes.splice(k.xAxis.length, 0, this)
                    : k.axes.push(this),
                  b(this, k[this.coll])),
                k.orderItems(this.coll),
                (this.series = this.series || []),
                k.inverted &&
                  !this.isZAxis &&
                  W &&
                  typeof this.reversed > "u" &&
                  (this.reversed = !0),
                (this.labelRotation = C(tt.rotation) ? tt.rotation : void 0),
                S(this, _),
                m(this, "afterInit");
            }
            setOptions(k) {
              (this.options = r(
                d.defaultXAxisOptions,
                this.coll === "yAxis" && d.defaultYAxisOptions,
                [
                  d.defaultTopAxisOptions,
                  d.defaultRightAxisOptions,
                  d.defaultBottomAxisOptions,
                  d.defaultLeftAxisOptions,
                ][this.side],
                r(z[this.coll], k)
              )),
                m(this, "afterSetOptions", { userOptions: k });
            }
            defaultLabelFormatter(k) {
              var U = this.axis;
              ({ numberFormatter: k } = this.chart);
              const _ = C(this.value) ? this.value : NaN,
                W = U.chart.time,
                tt = this.dateTimeLabelFormat;
              var j = z.lang;
              const I = j.numericSymbols;
              j = j.numericSymbolMagnitude || 1e3;
              const F = U.logarithmic ? Math.abs(_) : U.tickInterval;
              let V = I && I.length,
                Q;
              if (U.categories) Q = `${this.value}`;
              else if (tt) Q = W.dateFormat(tt, _);
              else if (V && 1e3 <= F)
                for (; V-- && typeof Q > "u"; )
                  (U = Math.pow(j, V + 1)),
                    F >= U &&
                      (10 * _) % U === 0 &&
                      I[V] !== null &&
                      _ !== 0 &&
                      (Q = k(_ / U, -1) + I[V]);
              return (
                typeof Q > "u" &&
                  (Q = 1e4 <= Math.abs(_) ? k(_, -1) : k(_, -1, void 0, "")),
                Q
              );
            }
            getSeriesExtremes() {
              const k = this,
                U = k.chart;
              let _;
              m(this, "getSeriesExtremes", null, function () {
                (k.hasVisibleSeries = !1),
                  (k.dataMin = k.dataMax = k.threshold = null),
                  (k.softThreshold = !k.isXAxis),
                  k.series.forEach(function (W) {
                    if (W.visible || !U.options.chart.ignoreHiddenSeries) {
                      var tt = W.options;
                      let j = tt.threshold,
                        I,
                        F;
                      (k.hasVisibleSeries = !0),
                        k.positiveValuesOnly && 0 >= j && (j = null),
                        k.isXAxis
                          ? (tt = W.xData) &&
                            tt.length &&
                            ((tt = k.logarithmic
                              ? tt.filter((V) => 0 < V)
                              : tt),
                            (_ = W.getXExtremes(tt)),
                            (I = _.min),
                            (F = _.max),
                            C(I) ||
                              I instanceof Date ||
                              ((tt = tt.filter(C)),
                              (_ = W.getXExtremes(tt)),
                              (I = _.min),
                              (F = _.max)),
                            tt.length &&
                              ((k.dataMin = Math.min(v(k.dataMin, I), I)),
                              (k.dataMax = Math.max(v(k.dataMax, F), F))))
                          : ((W = W.applyExtremes()),
                            C(W.dataMin) &&
                              ((I = W.dataMin),
                              (k.dataMin = Math.min(v(k.dataMin, I), I))),
                            C(W.dataMax) &&
                              ((F = W.dataMax),
                              (k.dataMax = Math.max(v(k.dataMax, F), F))),
                            p(j) && (k.threshold = j),
                            (!tt.softThreshold || k.positiveValuesOnly) &&
                              (k.softThreshold = !1));
                    }
                  });
              }),
                m(this, "afterGetSeriesExtremes");
            }
            translate(k, U, _, W, tt, j) {
              const I = this.linkedParent || this,
                F = W && I.old ? I.old.min : I.min;
              if (!C(F)) return NaN;
              const V = I.minPixelPadding;
              tt =
                (I.isOrdinal ||
                  (I.brokenAxis && I.brokenAxis.hasBreaks) ||
                  (I.logarithmic && tt)) &&
                I.lin2val;
              let Q = 1,
                $ = 0;
              return (
                (W = W && I.old ? I.old.transA : I.transA),
                W || (W = I.transA),
                _ && ((Q *= -1), ($ = I.len)),
                I.reversed && ((Q *= -1), ($ -= Q * (I.sector || I.len))),
                U
                  ? ((j = (k * Q + $ - V) / W + F), tt && (j = I.lin2val(j)))
                  : (tt && (k = I.val2lin(k)),
                    (k = Q * (k - F) * W),
                    (j =
                      (I.isRadial ? k : l(k)) +
                      $ +
                      Q * V +
                      (C(j) ? W * j : 0))),
                j
              );
            }
            toPixels(k, U) {
              return (
                this.translate(k, !1, !this.horiz, void 0, !0) +
                (U ? 0 : this.pos)
              );
            }
            toValue(k, U) {
              return this.translate(
                k - (U ? 0 : this.pos),
                !0,
                !this.horiz,
                void 0,
                !0
              );
            }
            getPlotLinePath(k) {
              function U(it, rt, ht) {
                return (
                  ot !== "pass" &&
                    (it < rt || it > ht) &&
                    (ot ? (it = s(it, rt, ht)) : (nt = !0)),
                  it
                );
              }
              const _ = this,
                W = _.chart,
                tt = _.left,
                j = _.top,
                I = k.old,
                F = k.value,
                V = k.lineWidth,
                Q = (I && W.oldChartHeight) || W.chartHeight,
                $ = (I && W.oldChartWidth) || W.chartWidth,
                et = _.transB;
              let st = k.translatedValue,
                ot = k.force,
                at,
                lt,
                Z,
                q,
                nt;
              return (
                (k = {
                  value: F,
                  lineWidth: V,
                  old: I,
                  force: ot,
                  acrossPanes: k.acrossPanes,
                  translatedValue: st,
                }),
                m(this, "getPlotLinePath", k, function (it) {
                  (st = v(st, _.translate(F, void 0, void 0, I))),
                    (st = s(st, -1e5, 1e5)),
                    (at = Z = Math.round(st + et)),
                    (lt = q = Math.round(Q - st - et)),
                    C(st)
                      ? _.horiz
                        ? ((lt = j),
                          (q = Q - _.bottom),
                          (at = Z = U(at, tt, tt + _.width)))
                        : ((at = tt),
                          (Z = $ - _.right),
                          (lt = q = U(lt, j, j + _.height)))
                      : ((nt = !0), (ot = !1)),
                    (it.path =
                      nt && !ot
                        ? null
                        : W.renderer.crispLine(
                            [
                              ["M", at, lt],
                              ["L", Z, q],
                            ],
                            V || 1
                          ));
                }),
                k.path
              );
            }
            getLinearTickPositions(k, U, _) {
              const W = l(Math.floor(U / k) * k);
              _ = l(Math.ceil(_ / k) * k);
              const tt = [];
              let j, I;
              if ((l(W + k) === W && (I = 20), this.single)) return [U];
              for (U = W; U <= _ && (tt.push(U), (U = l(U + k, I)), U !== j); )
                j = U;
              return tt;
            }
            getMinorTickInterval() {
              const k = this.options;
              return k.minorTicks === !0
                ? v(k.minorTickInterval, "auto")
                : k.minorTicks === !1
                ? null
                : k.minorTickInterval;
            }
            getMinorTickPositions() {
              var k = this.options;
              const U = this.tickPositions,
                _ = this.minorTickInterval;
              var W = this.pointRangePadding || 0;
              const tt = this.min - W;
              W = this.max + W;
              const j = W - tt;
              let I = [];
              if (j && j / _ < this.len / 3) {
                const F = this.logarithmic;
                if (F)
                  this.paddedTicks.forEach(function (V, Q, $) {
                    Q &&
                      I.push.apply(
                        I,
                        F.getLogTickPositions(_, $[Q - 1], $[Q], !0)
                      );
                  });
                else if (
                  this.dateTime &&
                  this.getMinorTickInterval() === "auto"
                )
                  I = I.concat(
                    this.getTimeTicks(
                      this.dateTime.normalizeTimeTickInterval(_),
                      tt,
                      W,
                      k.startOfWeek
                    )
                  );
                else
                  for (k = tt + ((U[0] - tt) % _); k <= W && k !== I[0]; k += _)
                    I.push(k);
              }
              return I.length !== 0 && this.trimTicks(I), I;
            }
            adjustForMinRange() {
              const k = this.options,
                U = this.logarithmic;
              let _ = this.min;
              var W = this.max;
              let tt, j;
              if (this.isXAxis && typeof this.minRange > "u" && !U)
                if (p(k.min) || p(k.max) || p(k.floor) || p(k.ceiling))
                  this.minRange = null;
                else {
                  var I =
                    f(
                      this.series.map((F) => {
                        var V;
                        return (
                          (F.xIncrement
                            ? (V = F.xData) === null || V === void 0
                              ? void 0
                              : V.slice(0, 2)
                            : F.xData) || []
                        );
                      })
                    ) || 0;
                  this.minRange = Math.min(5 * I, this.dataMax - this.dataMin);
                }
              W - _ < this.minRange &&
                ((I = this.dataMax - this.dataMin >= this.minRange),
                (j = this.minRange),
                (W = (j - W + _) / 2),
                (tt = [_ - W, v(k.min, _ - W)]),
                I && (tt[2] = U ? U.log2lin(this.dataMin) : this.dataMin),
                (_ = P(tt)),
                (W = [_ + j, v(k.max, _ + j)]),
                I && (W[2] = U ? U.log2lin(this.dataMax) : this.dataMax),
                (W = h(W)),
                W - _ < j &&
                  ((tt[0] = W - j), (tt[1] = v(k.min, W - j)), (_ = P(tt)))),
                (this.min = _),
                (this.max = W);
            }
            getClosest() {
              let k, U;
              if (this.categories) U = 1;
              else {
                const _ = [];
                this.series.forEach(function (W) {
                  var tt;
                  const j = W.closestPointRange,
                    I = W.visible || !W.chart.options.chart.ignoreHiddenSeries;
                  ((tt = W.xData) === null || tt === void 0
                    ? void 0
                    : tt.length) === 1
                    ? _.push(W.xData[0])
                    : !W.noSharedTooltip &&
                      p(j) &&
                      I &&
                      (U = p(U) ? Math.min(U, j) : j);
                }),
                  _.length && (_.sort((W, tt) => W - tt), (k = f([_])));
              }
              return k && U ? Math.min(k, U) : k || U;
            }
            nameToX(k) {
              const U = y(this.options.categories),
                _ = U ? this.categories : this.names;
              let W = k.options.x,
                tt;
              return (
                (k.series.requireSorting = !1),
                p(W) ||
                  (W =
                    this.options.uniqueNames && _
                      ? U
                        ? _.indexOf(k.name)
                        : v(_.keys[k.name], -1)
                      : k.series.autoIncrement()),
                W === -1 ? !U && _ && (tt = _.length) : (tt = W),
                typeof tt < "u"
                  ? ((this.names[tt] = k.name), (this.names.keys[k.name] = tt))
                  : k.x && (tt = k.x),
                tt
              );
            }
            updateNames() {
              const k = this,
                U = this.names;
              0 < U.length &&
                (Object.keys(U.keys).forEach(function (_) {
                  delete U.keys[_];
                }),
                (U.length = 0),
                (this.minRange = this.userMinRange),
                (this.series || []).forEach(function (_) {
                  (_.xIncrement = null),
                    (!_.points || _.isDirtyData) &&
                      ((k.max = Math.max(k.max, _.xData.length - 1)),
                      _.processData(),
                      _.generatePoints()),
                    _.data.forEach(function (W, tt) {
                      let j;
                      W &&
                        W.options &&
                        typeof W.name < "u" &&
                        ((j = k.nameToX(W)),
                        typeof j < "u" &&
                          j !== W.x &&
                          ((W.x = j), (_.xData[tt] = j)));
                    });
                }));
            }
            setAxisTranslation() {
              const k = this,
                U = k.max - k.min;
              var _ = k.linkedParent;
              const W = !!k.categories,
                tt = k.isXAxis;
              let j = k.axisPointRange || 0,
                I,
                F = 0,
                V = 0,
                Q = k.transA;
              (tt || W || j) &&
                ((I = k.getClosest()),
                _
                  ? ((F = _.minPointOffset), (V = _.pointRangePadding))
                  : k.series.forEach(function ($) {
                      const et = W
                          ? 1
                          : tt
                          ? v($.options.pointRange, I, 0)
                          : k.axisPointRange || 0,
                        st = $.options.pointPlacement;
                      (j = Math.max(j, et)),
                        (!k.single || W) &&
                          (($ = $.is("xrange") ? !tt : tt),
                          (F = Math.max(F, $ && o(st) ? 0 : et / 2)),
                          (V = Math.max(V, $ && st === "on" ? 0 : et)));
                    }),
                (_ =
                  k.ordinal && k.ordinal.slope && I ? k.ordinal.slope / I : 1),
                (k.minPointOffset = F *= _),
                (k.pointRangePadding = V *= _),
                (k.pointRange = Math.min(j, k.single && W ? 1 : U)),
                tt && I && (k.closestPointRange = I)),
                (k.translationSlope =
                  k.transA =
                  Q =
                    k.staticScale || k.len / (U + V || 1)),
                (k.transB = k.horiz ? k.left : k.bottom),
                (k.minPixelPadding = Q * F),
                m(this, "afterSetAxisTranslation");
            }
            minFromRange() {
              return this.max - this.range;
            }
            setTickInterval(k) {
              var U = this.chart;
              const _ = this.logarithmic,
                W = this.options,
                tt = this.isXAxis,
                j = this.isLinked,
                I = W.tickPixelInterval,
                F = this.categories,
                V = this.softThreshold;
              let Q = W.maxPadding,
                $ = W.minPadding,
                et =
                  C(W.tickInterval) && 0 <= W.tickInterval
                    ? W.tickInterval
                    : void 0,
                st = C(this.threshold) ? this.threshold : null,
                ot,
                at,
                lt;
              if (
                (this.dateTime || F || j || this.getTickAmount(),
                (at = v(this.userMin, W.min)),
                (lt = v(this.userMax, W.max)),
                j)
              ) {
                this.linkedParent = U[this.coll][W.linkedTo];
                var Z = this.linkedParent.getExtremes();
                (this.min = v(Z.min, Z.dataMin)),
                  (this.max = v(Z.max, Z.dataMax)),
                  W.type !== this.linkedParent.options.type && D(11, 1, U);
              } else
                V &&
                  p(st) &&
                  (this.dataMin >= st
                    ? ((Z = st), ($ = 0))
                    : this.dataMax <= st && ((ot = st), (Q = 0))),
                  (this.min = v(at, Z, this.dataMin)),
                  (this.max = v(lt, ot, this.dataMax));
              if (
                (_ &&
                  (this.positiveValuesOnly &&
                    !k &&
                    0 >= Math.min(this.min, v(this.dataMin, this.min)) &&
                    D(10, 1, U),
                  (this.min = l(_.log2lin(this.min), 16)),
                  (this.max = l(_.log2lin(this.max), 16))),
                this.range &&
                  p(this.max) &&
                  ((this.userMin =
                    this.min =
                    at =
                      Math.max(this.dataMin, this.minFromRange())),
                  (this.userMax = lt = this.max),
                  (this.range = null)),
                m(this, "foundExtremes"),
                this.beforePadding && this.beforePadding(),
                this.adjustForMinRange(),
                !C(this.userMin) &&
                  C(W.softMin) &&
                  W.softMin < this.min &&
                  (this.min = at = W.softMin),
                !C(this.userMax) &&
                  C(W.softMax) &&
                  W.softMax > this.max &&
                  (this.max = lt = W.softMax),
                !(
                  F ||
                  this.axisPointRange ||
                  (this.stacking && this.stacking.usePercentage) ||
                  j
                ) &&
                  p(this.min) &&
                  p(this.max) &&
                  (U = this.max - this.min) &&
                  (!p(at) && $ && (this.min -= U * $),
                  !p(lt) && Q && (this.max += U * Q)),
                !C(this.userMin) &&
                  C(W.floor) &&
                  (this.min = Math.max(this.min, W.floor)),
                !C(this.userMax) &&
                  C(W.ceiling) &&
                  (this.max = Math.min(this.max, W.ceiling)),
                V &&
                  p(this.dataMin) &&
                  ((st = st || 0),
                  !p(at) && this.min < st && this.dataMin >= st
                    ? (this.min = this.options.minRange
                        ? Math.min(st, this.max - this.minRange)
                        : st)
                    : !p(lt) &&
                      this.max > st &&
                      this.dataMax <= st &&
                      (this.max = this.options.minRange
                        ? Math.max(st, this.min + this.minRange)
                        : st)),
                C(this.min) &&
                  C(this.max) &&
                  !this.chart.polar &&
                  this.min > this.max &&
                  (p(this.options.min)
                    ? (this.max = this.min)
                    : p(this.options.max) && (this.min = this.max)),
                (this.tickInterval =
                  this.min === this.max ||
                  typeof this.min > "u" ||
                  typeof this.max > "u"
                    ? 1
                    : j &&
                      this.linkedParent &&
                      !et &&
                      I === this.linkedParent.options.tickPixelInterval
                    ? (et = this.linkedParent.tickInterval)
                    : v(
                        et,
                        this.tickAmount
                          ? (this.max - this.min) /
                              Math.max(this.tickAmount - 1, 1)
                          : void 0,
                        F
                          ? 1
                          : ((this.max - this.min) * I) / Math.max(this.len, I)
                      )),
                tt && !k)
              ) {
                const q =
                  this.min !== (this.old && this.old.min) ||
                  this.max !== (this.old && this.old.max);
                this.series.forEach(function (nt) {
                  (nt.forceCrop = nt.forceCropping && nt.forceCropping()),
                    nt.processData(q);
                }),
                  m(this, "postProcessData", { hasExtremesChanged: q });
              }
              this.setAxisTranslation(),
                m(this, "initialAxisTranslation"),
                this.pointRange &&
                  !et &&
                  (this.tickInterval = Math.max(
                    this.pointRange,
                    this.tickInterval
                  )),
                (k = v(
                  W.minTickInterval,
                  this.dateTime && !this.series.some((q) => q.noSharedTooltip)
                    ? this.closestPointRange
                    : 0
                )),
                !et && this.tickInterval < k && (this.tickInterval = k),
                this.dateTime ||
                  this.logarithmic ||
                  et ||
                  (this.tickInterval = J(this, this.tickInterval)),
                this.tickAmount || (this.tickInterval = this.unsquish()),
                this.setTickPositions();
            }
            setTickPositions() {
              var k = this.options;
              const U = k.tickPositions,
                _ = k.tickPositioner;
              var W = this.getMinorTickInterval(),
                tt = this.hasVerticalPanning(),
                j = this.coll === "colorAxis";
              const I = (j || !tt) && k.startOnTick;
              (tt = (j || !tt) && k.endOnTick), (j = []);
              let F;
              if (
                ((this.tickmarkOffset =
                  this.categories &&
                  k.tickmarkPlacement === "between" &&
                  this.tickInterval === 1
                    ? 0.5
                    : 0),
                (this.minorTickInterval =
                  W === "auto" && this.tickInterval
                    ? this.tickInterval / k.minorTicksPerMajor
                    : W),
                (this.single =
                  this.min === this.max &&
                  p(this.min) &&
                  !this.tickAmount &&
                  (parseInt(this.min, 10) === this.min ||
                    k.allowDecimals !== !1)),
                U)
              )
                j = U.slice();
              else if (C(this.min) && C(this.max)) {
                if (
                  (this.ordinal && this.ordinal.positions) ||
                  !(
                    (this.max - this.min) / this.tickInterval >
                    Math.max(2 * this.len, 200)
                  )
                )
                  if (this.dateTime)
                    j = this.getTimeTicks(
                      this.dateTime.normalizeTimeTickInterval(
                        this.tickInterval,
                        k.units
                      ),
                      this.min,
                      this.max,
                      k.startOfWeek,
                      this.ordinal && this.ordinal.positions,
                      this.closestPointRange,
                      !0
                    );
                  else if (this.logarithmic)
                    j = this.logarithmic.getLogTickPositions(
                      this.tickInterval,
                      this.min,
                      this.max
                    );
                  else
                    for (
                      W = k = this.tickInterval;
                      W <= 2 * k &&
                      ((j = this.getLinearTickPositions(
                        this.tickInterval,
                        this.min,
                        this.max
                      )),
                      this.tickAmount && j.length > this.tickAmount);

                    )
                      this.tickInterval = J(this, (W *= 1.1));
                else (j = [this.min, this.max]), D(19, !1, this.chart);
                j.length > this.len &&
                  ((j = [j[0], j[j.length - 1]]),
                  j[0] === j[1] && (j.length = 1)),
                  _ &&
                    ((this.tickPositions = j),
                    (F = _.apply(this, [this.min, this.max])) && (j = F));
              }
              (this.tickPositions = j),
                (this.paddedTicks = j.slice(0)),
                this.trimTicks(j, I, tt),
                !this.isLinked &&
                  C(this.min) &&
                  C(this.max) &&
                  (this.single &&
                    2 > j.length &&
                    !this.categories &&
                    !this.series.some(
                      (V) =>
                        V.is("heatmap") &&
                        V.options.pointPlacement === "between"
                    ) &&
                    ((this.min -= 0.5), (this.max += 0.5)),
                  U || F || this.adjustTickAmount()),
                m(this, "afterSetTickPositions");
            }
            trimTicks(k, U, _) {
              const W = k[0],
                tt = k[k.length - 1],
                j = (!this.isOrdinal && this.minPointOffset) || 0;
              if ((m(this, "trimTicks"), !this.isLinked)) {
                if (U && W !== -1 / 0) this.min = W;
                else for (; this.min - j > k[0]; ) k.shift();
                if (_) this.max = tt;
                else for (; this.max + j < k[k.length - 1]; ) k.pop();
                k.length === 0 &&
                  p(W) &&
                  !this.options.tickPositions &&
                  k.push((tt + W) / 2);
              }
            }
            alignToOthers() {
              const k = this,
                U = [this],
                _ = k.options,
                W =
                  this.coll === "yAxis" &&
                  this.chart.options.chart.alignThresholds,
                tt = [];
              let j;
              if (
                ((k.thresholdAlignment = void 0),
                ((this.chart.options.chart.alignTicks !== !1 && _.alignTicks) ||
                  W) &&
                  _.startOnTick !== !1 &&
                  _.endOnTick !== !1 &&
                  !k.logarithmic)
              ) {
                const I = (V) => {
                    const { horiz: Q, options: $ } = V;
                    return [
                      Q ? $.left : $.top,
                      $.width,
                      $.height,
                      $.pane,
                    ].join();
                  },
                  F = I(this);
                this.chart[this.coll].forEach(function (V) {
                  const { series: Q } = V;
                  Q.length &&
                    Q.some(($) => $.visible) &&
                    V !== k &&
                    I(V) === F &&
                    ((j = !0), U.push(V));
                });
              }
              if (j && W) {
                U.forEach((F) => {
                  (F = F.getThresholdAlignment(k)), C(F) && tt.push(F);
                });
                const I =
                  1 < tt.length
                    ? tt.reduce((F, V) => F + V, 0) / tt.length
                    : void 0;
                U.forEach((F) => {
                  F.thresholdAlignment = I;
                });
              }
              return j;
            }
            getThresholdAlignment(k) {
              if (
                ((!C(this.dataMin) ||
                  (this !== k &&
                    this.series.some((U) => U.isDirty || U.isDirtyData))) &&
                  this.getSeriesExtremes(),
                C(this.threshold))
              )
                return (
                  (k = s(
                    (this.threshold - (this.dataMin || 0)) /
                      ((this.dataMax || 0) - (this.dataMin || 0)),
                    0,
                    1
                  )),
                  this.options.reversed && (k = 1 - k),
                  k
                );
            }
            getTickAmount() {
              const k = this.options,
                U = k.tickPixelInterval;
              let _ = k.tickAmount;
              !p(k.tickInterval) &&
                !_ &&
                this.len < U &&
                !this.isRadial &&
                !this.logarithmic &&
                k.startOnTick &&
                k.endOnTick &&
                (_ = 2),
                !_ && this.alignToOthers() && (_ = Math.ceil(this.len / U) + 1),
                4 > _ && ((this.finalTickAmt = _), (_ = 5)),
                (this.tickAmount = _);
            }
            adjustTickAmount() {
              const k = this,
                {
                  finalTickAmt: U,
                  max: _,
                  min: W,
                  options: tt,
                  tickPositions: j,
                  tickAmount: I,
                  thresholdAlignment: F,
                } = k,
                V = j && j.length;
              var Q = v(k.threshold, k.softThreshold ? 0 : null),
                $ = k.tickInterval;
              let et;
              if (
                (C(F) &&
                  ((et =
                    0.5 > F ? Math.ceil(F * (I - 1)) : Math.floor(F * (I - 1))),
                  tt.reversed && (et = I - 1 - et)),
                k.hasData() && C(W) && C(_))
              ) {
                const st = () => {
                  (k.transA *= (V - 1) / (I - 1)),
                    (k.min = tt.startOnTick ? j[0] : Math.min(W, j[0])),
                    (k.max = tt.endOnTick
                      ? j[j.length - 1]
                      : Math.max(_, j[j.length - 1]));
                };
                if (C(et) && C(k.threshold)) {
                  for (
                    ;
                    j[et] !== Q ||
                    j.length !== I ||
                    j[0] > W ||
                    j[j.length - 1] < _;

                  ) {
                    for (j.length = 0, j.push(k.threshold); j.length < I; )
                      j[et] === void 0 || j[et] > k.threshold
                        ? j.unshift(l(j[0] - $))
                        : j.push(l(j[j.length - 1] + $));
                    if ($ > 8 * k.tickInterval) break;
                    $ *= 2;
                  }
                  st();
                } else if (V < I) {
                  for (; j.length < I; )
                    j.length % 2 || W === Q
                      ? j.push(l(j[j.length - 1] + $))
                      : j.unshift(l(j[0] - $));
                  st();
                }
                if (p(U)) {
                  for ($ = Q = j.length; $--; )
                    ((U === 3 && $ % 2 === 1) ||
                      (2 >= U && 0 < $ && $ < Q - 1)) &&
                      j.splice($, 1);
                  k.finalTickAmt = void 0;
                }
              }
            }
            setScale() {
              let k = !1,
                U = !1;
              this.series.forEach(function (W) {
                (k = k || W.isDirtyData || W.isDirty),
                  (U = U || (W.xAxis && W.xAxis.isDirty) || !1);
              }),
                this.setAxisSize();
              const _ = this.len !== (this.old && this.old.len);
              _ ||
              k ||
              U ||
              this.isLinked ||
              this.forceRedraw ||
              this.userMin !== (this.old && this.old.userMin) ||
              this.userMax !== (this.old && this.old.userMax) ||
              this.alignToOthers()
                ? (this.stacking &&
                    (this.stacking.resetStacks(), this.stacking.buildStacks()),
                  (this.forceRedraw = !1),
                  this.userMinRange || (this.minRange = void 0),
                  this.getSeriesExtremes(),
                  this.setTickInterval(),
                  this.isDirty ||
                    (this.isDirty =
                      _ ||
                      this.min !== (this.old && this.old.min) ||
                      this.max !== (this.old && this.old.max)))
                : this.stacking && this.stacking.cleanStacks(),
                k && this.panningState && (this.panningState.isDirty = !0),
                m(this, "afterSetScale");
            }
            setExtremes(k, U, _, W, tt) {
              const j = this,
                I = j.chart;
              (_ = v(_, !0)),
                j.series.forEach(function (F) {
                  delete F.kdTree;
                }),
                (tt = A(tt, { min: k, max: U })),
                m(j, "setExtremes", tt, function () {
                  (j.userMin = k),
                    (j.userMax = U),
                    (j.eventArgs = tt),
                    _ && I.redraw(W);
                });
            }
            zoom(k, U) {
              const _ = this,
                W = this.dataMin,
                tt = this.dataMax,
                j = this.options,
                I = Math.min(W, v(j.min, W)),
                F = Math.max(tt, v(j.max, tt));
              return (
                (k = { newMin: k, newMax: U }),
                m(this, "zoom", k, function (V) {
                  let Q = V.newMin,
                    $ = V.newMax;
                  (Q !== _.min || $ !== _.max) &&
                    (_.allowZoomOutside ||
                      (p(W) && (Q < I && (Q = I), Q > F && (Q = F)),
                      p(tt) && ($ < I && ($ = I), $ > F && ($ = F))),
                    (_.displayBtn = typeof Q < "u" || typeof $ < "u"),
                    _.setExtremes(Q, $, !1, void 0, { trigger: "zoom" })),
                    (V.zoomed = !0);
                }),
                k.zoomed
              );
            }
            setAxisSize() {
              const k = this.chart;
              var U = this.options;
              const _ = U.offsets || [0, 0, 0, 0],
                W = this.horiz,
                tt = (this.width = Math.round(
                  N(v(U.width, k.plotWidth - _[3] + _[1]), k.plotWidth)
                )),
                j = (this.height = Math.round(
                  N(v(U.height, k.plotHeight - _[0] + _[2]), k.plotHeight)
                )),
                I = (this.top = Math.round(
                  N(v(U.top, k.plotTop + _[0]), k.plotHeight, k.plotTop)
                ));
              (U = this.left =
                Math.round(
                  N(v(U.left, k.plotLeft + _[3]), k.plotWidth, k.plotLeft)
                )),
                (this.bottom = k.chartHeight - j - I),
                (this.right = k.chartWidth - tt - U),
                (this.len = Math.max(W ? tt : j, 0)),
                (this.pos = W ? U : I);
            }
            getExtremes() {
              const k = this.logarithmic;
              return {
                min: k ? l(k.lin2log(this.min)) : this.min,
                max: k ? l(k.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax,
              };
            }
            getThreshold(k) {
              var U = this.logarithmic;
              const _ = U ? U.lin2log(this.min) : this.min;
              return (
                (U = U ? U.lin2log(this.max) : this.max),
                k === null || k === -1 / 0
                  ? (k = _)
                  : k === 1 / 0
                  ? (k = U)
                  : _ > k
                  ? (k = _)
                  : U < k && (k = U),
                this.translate(k, 0, 1, 0, 1)
              );
            }
            autoLabelAlign(k) {
              const U = (v(k, 0) - 90 * this.side + 720) % 360;
              return (
                (k = { align: "center" }),
                m(this, "autoLabelAlign", k, function (_) {
                  15 < U && 165 > U
                    ? (_.align = "right")
                    : 195 < U && 345 > U && (_.align = "left");
                }),
                k.align
              );
            }
            tickSize(k) {
              const U = this.options,
                _ = v(
                  U[k === "tick" ? "tickWidth" : "minorTickWidth"],
                  k === "tick" && this.isXAxis && !this.categories ? 1 : 0
                );
              let W = U[k === "tick" ? "tickLength" : "minorTickLength"],
                tt;
              return (
                _ &&
                  W &&
                  (U[k + "Position"] === "inside" && (W = -W), (tt = [W, _])),
                (k = { tickSize: tt }),
                m(this, "afterTickSize", k),
                k.tickSize
              );
            }
            labelMetrics() {
              const k = this.chart.renderer;
              var U = this.ticks;
              return (
                (U = U[Object.keys(U)[0]] || {}),
                this.chart.renderer.fontMetrics(
                  U.label || U.movedLabel || k.box
                )
              );
            }
            unsquish() {
              const k = this.options.labels;
              var U = this.horiz;
              const _ = this.tickInterval,
                W =
                  this.len /
                  (((this.categories ? 1 : 0) + this.max - this.min) / _),
                tt = k.rotation,
                j = 0.75 * this.labelMetrics().h,
                I = Math.max(this.max - this.min, 0),
                F = function (st) {
                  let ot = st / (W || 1);
                  return (
                    (ot = 1 < ot ? Math.ceil(ot) : 1),
                    ot * _ > I &&
                      st !== 1 / 0 &&
                      W !== 1 / 0 &&
                      I &&
                      (ot = Math.ceil(I / _)),
                    l(ot * _)
                  );
                };
              let V = _,
                Q,
                $ = Number.MAX_VALUE,
                et;
              if (U) {
                if (
                  (k.staggerLines ||
                    (C(tt)
                      ? (et = [tt])
                      : W < k.autoRotationLimit && (et = k.autoRotation)),
                  et)
                ) {
                  let st;
                  for (const ot of et)
                    (ot === tt || (ot && -90 <= ot && 90 >= ot)) &&
                      ((U = F(Math.abs(j / Math.sin(x * ot)))),
                      (st = U + Math.abs(ot / 360)),
                      st < $ && (($ = st), (Q = ot), (V = U)));
                }
              } else V = F(j);
              return (
                (this.autoRotation = et),
                (this.labelRotation = v(Q, C(tt) ? tt : 0)),
                k.step ? _ : V
              );
            }
            getSlotWidth(k) {
              const U = this.chart,
                _ = this.horiz,
                W = this.options.labels,
                tt = Math.max(
                  this.tickPositions.length - (this.categories ? 0 : 1),
                  1
                ),
                j = U.margin[3];
              if (k && C(k.slotWidth)) return k.slotWidth;
              if (_ && 2 > W.step)
                return W.rotation
                  ? 0
                  : ((this.staggerLines || 1) * this.len) / tt;
              if (!_) {
                if (((k = W.style.width), k !== void 0))
                  return parseInt(String(k), 10);
                if (j) return j - U.spacing[3];
              }
              return 0.33 * U.chartWidth;
            }
            renderUnsquish() {
              const k = this.chart,
                U = k.renderer,
                _ = this.tickPositions,
                W = this.ticks,
                tt = this.options.labels,
                j = tt.style,
                I = this.horiz,
                F = this.getSlotWidth();
              var V = Math.max(1, Math.round(F - 2 * tt.padding));
              const Q = {},
                $ = this.labelMetrics(),
                et = j.textOverflow;
              let st,
                ot,
                at = 0;
              if (
                (o(tt.rotation) || (Q.rotation = tt.rotation || 0),
                _.forEach(function (Z) {
                  (Z = W[Z]),
                    Z.movedLabel && Z.replaceMovedLabel(),
                    Z &&
                      Z.label &&
                      Z.label.textPxLength > at &&
                      (at = Z.label.textPxLength);
                }),
                (this.maxLabelLength = at),
                this.autoRotation)
              )
                at > V && at > $.h
                  ? (Q.rotation = this.labelRotation)
                  : (this.labelRotation = 0);
              else if (F && ((st = V), !et))
                for (ot = "clip", V = _.length; !I && V--; ) {
                  var lt = _[V];
                  (lt = W[lt].label) &&
                    (lt.styles && lt.styles.textOverflow === "ellipsis"
                      ? lt.css({ textOverflow: "clip" })
                      : lt.textPxLength > F && lt.css({ width: F + "px" }),
                    lt.getBBox().height > this.len / _.length - ($.h - $.f) &&
                      (lt.specificTextOverflow = "ellipsis"));
                }
              Q.rotation &&
                ((st = at > 0.5 * k.chartHeight ? 0.33 * k.chartHeight : at),
                et || (ot = "ellipsis")),
                (this.labelAlign =
                  tt.align || this.autoLabelAlign(this.labelRotation)) &&
                  (Q.align = this.labelAlign),
                _.forEach(function (Z) {
                  const q = (Z = W[Z]) && Z.label,
                    nt = j.width,
                    it = {};
                  q &&
                    (q.attr(Q),
                    Z.shortenLabel
                      ? Z.shortenLabel()
                      : st &&
                        !nt &&
                        j.whiteSpace !== "nowrap" &&
                        (st < q.textPxLength || q.element.tagName === "SPAN")
                      ? ((it.width = st + "px"),
                        et || (it.textOverflow = q.specificTextOverflow || ot),
                        q.css(it))
                      : q.styles &&
                        q.styles.width &&
                        !it.width &&
                        !nt &&
                        q.css({ width: null }),
                    delete q.specificTextOverflow,
                    (Z.rotation = Q.rotation));
                }, this),
                (this.tickRotCorr = U.rotCorr(
                  $.b,
                  this.labelRotation || 0,
                  this.side !== 0
                ));
            }
            hasData() {
              return (
                this.series.some(function (k) {
                  return k.hasData();
                }) ||
                (this.options.showEmpty && p(this.min) && p(this.max))
              );
            }
            addTitle(k) {
              const U = this.chart.renderer,
                _ = this.horiz,
                W = this.opposite,
                tt = this.options.title,
                j = this.chart.styledMode;
              let I;
              this.axisTitle ||
                ((I = tt.textAlign) ||
                  (I = (
                    _
                      ? { low: "left", middle: "center", high: "right" }
                      : {
                          low: W ? "right" : "left",
                          middle: "center",
                          high: W ? "left" : "right",
                        }
                  )[tt.align]),
                (this.axisTitle = U.text(tt.text || "", 0, 0, tt.useHTML)
                  .attr({ zIndex: 7, rotation: tt.rotation, align: I })
                  .addClass("highcharts-axis-title")),
                j || this.axisTitle.css(r(tt.style)),
                this.axisTitle.add(this.axisGroup),
                (this.axisTitle.isNew = !0)),
                j ||
                  tt.style.width ||
                  this.isRadial ||
                  this.axisTitle.css({ width: this.len + "px" }),
                this.axisTitle[k ? "show" : "hide"](k);
            }
            generateTick(k) {
              const U = this.ticks;
              U[k] ? U[k].addLabel() : (U[k] = new Y(this, k));
            }
            getOffset() {
              const k = this,
                {
                  chart: U,
                  horiz: _,
                  options: W,
                  side: tt,
                  ticks: j,
                  tickPositions: I,
                  coll: F,
                  axisParent: V,
                } = k,
                Q = U.renderer,
                $ = U.inverted && !k.isZAxis ? [1, 0, 3, 2][tt] : tt;
              var et = k.hasData();
              const st = W.title;
              var ot = W.labels;
              const at = C(W.crossing);
              var lt = U.axisOffset;
              const Z = U.clipOffset,
                q = [-1, 1, 1, -1][tt],
                nt = W.className;
              let it,
                rt = 0,
                ht;
              var ct = 0;
              let ft = 0;
              if (
                ((k.showAxis = it = et || W.showEmpty),
                (k.staggerLines = (k.horiz && ot.staggerLines) || void 0),
                !k.axisGroup)
              ) {
                const yt = (ut, gt, wt) =>
                  Q.g(ut)
                    .attr({ zIndex: wt })
                    .addClass(
                      `highcharts-${F.toLowerCase()}${gt} ` +
                        (this.isRadial ? `highcharts-radial-axis${gt} ` : "") +
                        (nt || "")
                    )
                    .add(V);
                (k.gridGroup = yt("grid", "-grid", W.gridZIndex)),
                  (k.axisGroup = yt("axis", "", W.zIndex)),
                  (k.labelGroup = yt("axis-labels", "-labels", ot.zIndex));
              }
              et || k.isLinked
                ? (I.forEach(function (yt) {
                    k.generateTick(yt);
                  }),
                  k.renderUnsquish(),
                  (k.reserveSpaceDefault =
                    tt === 0 ||
                    tt === 2 ||
                    { 1: "left", 3: "right" }[tt] === k.labelAlign),
                  v(
                    ot.reserveSpace,
                    at ? !1 : null,
                    k.labelAlign === "center" ? !0 : null,
                    k.reserveSpaceDefault
                  ) &&
                    I.forEach(function (yt) {
                      ft = Math.max(j[yt].getLabelSize(), ft);
                    }),
                  k.staggerLines && (ft *= k.staggerLines),
                  (k.labelOffset = ft * (k.opposite ? -1 : 1)))
                : u(j, function (yt, ut) {
                    yt.destroy(), delete j[ut];
                  }),
                st &&
                  st.text &&
                  st.enabled !== !1 &&
                  (k.addTitle(it),
                  it &&
                    !at &&
                    st.reserveSpace !== !1 &&
                    ((k.titleOffset = rt =
                      k.axisTitle.getBBox()[_ ? "height" : "width"]),
                    (ht = st.offset),
                    (ct = p(ht) ? 0 : v(st.margin, _ ? 5 : 10)))),
                k.renderLine(),
                (k.offset =
                  q * v(W.offset, lt[tt] ? lt[tt] + (W.margin || 0) : 0)),
                (k.tickRotCorr = k.tickRotCorr || { x: 0, y: 0 }),
                (et =
                  tt === 0
                    ? -k.labelMetrics().h
                    : tt === 2
                    ? k.tickRotCorr.y
                    : 0),
                (ct = Math.abs(ft) + ct),
                ft &&
                  (ct =
                    ct -
                    et +
                    q *
                      (_
                        ? v(ot.y, k.tickRotCorr.y + q * ot.distance)
                        : v(ot.x, q * ot.distance))),
                (k.axisTitleMargin = v(ht, ct)),
                k.getMaxLabelDimensions &&
                  (k.maxLabelDimensions = k.getMaxLabelDimensions(j, I)),
                F !== "colorAxis" &&
                  ((ot = this.tickSize("tick")),
                  (lt[tt] = Math.max(
                    lt[tt],
                    (k.axisTitleMargin || 0) + rt + q * k.offset,
                    ct,
                    I && I.length && ot ? ot[0] + q * k.offset : 0
                  )),
                  (lt =
                    !k.axisLine || W.offset
                      ? 0
                      : 2 * Math.floor(k.axisLine.strokeWidth() / 2)),
                  (Z[$] = Math.max(Z[$], lt))),
                m(this, "afterGetOffset");
            }
            getLinePath(k) {
              const U = this.chart,
                _ = this.opposite;
              var W = this.offset;
              const tt = this.horiz,
                j = this.left + (_ ? this.width : 0) + W;
              return (
                (W = U.chartHeight - this.bottom - (_ ? this.height : 0) + W),
                _ && (k *= -1),
                U.renderer.crispLine(
                  [
                    ["M", tt ? this.left : j, tt ? W : this.top],
                    [
                      "L",
                      tt ? U.chartWidth - this.right : j,
                      tt ? W : U.chartHeight - this.bottom,
                    ],
                  ],
                  k
                )
              );
            }
            renderLine() {
              this.axisLine ||
                ((this.axisLine = this.chart.renderer
                  .path()
                  .addClass("highcharts-axis-line")
                  .add(this.axisGroup)),
                this.chart.styledMode ||
                  this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7,
                  }));
            }
            getTitlePosition(k) {
              var U = this.horiz,
                _ = this.left;
              const W = this.top;
              var tt = this.len;
              const j = this.options.title,
                I = U ? _ : W,
                F = this.opposite,
                V = this.offset,
                Q = j.x,
                $ = j.y,
                et = this.chart.renderer.fontMetrics(k);
              return (
                (k = k ? Math.max(k.getBBox(!1, 0).height - et.h - 1, 0) : 0),
                (tt = {
                  low: I + (U ? 0 : tt),
                  middle: I + tt / 2,
                  high: I + (U ? tt : 0),
                }[j.align]),
                (_ =
                  (U ? W + this.height : _) +
                  (U ? 1 : -1) * (F ? -1 : 1) * (this.axisTitleMargin || 0) +
                  [-k, k, et.f, -k][this.side]),
                (U = {
                  x: U ? tt + Q : _ + (F ? this.width : 0) + V + Q,
                  y: U ? _ + $ - (F ? this.height : 0) + V : tt + $,
                }),
                m(this, "afterGetTitlePosition", { titlePosition: U }),
                U
              );
            }
            renderMinorTick(k, U) {
              const _ = this.minorTicks;
              _[k] || (_[k] = new Y(this, k, "minor")),
                U && _[k].isNew && _[k].render(null, !0),
                _[k].render(null, !1, 1);
            }
            renderTick(k, U, _) {
              const W = this.ticks;
              (!this.isLinked ||
                (k >= this.min && k <= this.max) ||
                (this.grid && this.grid.isColumn)) &&
                (W[k] || (W[k] = new Y(this, k)),
                _ && W[k].isNew && W[k].render(U, !0, -1),
                W[k].render(U));
            }
            render() {
              const k = this,
                U = k.chart,
                _ = k.logarithmic,
                W = k.options,
                tt = k.isLinked,
                j = k.tickPositions,
                I = k.axisTitle,
                F = k.ticks,
                V = k.minorTicks,
                Q = k.alternateBands,
                $ = W.stackLabels,
                et = W.alternateGridColor;
              var st = W.crossing;
              const ot = k.tickmarkOffset,
                at = k.axisLine,
                lt = k.showAxis,
                Z = E(U.renderer.globalAnimation);
              let q, nt;
              if (
                ((k.labelEdge.length = 0),
                (k.overlap = !1),
                [F, V, Q].forEach(function (it) {
                  u(it, function (rt) {
                    rt.isActive = !1;
                  });
                }),
                C(st))
              ) {
                const it = this.isXAxis ? U.yAxis[0] : U.xAxis[0],
                  rt = [1, -1, -1, 1][this.side];
                it &&
                  ((st = it.toPixels(st, !0)),
                  k.horiz && (st = it.len - st),
                  (k.offset = rt * st));
              }
              if (k.hasData() || tt) {
                const it = k.chart.hasRendered && k.old && C(k.old.min);
                k.minorTickInterval &&
                  !k.categories &&
                  k.getMinorTickPositions().forEach(function (rt) {
                    k.renderMinorTick(rt, it);
                  }),
                  j.length &&
                    (j.forEach(function (rt, ht) {
                      k.renderTick(rt, ht, it);
                    }),
                    ot &&
                      (k.min === 0 || k.single) &&
                      (F[-1] || (F[-1] = new Y(k, -1, null, !0)),
                      F[-1].render(-1))),
                  et &&
                    j.forEach(function (rt, ht) {
                      (nt =
                        typeof j[ht + 1] < "u" ? j[ht + 1] + ot : k.max - ot),
                        ht % 2 === 0 &&
                          rt < k.max &&
                          nt <= k.max + (U.polar ? -ot : ot) &&
                          (Q[rt] || (Q[rt] = new G.PlotLineOrBand(k)),
                          (q = rt + ot),
                          (Q[rt].options = {
                            from: _ ? _.lin2log(q) : q,
                            to: _ ? _.lin2log(nt) : nt,
                            color: et,
                            className: "highcharts-alternate-grid",
                          }),
                          Q[rt].render(),
                          (Q[rt].isActive = !0));
                    }),
                  k._addedPlotLB ||
                    ((k._addedPlotLB = !0),
                    (W.plotLines || [])
                      .concat(W.plotBands || [])
                      .forEach(function (rt) {
                        k.addPlotBandOrLine(rt);
                      }));
              }
              [F, V, Q].forEach(function (it) {
                const rt = [],
                  ht = Z.duration;
                u(it, function (ct, ft) {
                  ct.isActive ||
                    (ct.render(ft, !1, 0), (ct.isActive = !1), rt.push(ft));
                }),
                  X(
                    function () {
                      let ct = rt.length;
                      for (; ct--; )
                        it[rt[ct]] &&
                          !it[rt[ct]].isActive &&
                          (it[rt[ct]].destroy(), delete it[rt[ct]]);
                    },
                    it !== Q && U.hasRendered && ht ? ht : 0
                  );
              }),
                at &&
                  (at[at.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(at.strokeWidth()),
                  }),
                  (at.isPlaced = !0),
                  at[lt ? "show" : "hide"](lt)),
                I &&
                  lt &&
                  (I[I.isNew ? "attr" : "animate"](k.getTitlePosition(I)),
                  (I.isNew = !1)),
                $ && $.enabled && k.stacking && k.stacking.renderStackTotals(),
                (k.old = {
                  len: k.len,
                  max: k.max,
                  min: k.min,
                  transA: k.transA,
                  userMax: k.userMax,
                  userMin: k.userMin,
                }),
                (k.isDirty = !1),
                m(this, "afterRender");
            }
            redraw() {
              this.visible &&
                (this.render(),
                this.plotLinesAndBands.forEach(function (k) {
                  k.render();
                })),
                this.series.forEach(function (k) {
                  k.isDirty = !0;
                });
            }
            getKeepProps() {
              return this.keepProps || K.keepProps;
            }
            destroy(k) {
              const U = this,
                _ = U.plotLinesAndBands,
                W = this.eventOptions;
              if (
                (m(this, "destroy", { keepEvents: k }),
                k || w(U),
                [U.ticks, U.minorTicks, U.alternateBands].forEach(function (
                  tt
                ) {
                  g(tt);
                }),
                _)
              )
                for (k = _.length; k--; ) _[k].destroy();
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar"
                .split(" ")
                .forEach(function (tt) {
                  U[tt] && (U[tt] = U[tt].destroy());
                });
              for (const tt in U.plotLinesAndBandsGroups)
                U.plotLinesAndBandsGroups[tt] =
                  U.plotLinesAndBandsGroups[tt].destroy();
              u(U, function (tt, j) {
                U.getKeepProps().indexOf(j) === -1 && delete U[j];
              }),
                (this.eventOptions = W);
            }
            drawCrosshair(k, U) {
              const _ = this.crosshair;
              var W = v(_ && _.snap, !0);
              const tt = this.chart;
              let j,
                I = this.cross;
              if (
                (m(this, "drawCrosshair", { e: k, point: U }),
                k || (k = this.cross && this.cross.e),
                _ && (p(U) || !W) !== !1)
              ) {
                if (
                  (W
                    ? p(U) &&
                      (j = v(
                        this.coll !== "colorAxis" ? U.crosshairPos : null,
                        this.isXAxis ? U.plotX : this.len - U.plotY
                      ))
                    : (j =
                        k &&
                        (this.horiz
                          ? k.chartX - this.pos
                          : this.len - k.chartY + this.pos)),
                  p(j))
                ) {
                  var F = {
                    value: U && (this.isXAxis ? U.x : v(U.stackY, U.y)),
                    translatedValue: j,
                  };
                  tt.polar &&
                    A(F, {
                      isCrosshair: !0,
                      chartX: k && k.chartX,
                      chartY: k && k.chartY,
                      point: U,
                    }),
                    (F = this.getPlotLinePath(F) || null);
                }
                if (!p(F)) {
                  this.hideCrosshair();
                  return;
                }
                (W = this.categories && !this.isRadial),
                  I ||
                    ((this.cross = I =
                      tt.renderer
                        .path()
                        .addClass(
                          "highcharts-crosshair highcharts-crosshair-" +
                            (W ? "category " : "thin ") +
                            (_.className || "")
                        )
                        .attr({ zIndex: v(_.zIndex, 2) })
                        .add()),
                    tt.styledMode ||
                      (I.attr({
                        stroke:
                          _.color ||
                          (W
                            ? M.parse("#ccd3ff").setOpacity(0.25).get()
                            : "#cccccc"),
                        "stroke-width": v(_.width, 1),
                      }).css({ "pointer-events": "none" }),
                      _.dashStyle && I.attr({ dashstyle: _.dashStyle }))),
                  I.show().attr({ d: F }),
                  W && !_.width && I.attr({ "stroke-width": this.transA }),
                  (this.cross.e = k);
              } else this.hideCrosshair();
              m(this, "afterDrawCrosshair", { e: k, point: U });
            }
            hideCrosshair() {
              this.cross && this.cross.hide(), m(this, "afterHideCrosshair");
            }
            hasVerticalPanning() {
              const k = this.chart.options.chart.panning;
              return !!(k && k.enabled && /y/.test(k.type));
            }
            update(k, U) {
              const _ = this.chart;
              (k = r(this.userOptions, k)),
                this.destroy(!0),
                this.init(_, k),
                (_.isDirtyBox = !0),
                v(U, !0) && _.redraw();
            }
            remove(k) {
              const U = this.chart,
                _ = this.coll,
                W = this.series;
              let tt = W.length;
              for (; tt--; ) W[tt] && W[tt].remove(!1);
              T(U.axes, this),
                T(U[_] || [], this),
                U.orderItems(_),
                this.destroy(),
                (U.isDirtyBox = !0),
                v(k, !0) && U.redraw();
            }
            setTitle(k, U) {
              this.update({ title: k }, U);
            }
            setCategories(k, U) {
              this.update({ categories: k }, U);
            }
          }
          return (
            (K.defaultOptions = d.defaultXAxisOptions),
            (K.keepProps =
              "coll extKey hcEvents names series userMax userMin".split(" ")),
            K
          );
        }
      ),
      n(i, "Core/Axis/DateTimeAxis.js", [i["Core/Utilities.js"]], function (a) {
        const {
          addEvent: d,
          getMagnitude: M,
          normalizeTickInterval: O,
          timeUnits: B,
        } = a;
        var G;
        return (
          (function (Y) {
            function L() {
              return this.chart.time.getTimeTicks.apply(
                this.chart.time,
                arguments
              );
            }
            function E(x) {
              x.userOptions.type !== "datetime"
                ? (this.dateTime = void 0)
                : this.dateTime || (this.dateTime = new S(this));
            }
            const z = [];
            Y.compose = function (x) {
              return (
                a.pushUnique(z, x) &&
                  (x.keepProps.push("dateTime"),
                  (x.prototype.getTimeTicks = L),
                  d(x, "init", E)),
                x
              );
            };
            class S {
              constructor(P) {
                this.axis = P;
              }
              normalizeTimeTickInterval(P, h) {
                const s = h || [
                  ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
                  ["second", [1, 2, 5, 10, 15, 30]],
                  ["minute", [1, 2, 5, 10, 15, 30]],
                  ["hour", [1, 2, 3, 4, 6, 8, 12]],
                  ["day", [1, 2]],
                  ["week", [1, 2]],
                  ["month", [1, 2, 3, 4, 6]],
                  ["year", null],
                ];
                h = s[s.length - 1];
                let l = B[h[0]],
                  p = h[1],
                  g;
                for (
                  g = 0;
                  g < s.length &&
                  ((h = s[g]),
                  (l = B[h[0]]),
                  (p = h[1]),
                  !(
                    s[g + 1] && P <= (l * p[p.length - 1] + B[s[g + 1][0]]) / 2
                  ));
                  g++
                );
                return (
                  l === B.year && P < 5 * l && (p = [1, 2, 5]),
                  (P = O(
                    P / l,
                    p,
                    h[0] === "year" ? Math.max(M(P / l), 1) : 1
                  )),
                  { unitRange: l, count: P, unitName: h[0] }
                );
              }
              getXDateFormat(P, h) {
                const { axis: s } = this,
                  l = s.chart.time;
                return s.closestPointRange
                  ? l.getDateFormat(
                      s.closestPointRange,
                      P,
                      s.options.startOfWeek,
                      h
                    ) || l.resolveDTLFormat(h.year).main
                  : l.resolveDTLFormat(h.day).main;
              }
            }
            Y.Additions = S;
          })(G || (G = {})),
          G
        );
      }),
      n(
        i,
        "Core/Axis/LogarithmicAxis.js",
        [i["Core/Utilities.js"]],
        function (a) {
          const { addEvent: d, normalizeTickInterval: M, pick: O } = a;
          var B;
          return (
            (function (G) {
              function Y(S) {
                let x = this.logarithmic;
                S.userOptions.type !== "logarithmic"
                  ? (this.logarithmic = void 0)
                  : x || (this.logarithmic = new z(this));
              }
              function L() {
                const S = this.logarithmic;
                S &&
                  ((this.lin2val = function (x) {
                    return S.lin2log(x);
                  }),
                  (this.val2lin = function (x) {
                    return S.log2lin(x);
                  }));
              }
              const E = [];
              G.compose = function (S) {
                return (
                  a.pushUnique(E, S) &&
                    (S.keepProps.push("logarithmic"),
                    d(S, "init", Y),
                    d(S, "afterInit", L)),
                  S
                );
              };
              class z {
                constructor(x) {
                  this.axis = x;
                }
                getLogTickPositions(x, P, h, s) {
                  const l = this.axis;
                  var p = l.len,
                    g = l.options;
                  let T = [];
                  if ((s || (this.minorAutoInterval = void 0), 0.5 <= x))
                    (x = Math.round(x)),
                      (T = l.getLinearTickPositions(x, P, h));
                  else if (0.08 <= x) {
                    g = Math.floor(P);
                    let D, A, m, f, b;
                    for (
                      p =
                        0.3 < x
                          ? [1, 2, 4]
                          : 0.15 < x
                          ? [1, 2, 4, 6, 8]
                          : [1, 2, 3, 4, 5, 6, 7, 8, 9];
                      g < h + 1 && !b;
                      g++
                    )
                      for (A = p.length, D = 0; D < A && !b; D++)
                        (m = this.log2lin(this.lin2log(g) * p[D])),
                          m > P &&
                            (!s || f <= h) &&
                            typeof f < "u" &&
                            T.push(f),
                          f > h && (b = !0),
                          (f = m);
                  } else
                    (P = this.lin2log(P)),
                      (h = this.lin2log(h)),
                      (x = s ? l.getMinorTickInterval() : g.tickInterval),
                      (x = O(
                        x === "auto" ? null : x,
                        this.minorAutoInterval,
                        ((g.tickPixelInterval / (s ? 5 : 1)) * (h - P)) /
                          ((s ? p / l.tickPositions.length : p) || 1)
                      )),
                      (x = M(x)),
                      (T = l.getLinearTickPositions(x, P, h).map(this.log2lin)),
                      s || (this.minorAutoInterval = x / 5);
                  return s || (l.tickInterval = x), T;
                }
                lin2log(x) {
                  return Math.pow(10, x);
                }
                log2lin(x) {
                  return Math.log(x) / Math.LN10;
                }
              }
              G.Additions = z;
            })(B || (B = {})),
            B
          );
        }
      ),
      n(
        i,
        "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js",
        [i["Core/Utilities.js"]],
        function (a) {
          const { erase: d, extend: M, isNumber: O } = a;
          var B;
          return (
            (function (G) {
              function Y(l) {
                return this.addPlotBandOrLine(l, "plotBands");
              }
              function L(l, p) {
                const g = this.userOptions;
                let T = new s(this, l);
                if ((this.visible && (T = T.render()), T)) {
                  if (
                    (this._addedPlotLB ||
                      ((this._addedPlotLB = !0),
                      (g.plotLines || [])
                        .concat(g.plotBands || [])
                        .forEach((D) => {
                          this.addPlotBandOrLine(D);
                        })),
                    p)
                  ) {
                    const D = g[p] || [];
                    D.push(l), (g[p] = D);
                  }
                  this.plotLinesAndBands.push(T);
                }
                return T;
              }
              function E(l) {
                return this.addPlotBandOrLine(l, "plotLines");
              }
              function z(l, p, g = this.options) {
                const T = this.getPlotLinePath({
                    value: p,
                    force: !0,
                    acrossPanes: g.acrossPanes,
                  }),
                  D = [],
                  A = this.horiz;
                (p =
                  !O(this.min) ||
                  !O(this.max) ||
                  (l < this.min && p < this.min) ||
                  (l > this.max && p > this.max)),
                  (l = this.getPlotLinePath({
                    value: l,
                    force: !0,
                    acrossPanes: g.acrossPanes,
                  })),
                  (g = 1);
                let m;
                if (l && T)
                  for (
                    p && ((m = l.toString() === T.toString()), (g = 0)), p = 0;
                    p < l.length;
                    p += 2
                  ) {
                    const f = l[p],
                      b = l[p + 1],
                      y = T[p],
                      C = T[p + 1];
                    (f[0] !== "M" && f[0] !== "L") ||
                      (b[0] !== "M" && b[0] !== "L") ||
                      (y[0] !== "M" && y[0] !== "L") ||
                      (C[0] !== "M" && C[0] !== "L") ||
                      (A && y[1] === f[1]
                        ? ((y[1] += g), (C[1] += g))
                        : A || y[2] !== f[2] || ((y[2] += g), (C[2] += g)),
                      D.push(
                        ["M", f[1], f[2]],
                        ["L", b[1], b[2]],
                        ["L", C[1], C[2]],
                        ["L", y[1], y[2]],
                        ["Z"]
                      )),
                      (D.isFlat = m);
                  }
                return D;
              }
              function S(l) {
                this.removePlotBandOrLine(l);
              }
              function x(l) {
                const p = this.plotLinesAndBands,
                  g = this.options,
                  T = this.userOptions;
                if (p) {
                  let D = p.length;
                  for (; D--; ) p[D].id === l && p[D].destroy();
                  [
                    g.plotLines || [],
                    T.plotLines || [],
                    g.plotBands || [],
                    T.plotBands || [],
                  ].forEach(function (A) {
                    for (D = A.length; D--; )
                      (A[D] || {}).id === l && d(A, A[D]);
                  });
                }
              }
              function P(l) {
                this.removePlotBandOrLine(l);
              }
              const h = [];
              let s;
              G.compose = function (l, p) {
                return (
                  s || (s = l),
                  a.pushUnique(h, p) &&
                    M(p.prototype, {
                      addPlotBand: Y,
                      addPlotLine: E,
                      addPlotBandOrLine: L,
                      getPlotBandPath: z,
                      removePlotBand: S,
                      removePlotLine: P,
                      removePlotBandOrLine: x,
                    }),
                  p
                );
              };
            })(B || (B = {})),
            B
          );
        }
      ),
      n(
        i,
        "Core/Axis/PlotLineOrBand/PlotLineOrBand.js",
        [
          i["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d) {
          const {
            arrayMax: M,
            arrayMin: O,
            defined: B,
            destroyObjectProperties: G,
            erase: Y,
            fireEvent: L,
            merge: E,
            objectEach: z,
            pick: S,
          } = d;
          class x {
            static compose(h) {
              return a.compose(x, h);
            }
            constructor(h, s) {
              (this.axis = h), s && ((this.options = s), (this.id = s.id));
            }
            render() {
              L(this, "render");
              const h = this,
                s = h.axis,
                l = s.horiz;
              var p = s.logarithmic;
              const g = h.options,
                T = g.color,
                D = S(g.zIndex, 0),
                A = g.events,
                m = {},
                f = s.chart.renderer;
              let b = g.label,
                y = h.label,
                C = g.to,
                o = g.from,
                r = g.value,
                c = h.svgElem;
              var u = [];
              const v = B(o) && B(C);
              u = B(r);
              const N = !c,
                w = {
                  class:
                    "highcharts-plot-" +
                    (v ? "band " : "line ") +
                    (g.className || ""),
                };
              let R = v ? "bands" : "lines";
              if (
                (p &&
                  ((o = p.log2lin(o)), (C = p.log2lin(C)), (r = p.log2lin(r))),
                s.chart.styledMode ||
                  (u
                    ? ((w.stroke = T || "#999999"),
                      (w["stroke-width"] = S(g.width, 1)),
                      g.dashStyle && (w.dashstyle = g.dashStyle))
                    : v &&
                      ((w.fill = T || "#e6e9ff"),
                      g.borderWidth &&
                        ((w.stroke = g.borderColor),
                        (w["stroke-width"] = g.borderWidth)))),
                (m.zIndex = D),
                (R += "-" + D),
                (p = s.plotLinesAndBandsGroups[R]) ||
                  (s.plotLinesAndBandsGroups[R] = p =
                    f
                      .g("plot-" + R)
                      .attr(m)
                      .add()),
                N && (h.svgElem = c = f.path().attr(w).add(p)),
                u)
              )
                u = s.getPlotLinePath({
                  value: r,
                  lineWidth: c.strokeWidth(),
                  acrossPanes: g.acrossPanes,
                });
              else if (v) u = s.getPlotBandPath(o, C, g);
              else return;
              return (
                !h.eventsAdded &&
                  A &&
                  (z(A, function (X, J) {
                    c.on(J, function (K) {
                      A[J].apply(h, [K]);
                    });
                  }),
                  (h.eventsAdded = !0)),
                (N || !c.d) && u && u.length
                  ? c.attr({ d: u })
                  : c &&
                    (u
                      ? (c.show(), c.animate({ d: u }))
                      : c.d && (c.hide(), y && (h.label = y = y.destroy()))),
                b &&
                (B(b.text) || B(b.formatter)) &&
                u &&
                u.length &&
                0 < s.width &&
                0 < s.height &&
                !u.isFlat
                  ? ((b = E(
                      {
                        align: l && v && "center",
                        x: l ? !v && 4 : 10,
                        verticalAlign: !l && v && "middle",
                        y: l ? (v ? 16 : 10) : v ? 6 : -4,
                        rotation: l && !v && 90,
                      },
                      b
                    )),
                    this.renderLabel(b, u, v, D))
                  : y && y.hide(),
                h
              );
            }
            renderLabel(h, s, l, p) {
              const g = this.axis;
              var T = g.chart.renderer;
              let D = this.label;
              D ||
                ((this.label = D =
                  T.text(this.getLabelText(h), 0, 0, h.useHTML)
                    .attr({
                      align: h.textAlign || h.align,
                      rotation: h.rotation,
                      class:
                        "highcharts-plot-" +
                        (l ? "band" : "line") +
                        "-label " +
                        (h.className || ""),
                      zIndex: p,
                    })
                    .add()),
                g.chart.styledMode ||
                  D.css(
                    E({ fontSize: "0.8em", textOverflow: "ellipsis" }, h.style)
                  )),
                (p = s.xBounds || [s[0][1], s[1][1], l ? s[2][1] : s[0][1]]),
                (s = s.yBounds || [s[0][2], s[1][2], l ? s[2][2] : s[0][2]]),
                (l = O(p)),
                (T = O(s)),
                D.align(h, !1, {
                  x: l,
                  y: T,
                  width: M(p) - l,
                  height: M(s) - T,
                }),
                (D.alignValue && D.alignValue !== "left") ||
                  ((h = h.clip ? g.width : g.chart.chartWidth),
                  D.css({
                    width:
                      (D.rotation === 90
                        ? g.height - (D.alignAttr.y - g.top)
                        : h - (D.alignAttr.x - g.left)) + "px",
                  })),
                D.show(!0);
            }
            getLabelText(h) {
              return B(h.formatter) ? h.formatter.call(this) : h.text;
            }
            destroy() {
              Y(this.axis.plotLinesAndBands, this), delete this.axis, G(this);
            }
          }
          return x;
        }
      ),
      n(
        i,
        "Core/Tooltip.js",
        [
          i["Core/Templating.js"],
          i["Core/Globals.js"],
          i["Core/Renderer/RendererUtilities.js"],
          i["Core/Renderer/RendererRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B) {
          const { format: G } = a,
            { doc: Y, isSafari: L } = d,
            { distribute: E } = M,
            {
              addEvent: z,
              clamp: S,
              css: x,
              discardElement: P,
              extend: h,
              fireEvent: s,
              isArray: l,
              isNumber: p,
              isString: g,
              merge: T,
              pick: D,
              splat: A,
              syncTimeout: m,
            } = B;
          class f {
            constructor(y, C) {
              (this.allowShared = !0),
                (this.container = void 0),
                (this.crosshairs = []),
                (this.distance = 0),
                (this.isHidden = !0),
                (this.isSticky = !1),
                (this.now = {}),
                (this.options = {}),
                (this.outside = !1),
                (this.chart = y),
                this.init(y, C);
            }
            bodyFormatter(y) {
              return y.map(function (C) {
                const o = C.series.tooltipOptions;
                return (
                  o[(C.point.formatPrefix || "point") + "Formatter"] ||
                  C.point.tooltipFormatter
                ).call(
                  C.point,
                  o[(C.point.formatPrefix || "point") + "Format"] || ""
                );
              });
            }
            cleanSplit(y) {
              this.chart.series.forEach(function (C) {
                const o = C && C.tt;
                o &&
                  (!o.isActive || y ? (C.tt = o.destroy()) : (o.isActive = !1));
              });
            }
            defaultFormatter(y) {
              const C = this.points || A(this);
              let o;
              return (
                (o = [y.tooltipFooterHeaderFormatter(C[0])]),
                (o = o.concat(y.bodyFormatter(C))),
                o.push(y.tooltipFooterHeaderFormatter(C[0], !0)),
                o
              );
            }
            destroy() {
              this.label && (this.label = this.label.destroy()),
                this.split &&
                  (this.cleanSplit(!0),
                  this.tt && (this.tt = this.tt.destroy())),
                this.renderer &&
                  ((this.renderer = this.renderer.destroy()),
                  P(this.container)),
                B.clearTimeout(this.hideTimer),
                B.clearTimeout(this.tooltipTimeout);
            }
            getAnchor(y, C) {
              var o = this.chart;
              const r = o.pointer,
                c = o.inverted,
                u = o.plotTop;
              if (
                ((o = o.plotLeft),
                (y = A(y)),
                y[0].series &&
                  y[0].series.yAxis &&
                  !y[0].series.yAxis.options.reversedStacks &&
                  (y = y.slice().reverse()),
                this.followPointer && C)
              )
                typeof C.chartX > "u" && (C = r.normalize(C)),
                  (y = [C.chartX - o, C.chartY - u]);
              else if (y[0].tooltipPos) y = y[0].tooltipPos;
              else {
                let v = 0,
                  N = 0;
                y.forEach(function (w) {
                  (w = w.pos(!0)) && ((v += w[0]), (N += w[1]));
                }),
                  (v /= y.length),
                  (N /= y.length),
                  this.shared &&
                    1 < y.length &&
                    C &&
                    (c ? (v = C.chartX) : (N = C.chartY)),
                  (y = [v - o, N - u]);
              }
              return y.map(Math.round);
            }
            getClassName(y, C, o) {
              const r = y.series,
                c = r.options;
              return [
                this.options.className,
                "highcharts-label",
                o && "highcharts-tooltip-header",
                C ? "highcharts-tooltip-box" : "highcharts-tooltip",
                !o && "highcharts-color-" + D(y.colorIndex, r.colorIndex),
                c && c.className,
              ]
                .filter(g)
                .join(" ");
            }
            getLabel() {
              const y = this,
                C = this.chart.styledMode,
                o = this.options,
                r = this.split && this.allowShared,
                c =
                  o.style.pointerEvents ||
                  (this.shouldStickOnContact() ? "auto" : "none");
              let u,
                v = this.chart.renderer;
              if (this.label) {
                var N = !this.label.hasClass("highcharts-label");
                ((!r && N) || (r && !N)) && this.destroy();
              }
              if (!this.label) {
                if (this.outside) {
                  N = this.chart.options.chart.style;
                  const w = O.getRendererType();
                  (this.container = u = d.doc.createElement("div")),
                    (u.className = "highcharts-tooltip-container"),
                    x(u, {
                      position: "absolute",
                      top: "1px",
                      pointerEvents: c,
                      zIndex: Math.max(
                        this.options.style.zIndex || 0,
                        ((N && N.zIndex) || 0) + 3
                      ),
                    }),
                    d.doc.body.appendChild(u),
                    (this.renderer = v =
                      new w(u, 0, 0, N, void 0, void 0, v.styledMode));
                }
                if (
                  (r
                    ? (this.label = v.g("tooltip"))
                    : ((this.label = v
                        .label(
                          "",
                          0,
                          0,
                          o.shape,
                          void 0,
                          void 0,
                          o.useHTML,
                          void 0,
                          "tooltip"
                        )
                        .attr({ padding: o.padding, r: o.borderRadius })),
                      C ||
                        this.label
                          .attr({
                            fill: o.backgroundColor,
                            "stroke-width": o.borderWidth || 0,
                          })
                          .css(o.style)
                          .css({ pointerEvents: c })),
                  y.outside)
                ) {
                  const w = this.label,
                    { xSetter: R, ySetter: X } = w;
                  (w.xSetter = function (J) {
                    R.call(w, y.distance), (u.style.left = J + "px");
                  }),
                    (w.ySetter = function (J) {
                      X.call(w, y.distance), (u.style.top = J + "px");
                    });
                }
                this.label.attr({ zIndex: 8 }).shadow(o.shadow).add();
              }
              return this.label;
            }
            getPlayingField() {
              const { body: y, documentElement: C } = Y,
                { chart: o, distance: r, outside: c } = this;
              return {
                width: c
                  ? Math.max(
                      y.scrollWidth,
                      C.scrollWidth,
                      y.offsetWidth,
                      C.offsetWidth,
                      C.clientWidth
                    ) -
                    2 * r
                  : o.chartWidth,
                height: c
                  ? Math.max(
                      y.scrollHeight,
                      C.scrollHeight,
                      y.offsetHeight,
                      C.offsetHeight,
                      C.clientHeight
                    )
                  : o.chartHeight,
              };
            }
            getPosition(y, C, o) {
              const r = this.chart,
                c = this.distance,
                u = {},
                v = (r.inverted && o.h) || 0,
                N = this.outside;
              var w = this.getPlayingField();
              const R = w.width,
                X = w.height,
                J = r.pointer.getChartPosition();
              w = (I) => {
                const F = I === "x";
                return [I, F ? R : X, F ? y : C].concat(
                  N
                    ? [
                        F ? y * J.scaleX : C * J.scaleY,
                        F
                          ? J.left - c + (o.plotX + r.plotLeft) * J.scaleX
                          : J.top - c + (o.plotY + r.plotTop) * J.scaleY,
                        0,
                        F ? R : X,
                      ]
                    : [
                        F ? y : C,
                        F ? o.plotX + r.plotLeft : o.plotY + r.plotTop,
                        F ? r.plotLeft : r.plotTop,
                        F ? r.plotLeft + r.plotWidth : r.plotTop + r.plotHeight,
                      ]
                );
              };
              let K = w("y"),
                H = w("x"),
                k;
              (w = !!o.negative),
                !r.polar &&
                  r.hoverSeries &&
                  r.hoverSeries.yAxis &&
                  r.hoverSeries.yAxis.reversed &&
                  (w = !w);
              const U = !this.followPointer && D(o.ttBelow, !r.inverted === w),
                _ = function (I, F, V, Q, $, et, st) {
                  const ot = N ? (I === "y" ? c * J.scaleY : c * J.scaleX) : c,
                    at = (V - Q) / 2,
                    lt = Q < $ - c,
                    Z = $ + c + Q < F,
                    q = $ - ot - V + at;
                  if ((($ = $ + ot - at), U && Z)) u[I] = $;
                  else if (!U && lt) u[I] = q;
                  else if (lt) u[I] = Math.min(st - Q, 0 > q - v ? q : q - v);
                  else if (Z) u[I] = Math.max(et, $ + v + V > F ? $ : $ + v);
                  else return !1;
                },
                W = function (I, F, V, Q, $) {
                  let et;
                  return (
                    $ < c || $ > F - c
                      ? (et = !1)
                      : (u[I] =
                          $ < V / 2
                            ? 1
                            : $ > F - Q / 2
                            ? F - Q - 2
                            : $ - V / 2),
                    et
                  );
                },
                tt = function (I) {
                  const F = K;
                  (K = H), (H = F), (k = I);
                },
                j = function () {
                  _.apply(0, K) !== !1
                    ? W.apply(0, H) !== !1 || k || (tt(!0), j())
                    : k
                    ? (u.x = u.y = 0)
                    : (tt(!0), j());
                };
              return (r.inverted || 1 < this.len) && tt(), j(), u;
            }
            hide(y) {
              const C = this;
              B.clearTimeout(this.hideTimer),
                (y = D(y, this.options.hideDelay)),
                this.isHidden ||
                  (this.hideTimer = m(function () {
                    C.getLabel().fadeOut(y && void 0), (C.isHidden = !0);
                  }, y));
            }
            init(y, C) {
              (this.chart = y),
                (this.options = C),
                (this.crosshairs = []),
                (this.now = { x: 0, y: 0 }),
                (this.isHidden = !0),
                (this.split = C.split && !y.inverted && !y.polar),
                (this.shared = C.shared || this.split),
                (this.outside = D(
                  C.outside,
                  !(!y.scrollablePixelsX && !y.scrollablePixelsY)
                ));
            }
            shouldStickOnContact(y) {
              return !(
                this.followPointer ||
                !this.options.stickOnContact ||
                (y &&
                  !this.chart.pointer.inClass(y.target, "highcharts-tooltip"))
              );
            }
            move(y, C, o, r) {
              const c = this,
                u = c.now,
                v =
                  c.options.animation !== !1 &&
                  !c.isHidden &&
                  (1 < Math.abs(y - u.x) || 1 < Math.abs(C - u.y)),
                N = c.followPointer || 1 < c.len;
              h(u, {
                x: v ? (2 * u.x + y) / 3 : y,
                y: v ? (u.y + C) / 2 : C,
                anchorX: N ? void 0 : v ? (2 * u.anchorX + o) / 3 : o,
                anchorY: N ? void 0 : v ? (u.anchorY + r) / 2 : r,
              }),
                c.getLabel().attr(u),
                c.drawTracker(),
                v &&
                  (B.clearTimeout(this.tooltipTimeout),
                  (this.tooltipTimeout = setTimeout(function () {
                    c && c.move(y, C, o, r);
                  }, 32)));
            }
            refresh(y, C) {
              const o = this.chart,
                r = this.options,
                c = o.pointer,
                u = A(y),
                v = u[0],
                N = [];
              var w = r.format,
                R = r.formatter || this.defaultFormatter;
              const X = this.shared,
                J = o.styledMode;
              let K = {};
              if (r.enabled && v.series) {
                B.clearTimeout(this.hideTimer),
                  (this.allowShared = !(
                    !l(y) &&
                    y.series &&
                    y.series.noSharedTooltip
                  )),
                  (this.followPointer =
                    !this.split && v.series.tooltipOptions.followPointer),
                  (y = this.getAnchor(y, C));
                var H = y[0],
                  k = y[1];
                if (
                  (X && this.allowShared
                    ? (c.applyInactiveState(u),
                      u.forEach(function (U) {
                        U.setState("hover"), N.push(U.getLabelConfig());
                      }),
                      (K = v.getLabelConfig()),
                      (K.points = N))
                    : (K = v.getLabelConfig()),
                  (this.len = N.length),
                  (w = g(w) ? G(w, K, o) : R.call(K, this)),
                  (R = v.series),
                  (this.distance = D(R.tooltipOptions.distance, 16)),
                  w === !1)
                )
                  this.hide();
                else {
                  if (this.split && this.allowShared) this.renderSplit(w, u);
                  else {
                    let U = H,
                      _ = k;
                    if (
                      (C &&
                        c.isDirectTouch &&
                        ((U = C.chartX - o.plotLeft),
                        (_ = C.chartY - o.plotTop)),
                      o.polar ||
                        R.options.clip === !1 ||
                        u.some(
                          (W) =>
                            c.isDirectTouch || W.series.shouldShowTooltip(U, _)
                        ))
                    )
                      (C = this.getLabel()),
                        (r.style.width && !J) ||
                          C.css({
                            width:
                              (this.outside
                                ? this.getPlayingField()
                                : o.spacingBox
                              ).width + "px",
                          }),
                        C.attr({ text: w && w.join ? w.join("") : w }),
                        C.addClass(this.getClassName(v), !0),
                        J ||
                          C.attr({
                            stroke:
                              r.borderColor || v.color || R.color || "#666666",
                          }),
                        this.updatePosition({
                          plotX: H,
                          plotY: k,
                          negative: v.negative,
                          ttBelow: v.ttBelow,
                          h: y[2] || 0,
                        });
                    else {
                      this.hide();
                      return;
                    }
                  }
                  this.isHidden &&
                    this.label &&
                    this.label.attr({ opacity: 1 }).show(),
                    (this.isHidden = !1);
                }
                s(this, "refresh");
              }
            }
            renderSplit(y, C) {
              function o(it, rt, ht, ct, ft = !0) {
                return (
                  ht
                    ? ((rt = V ? 0 : ot),
                      (it = S(
                        it - ct / 2,
                        j.left,
                        j.right - ct - (r.outside ? Q : 0)
                      )))
                    : ((rt -= et),
                      (it = ft ? it - ct - _ : it + _),
                      (it = S(it, ft ? it : j.left, j.right))),
                  { x: it, y: rt }
                );
              }
              const r = this,
                {
                  chart: c,
                  chart: {
                    chartWidth: u,
                    chartHeight: v,
                    plotHeight: N,
                    plotLeft: w,
                    plotTop: R,
                    pointer: X,
                    scrollablePixelsY: J = 0,
                    scrollablePixelsX: K,
                    scrollingContainer: { scrollLeft: H, scrollTop: k } = {
                      scrollLeft: 0,
                      scrollTop: 0,
                    },
                    styledMode: U,
                  },
                  distance: _,
                  options: W,
                  options: { positioner: tt },
                } = r,
                j =
                  r.outside && typeof K != "number"
                    ? Y.documentElement.getBoundingClientRect()
                    : { left: H, right: H + u, top: k, bottom: k + v },
                I = r.getLabel(),
                F = this.renderer || c.renderer,
                V = !(!c.xAxis[0] || !c.xAxis[0].opposite),
                { left: Q, top: $ } = X.getChartPosition();
              let et = R + k,
                st = 0,
                ot = N - J;
              g(y) && (y = [!1, y]),
                (y = y.slice(0, C.length + 1).reduce(function (it, rt, ht) {
                  if (rt !== !1 && rt !== "") {
                    ht = C[ht - 1] || {
                      isHeader: !0,
                      plotX: C[0].plotX,
                      plotY: N,
                      series: {},
                    };
                    const wt = ht.isHeader;
                    var ct = wt ? r : ht.series,
                      ft;
                    {
                      var yt = ht;
                      rt = rt.toString();
                      var ut = ct.tt;
                      const { isHeader: kt, series: Nt } = yt;
                      ut ||
                        ((ut = { padding: W.padding, r: W.borderRadius }),
                        U ||
                          ((ut.fill = W.backgroundColor),
                          (ut["stroke-width"] =
                            (ft = W.borderWidth) !== null && ft !== void 0
                              ? ft
                              : 1)),
                        (ut = F.label(
                          "",
                          0,
                          0,
                          W[kt ? "headerShape" : "shape"],
                          void 0,
                          void 0,
                          W.useHTML
                        )
                          .addClass(r.getClassName(yt, !0, kt))
                          .attr(ut)
                          .add(I))),
                        (ut.isActive = !0),
                        ut.attr({ text: rt }),
                        U ||
                          ut.css(W.style).attr({
                            stroke:
                              W.borderColor ||
                              yt.color ||
                              Nt.color ||
                              "#333333",
                          }),
                        (ft = ut);
                    }
                    (ft = ct.tt = ft),
                      (yt = ft.getBBox()),
                      (ct = yt.width + ft.strokeWidth()),
                      wt && ((st = yt.height), (ot += st), V && (et -= st));
                    {
                      const {
                        isHeader: kt,
                        plotX: Nt = 0,
                        plotY: Mt = 0,
                        series: qt,
                      } = ht;
                      if (kt) {
                        rt = w + Nt;
                        var gt = R + N / 2;
                      } else {
                        const { xAxis: ge, yAxis: Dt } = qt;
                        (rt = ge.pos + S(Nt, -_, ge.len + _)),
                          qt.shouldShowTooltip(0, Dt.pos - R + Mt, {
                            ignoreX: !0,
                          }) && (gt = Dt.pos + Mt);
                      }
                      (rt = S(rt, j.left - _, j.right + _)),
                        (gt = { anchorX: rt, anchorY: gt });
                    }
                    const { anchorX: xt, anchorY: St } = gt;
                    typeof St == "number"
                      ? ((gt = yt.height + 1),
                        (yt = tt ? tt.call(r, ct, gt, ht) : o(xt, St, wt, ct)),
                        it.push({
                          align: tt ? 0 : void 0,
                          anchorX: xt,
                          anchorY: St,
                          boxWidth: ct,
                          point: ht,
                          rank: D(yt.rank, wt ? 1 : 0),
                          size: gt,
                          target: yt.y,
                          tt: ft,
                          x: yt.x,
                        }))
                      : (ft.isActive = !1);
                  }
                  return it;
                }, [])),
                !tt &&
                  y.some((it) => {
                    var { outside: rt } = r;
                    return (
                      (rt = (rt ? Q : 0) + it.anchorX),
                      rt < j.left && rt + it.boxWidth < j.right
                        ? !0
                        : rt < Q - j.left + it.boxWidth && j.right - rt > rt
                    );
                  }) &&
                  (y = y.map((it) => {
                    const { x: rt, y: ht } = o(
                      it.anchorX,
                      it.anchorY,
                      it.point.isHeader,
                      it.boxWidth,
                      !1
                    );
                    return h(it, { target: ht, x: rt });
                  })),
                r.cleanSplit(),
                E(y, ot);
              var at = Q,
                lt = Q;
              y.forEach(function (it) {
                const { x: rt, boxWidth: ht, isHeader: ct } = it;
                ct ||
                  (r.outside && Q + rt < at && (at = Q + rt),
                  !ct && r.outside && at + ht > lt && (lt = Q + rt));
              }),
                y.forEach(function (it) {
                  const {
                      x: rt,
                      anchorX: ht,
                      anchorY: ct,
                      pos: ft,
                      point: { isHeader: yt },
                    } = it,
                    ut = {
                      visibility: typeof ft > "u" ? "hidden" : "inherit",
                      x: rt,
                      y: (ft || 0) + et,
                      anchorX: ht,
                      anchorY: ct,
                    };
                  if (r.outside && rt < ht) {
                    const gt = Q - at;
                    0 < gt &&
                      (yt || ((ut.x = rt + gt), (ut.anchorX = ht + gt)),
                      yt && ((ut.x = (lt - at) / 2), (ut.anchorX = ht + gt)));
                  }
                  it.tt.attr(ut);
                });
              const { container: Z, outside: q, renderer: nt } = r;
              if (q && Z && nt) {
                const { width: it, height: rt, x: ht, y: ct } = I.getBBox();
                nt.setSize(it + ht, rt + ct, !1),
                  (Z.style.left = at + "px"),
                  (Z.style.top = $ + "px");
              }
              L && I.attr({ opacity: I.opacity === 1 ? 0.999 : 1 });
            }
            drawTracker() {
              if (this.shouldStickOnContact()) {
                var y = this.chart,
                  C = this.label,
                  o = this.shared ? y.hoverPoints : y.hoverPoint;
                if (C && o) {
                  var r = { x: 0, y: 0, width: 0, height: 0 };
                  o = this.getAnchor(o);
                  var c = C.getBBox();
                  (o[0] += y.plotLeft - C.translateX),
                    (o[1] += y.plotTop - C.translateY),
                    (r.x = Math.min(0, o[0])),
                    (r.y = Math.min(0, o[1])),
                    (r.width =
                      0 > o[0]
                        ? Math.max(Math.abs(o[0]), c.width - o[0])
                        : Math.max(Math.abs(o[0]), c.width)),
                    (r.height =
                      0 > o[1]
                        ? Math.max(Math.abs(o[1]), c.height - Math.abs(o[1]))
                        : Math.max(Math.abs(o[1]), c.height)),
                    this.tracker
                      ? this.tracker.attr(r)
                      : ((this.tracker = C.renderer
                          .rect(r)
                          .addClass("highcharts-tracker")
                          .add(C)),
                        y.styledMode ||
                          this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
                }
              } else this.tracker && (this.tracker = this.tracker.destroy());
            }
            styledModeFormat(y) {
              return y
                .replace(
                  'style="font-size: 0.8em"',
                  'class="highcharts-header"'
                )
                .replace(
                  /style="color:{(point|series)\.color}"/g,
                  'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"'
                );
            }
            tooltipFooterHeaderFormatter(y, C) {
              const o = y.series,
                r = o.tooltipOptions;
              var c = o.xAxis;
              const u = c && c.dateTime;
              c = { isFooter: C, labelConfig: y };
              let v = r.xDateFormat,
                N = r[C ? "footerFormat" : "headerFormat"];
              return (
                s(this, "headerFormatter", c, function (w) {
                  u &&
                    !v &&
                    p(y.key) &&
                    (v = u.getXDateFormat(y.key, r.dateTimeLabelFormats)),
                    u &&
                      v &&
                      ((y.point && y.point.tooltipDateKeys) || ["key"]).forEach(
                        function (R) {
                          N = N.replace(
                            "{point." + R + "}",
                            "{point." + R + ":" + v + "}"
                          );
                        }
                      ),
                    o.chart.styledMode && (N = this.styledModeFormat(N)),
                    (w.text = G(N, { point: y, series: o }, this.chart));
                }),
                c.text
              );
            }
            update(y) {
              this.destroy(), this.init(this.chart, T(!0, this.options, y));
            }
            updatePosition(y) {
              const { chart: C, distance: o, options: r } = this;
              var c = C.pointer;
              const u = this.getLabel(),
                {
                  left: v,
                  top: N,
                  scaleX: w,
                  scaleY: R,
                } = c.getChartPosition();
              c = (r.positioner || this.getPosition).call(
                this,
                u.width,
                u.height,
                y
              );
              let X = (y.plotX || 0) + C.plotLeft;
              y = (y.plotY || 0) + C.plotTop;
              let J;
              this.outside &&
                (r.positioner && ((c.x += v - o), (c.y += N - o)),
                (J = (r.borderWidth || 0) + 2 * o),
                this.renderer.setSize(u.width + J, u.height + J, !1),
                (w !== 1 || R !== 1) &&
                  (x(this.container, { transform: `scale(${w}, ${R})` }),
                  (X *= w),
                  (y *= R)),
                (X += v - c.x),
                (y += N - c.y)),
                this.move(Math.round(c.x), Math.round(c.y || 0), X, y);
            }
          }
          return (
            (function (b) {
              const y = [];
              b.compose = function (C) {
                B.pushUnique(y, C) &&
                  z(C, "afterInit", function () {
                    const o = this.chart;
                    o.options.tooltip &&
                      (o.tooltip = new b(o, o.options.tooltip));
                  });
              };
            })(f || (f = {})),
            f
          );
        }
      ),
      n(
        i,
        "Core/Series/Point.js",
        [
          i["Core/Renderer/HTML/AST.js"],
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Defaults.js"],
          i["Core/Templating.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B) {
          const { animObject: G } = d,
            { defaultOptions: Y } = M,
            { format: L } = O,
            {
              addEvent: E,
              defined: z,
              erase: S,
              extend: x,
              fireEvent: P,
              getNestedProperty: h,
              isArray: s,
              isFunction: l,
              isNumber: p,
              isObject: g,
              merge: T,
              objectEach: D,
              pick: A,
              syncTimeout: m,
              removeEvent: f,
              uniqueKey: b,
            } = B;
          class y {
            constructor() {
              (this.category = void 0),
                (this.destroyed = !1),
                (this.formatPrefix = "point"),
                (this.id = void 0),
                (this.isNull = !1),
                (this.percentage = this.options = this.name = void 0),
                (this.selected = !1),
                (this.total = this.shapeArgs = this.series = void 0),
                (this.visible = !0),
                (this.x = void 0);
            }
            animateBeforeDestroy() {
              const o = this,
                r = { x: o.startXPos, opacity: 0 },
                c = o.getGraphicalProps();
              c.singular.forEach(function (u) {
                o[u] = o[u].animate(
                  u === "dataLabel"
                    ? { x: o[u].startXPos, y: o[u].startYPos, opacity: 0 }
                    : r
                );
              }),
                c.plural.forEach(function (u) {
                  o[u].forEach(function (v) {
                    v.element &&
                      v.animate(
                        x(
                          { x: o.startXPos },
                          v.startYPos ? { x: v.startXPos, y: v.startYPos } : {}
                        )
                      );
                  });
                });
            }
            applyOptions(o, r) {
              const c = this.series,
                u = c.options.pointValKey || c.pointValKey;
              return (
                (o = y.prototype.optionsToObject.call(this, o)),
                x(this, o),
                (this.options = this.options ? x(this.options, o) : o),
                o.group && delete this.group,
                o.dataLabels && delete this.dataLabels,
                u && (this.y = y.prototype.getNestedProperty.call(this, u)),
                (this.formatPrefix = (this.isNull =
                  this.isValid && !this.isValid())
                  ? "null"
                  : "point"),
                this.selected && (this.state = "select"),
                "name" in this &&
                  typeof r > "u" &&
                  c.xAxis &&
                  c.xAxis.hasNames &&
                  (this.x = c.xAxis.nameToX(this)),
                typeof this.x > "u" && c
                  ? (this.x = typeof r > "u" ? c.autoIncrement() : r)
                  : p(o.x) &&
                    c.options.relativeXValue &&
                    (this.x = c.autoIncrement(o.x)),
                this
              );
            }
            destroy() {
              if (!this.destroyed) {
                const r = this;
                var o = r.series;
                const c = o.chart;
                o = o.options.dataSorting;
                const u = c.hoverPoints,
                  v = G(r.series.chart.renderer.globalAnimation),
                  N = () => {
                    (r.graphic || r.graphics || r.dataLabel || r.dataLabels) &&
                      (f(r), r.destroyElements());
                    for (const w in r) delete r[w];
                  };
                r.legendItem && c.legend.destroyItem(r),
                  u &&
                    (r.setState(), S(u, r), u.length || (c.hoverPoints = null)),
                  r === c.hoverPoint && r.onMouseOut(),
                  o && o.enabled
                    ? (this.animateBeforeDestroy(), m(N, v.duration))
                    : N(),
                  c.pointCount--;
              }
              this.destroyed = !0;
            }
            destroyElements(o) {
              const r = this;
              (o = r.getGraphicalProps(o)),
                o.singular.forEach(function (c) {
                  r[c] = r[c].destroy();
                }),
                o.plural.forEach(function (c) {
                  r[c].forEach(function (u) {
                    u && u.element && u.destroy();
                  }),
                    delete r[c];
                });
            }
            firePointEvent(o, r, c) {
              const u = this,
                v = this.series.options;
              (v.point.events[o] ||
                (u.options && u.options.events && u.options.events[o])) &&
                u.importEvents(),
                o === "click" &&
                  v.allowPointSelect &&
                  (c = function (N) {
                    u.select &&
                      u.select(null, N.ctrlKey || N.metaKey || N.shiftKey);
                  }),
                P(u, o, r, c);
            }
            getClassName() {
              return (
                "highcharts-point" +
                (this.selected ? " highcharts-point-select" : "") +
                (this.negative ? " highcharts-negative" : "") +
                (this.isNull ? " highcharts-null-point" : "") +
                (typeof this.colorIndex < "u"
                  ? " highcharts-color-" + this.colorIndex
                  : "") +
                (this.options.className ? " " + this.options.className : "") +
                (this.zone && this.zone.className
                  ? " " + this.zone.className.replace("highcharts-negative", "")
                  : "")
              );
            }
            getGraphicalProps(o) {
              const r = this,
                c = [],
                u = { singular: [], plural: [] };
              let v, N;
              for (
                o = o || { graphic: 1, dataLabel: 1 },
                  o.graphic && c.push("graphic"),
                  o.dataLabel &&
                    c.push(
                      "dataLabel",
                      "dataLabelPath",
                      "dataLabelUpper",
                      "connector"
                    ),
                  N = c.length;
                N--;

              )
                (v = c[N]), r[v] && u.singular.push(v);
              return (
                ["graphic", "dataLabel", "connector"].forEach(function (w) {
                  const R = w + "s";
                  o[w] && r[R] && u.plural.push(R);
                }),
                u
              );
            }
            getLabelConfig() {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal,
              };
            }
            getNestedProperty(o) {
              if (o)
                return o.indexOf("custom.") === 0
                  ? h(o, this.options)
                  : this[o];
            }
            getZone() {
              var o = this.series;
              const r = o.zones;
              o = o.zoneAxis || "y";
              let c,
                u = 0;
              for (c = r[u]; this[o] >= c.value; ) c = r[++u];
              return (
                this.nonZonedColor || (this.nonZonedColor = this.color),
                (this.color =
                  c && c.color && !this.options.color
                    ? c.color
                    : this.nonZonedColor),
                c
              );
            }
            hasNewShapeType() {
              return (
                (this.graphic &&
                  (this.graphic.symbolName ||
                    this.graphic.element.nodeName)) !== this.shapeType
              );
            }
            init(o, r, c) {
              return (
                (this.series = o),
                this.applyOptions(r, c),
                (this.id = z(this.id) ? this.id : b()),
                this.resolveColor(),
                o.chart.pointCount++,
                P(this, "afterInit"),
                this
              );
            }
            isValid() {
              return this.x !== null && p(this.y);
            }
            optionsToObject(o) {
              var r = this.series;
              const c = r.options.keys,
                u = c || r.pointArrayMap || ["y"],
                v = u.length;
              let N = {},
                w = 0,
                R = 0;
              if (p(o) || o === null) N[u[0]] = o;
              else if (s(o))
                for (
                  !c &&
                  o.length > v &&
                  ((r = typeof o[0]),
                  r === "string"
                    ? (N.name = o[0])
                    : r === "number" && (N.x = o[0]),
                  w++);
                  R < v;

                )
                  (c && typeof o[w] > "u") ||
                    (0 < u[R].indexOf(".")
                      ? y.prototype.setNestedProperty(N, o[w], u[R])
                      : (N[u[R]] = o[w])),
                    w++,
                    R++;
              else
                typeof o == "object" &&
                  ((N = o),
                  o.dataLabels && (r._hasPointLabels = !0),
                  o.marker && (r._hasPointMarkers = !0));
              return N;
            }
            pos(o, r = this.plotY) {
              if (!this.destroyed) {
                const { plotX: c, series: u } = this,
                  { chart: v, xAxis: N, yAxis: w } = u;
                let R = 0,
                  X = 0;
                if (p(c) && p(r))
                  return (
                    o &&
                      ((R = N ? N.pos : v.plotLeft),
                      (X = w ? w.pos : v.plotTop)),
                    v.inverted && N && w
                      ? [w.len - r + X, N.len - c + R]
                      : [c + R, r + X]
                  );
              }
            }
            resolveColor() {
              const o = this.series;
              var r = o.chart.styledMode;
              let c;
              var u = o.chart.options.chart.colorCount;
              delete this.nonZonedColor,
                o.options.colorByPoint
                  ? (r ||
                      ((u = o.options.colors || o.chart.options.colors),
                      (c = u[o.colorCounter]),
                      (u = u.length)),
                    (r = o.colorCounter),
                    o.colorCounter++,
                    o.colorCounter === u && (o.colorCounter = 0))
                  : (r || (c = o.color), (r = o.colorIndex)),
                (this.colorIndex = A(this.options.colorIndex, r)),
                (this.color = A(this.options.color, c));
            }
            setNestedProperty(o, r, c) {
              return (
                c.split(".").reduce(function (u, v, N, w) {
                  return (
                    (u[v] = w.length - 1 === N ? r : g(u[v], !0) ? u[v] : {}),
                    u[v]
                  );
                }, o),
                o
              );
            }
            shouldDraw() {
              return !this.isNull;
            }
            tooltipFormatter(o) {
              const r = this.series,
                c = r.tooltipOptions,
                u = A(c.valueDecimals, ""),
                v = c.valuePrefix || "",
                N = c.valueSuffix || "";
              return (
                r.chart.styledMode && (o = r.chart.tooltip.styledModeFormat(o)),
                (r.pointArrayMap || ["y"]).forEach(function (w) {
                  (w = "{point." + w),
                    (v || N) &&
                      (o = o.replace(RegExp(w + "}", "g"), v + w + "}" + N)),
                    (o = o.replace(RegExp(w + "}", "g"), w + ":,." + u + "f}"));
                }),
                L(o, { point: this, series: this.series }, r.chart)
              );
            }
            update(o, r, c, u) {
              function v() {
                N.applyOptions(o);
                var H = R && N.hasMockGraphic;
                (H = N.y === null ? !H : H),
                  R &&
                    H &&
                    ((N.graphic = R.destroy()), delete N.hasMockGraphic),
                  g(o, !0) &&
                    (R &&
                      R.element &&
                      o &&
                      o.marker &&
                      typeof o.marker.symbol < "u" &&
                      (N.graphic = R.destroy()),
                    o &&
                      o.dataLabels &&
                      N.dataLabel &&
                      (N.dataLabel = N.dataLabel.destroy()),
                    N.connector && (N.connector = N.connector.destroy())),
                  (K = N.index),
                  w.updateParallelArrays(N, K),
                  (J.data[K] =
                    g(J.data[K], !0) || g(o, !0) ? N.options : A(o, J.data[K])),
                  (w.isDirty = w.isDirtyData = !0),
                  !w.fixedBox && w.hasCartesianSeries && (X.isDirtyBox = !0),
                  J.legendType === "point" && (X.isDirtyLegend = !0),
                  r && X.redraw(c);
              }
              const N = this,
                w = N.series,
                R = N.graphic,
                X = w.chart,
                J = w.options;
              let K;
              (r = A(r, !0)),
                u === !1 ? v() : N.firePointEvent("update", { options: o }, v);
            }
            remove(o, r) {
              this.series.removePoint(this.series.data.indexOf(this), o, r);
            }
            select(o, r) {
              const c = this,
                u = c.series,
                v = u.chart;
              (this.selectedStaging = o = A(o, !c.selected)),
                c.firePointEvent(
                  o ? "select" : "unselect",
                  { accumulate: r },
                  function () {
                    (c.selected = c.options.selected = o),
                      (u.options.data[u.data.indexOf(c)] = c.options),
                      c.setState(o && "select"),
                      r ||
                        v.getSelectedPoints().forEach(function (N) {
                          const w = N.series;
                          N.selected &&
                            N !== c &&
                            ((N.selected = N.options.selected = !1),
                            (w.options.data[w.data.indexOf(N)] = N.options),
                            N.setState(
                              v.hoverPoints && w.options.inactiveOtherPoints
                                ? "inactive"
                                : ""
                            ),
                            N.firePointEvent("unselect"));
                        });
                  }
                ),
                delete this.selectedStaging;
            }
            onMouseOver(o) {
              const r = this.series.chart,
                c = r.pointer;
              (o = o
                ? c.normalize(o)
                : c.getChartCoordinatesFromPoint(this, r.inverted)),
                c.runPointActions(o, this);
            }
            onMouseOut() {
              const o = this.series.chart;
              this.firePointEvent("mouseOut"),
                this.series.options.inactiveOtherPoints ||
                  (o.hoverPoints || []).forEach(function (r) {
                    r.setState();
                  }),
                (o.hoverPoints = o.hoverPoint = null);
            }
            importEvents() {
              if (!this.hasImportedEvents) {
                const o = this,
                  r = T(o.series.options.point, o.options).events;
                (o.events = r),
                  D(r, function (c, u) {
                    l(c) && E(o, u, c);
                  }),
                  (this.hasImportedEvents = !0);
              }
            }
            setState(o, r) {
              const c = this.series;
              var u = this.state,
                v = c.options.states[o || "normal"] || {},
                N = Y.plotOptions[c.type].marker && c.options.marker;
              const w = N && N.enabled === !1,
                R = (N && N.states && N.states[o || "normal"]) || {},
                X = R.enabled === !1,
                J = this.marker || {},
                K = c.chart,
                H = N && c.markerAttribs;
              let k = c.halo;
              var U;
              let _;
              var W = c.stateMarkerGraphic;
              if (
                ((o = o || ""),
                !(
                  (o === this.state && !r) ||
                  (this.selected && o !== "select") ||
                  v.enabled === !1 ||
                  (o && (X || (w && R.enabled === !1))) ||
                  (o && J.states && J.states[o] && J.states[o].enabled === !1)
                ))
              ) {
                if (
                  ((this.state = o),
                  H && (U = c.markerAttribs(this, o)),
                  this.graphic && !this.hasMockGraphic)
                ) {
                  if (
                    (u && this.graphic.removeClass("highcharts-point-" + u),
                    o && this.graphic.addClass("highcharts-point-" + o),
                    !K.styledMode)
                  ) {
                    (u = c.pointAttribs(this, o)),
                      (_ = A(K.options.chart.animation, v.animation));
                    const tt = u.opacity;
                    c.options.inactiveOtherPoints &&
                      p(tt) &&
                      ((this.dataLabels || []).forEach(function (j) {
                        j &&
                          !j.hasClass("highcharts-data-label-hidden") &&
                          j.animate({ opacity: tt }, _);
                      }),
                      this.connector &&
                        this.connector.animate({ opacity: tt }, _)),
                      this.graphic.animate(u, _);
                  }
                  U &&
                    this.graphic.animate(
                      U,
                      A(K.options.chart.animation, R.animation, N.animation)
                    ),
                    W && W.hide();
                } else
                  o &&
                    R &&
                    ((N = J.symbol || c.symbol),
                    W && W.currentSymbol !== N && (W = W.destroy()),
                    U &&
                      (W
                        ? W[r ? "animate" : "attr"]({ x: U.x, y: U.y })
                        : N &&
                          ((c.stateMarkerGraphic = W =
                            K.renderer
                              .symbol(N, U.x, U.y, U.width, U.height)
                              .add(c.markerGroup)),
                          (W.currentSymbol = N))),
                    !K.styledMode &&
                      W &&
                      this.state !== "inactive" &&
                      W.attr(c.pointAttribs(this, o))),
                    W &&
                      (W[o && this.isInside ? "show" : "hide"](),
                      (W.element.point = this),
                      W.addClass(this.getClassName(), !0));
                (v = v.halo),
                  (U = ((W = this.graphic || W) && W.visibility) || "inherit"),
                  v && v.size && W && U !== "hidden" && !this.isCluster
                    ? (k || (c.halo = k = K.renderer.path().add(W.parentGroup)),
                      k
                        .show()
                        [r ? "animate" : "attr"]({ d: this.haloPath(v.size) }),
                      k.attr({
                        class:
                          "highcharts-halo highcharts-color-" +
                          A(this.colorIndex, c.colorIndex) +
                          (this.className ? " " + this.className : ""),
                        visibility: U,
                        zIndex: -1,
                      }),
                      (k.point = this),
                      K.styledMode ||
                        k.attr(
                          x(
                            {
                              fill: this.color || c.color,
                              "fill-opacity": v.opacity,
                            },
                            a.filterUserAttributes(v.attributes || {})
                          )
                        ))
                    : k &&
                      k.point &&
                      k.point.haloPath &&
                      k.animate({ d: k.point.haloPath(0) }, null, k.hide),
                  P(this, "afterSetState", { state: o });
              }
            }
            haloPath(o) {
              const r = this.pos();
              return r
                ? this.series.chart.renderer.symbols.circle(
                    Math.floor(r[0]) - o,
                    r[1] - o,
                    2 * o,
                    2 * o
                  )
                : [];
            }
          }
          return y;
        }
      ),
      n(
        i,
        "Core/Pointer.js",
        [
          i["Core/Color/Color.js"],
          i["Core/Globals.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { parse: O } = a,
            { charts: B, noop: G } = d,
            {
              addEvent: Y,
              attr: L,
              css: E,
              defined: z,
              extend: S,
              find: x,
              fireEvent: P,
              isNumber: h,
              isObject: s,
              objectEach: l,
              offset: p,
              pick: g,
              splat: T,
            } = M;
          class D {
            constructor(m, f) {
              (this.lastValidTouch = {}),
                (this.pinchDown = []),
                (this.runChartClick = !1),
                (this.eventsToUnbind = []),
                (this.chart = m),
                (this.hasDragged = !1),
                (this.options = f),
                this.init(m, f);
            }
            applyInactiveState(m) {
              let f = [],
                b;
              (m || []).forEach(function (y) {
                (b = y.series),
                  f.push(b),
                  b.linkedParent && f.push(b.linkedParent),
                  b.linkedSeries && (f = f.concat(b.linkedSeries)),
                  b.navigatorSeries && f.push(b.navigatorSeries);
              }),
                this.chart.series.forEach(function (y) {
                  f.indexOf(y) === -1
                    ? y.setState("inactive", !0)
                    : y.options.inactiveOtherPoints &&
                      y.setAllPointsToState("inactive");
                });
            }
            destroy() {
              const m = this;
              this.eventsToUnbind.forEach((f) => f()),
                (this.eventsToUnbind = []),
                d.chartCount ||
                  (D.unbindDocumentMouseUp &&
                    (D.unbindDocumentMouseUp = D.unbindDocumentMouseUp()),
                  D.unbindDocumentTouchEnd &&
                    (D.unbindDocumentTouchEnd = D.unbindDocumentTouchEnd())),
                clearInterval(m.tooltipTimeout),
                l(m, function (f, b) {
                  m[b] = void 0;
                });
            }
            getSelectionMarkerAttrs(m, f) {
              const b = {
                args: { chartX: m, chartY: f },
                attrs: {},
                shapeType: "rect",
              };
              return (
                P(this, "getSelectionMarkerAttrs", b, (y) => {
                  const {
                    chart: C,
                    mouseDownX: o = 0,
                    mouseDownY: r = 0,
                    zoomHor: c,
                    zoomVert: u,
                  } = this;
                  y = y.attrs;
                  let v;
                  (y.x = C.plotLeft),
                    (y.y = C.plotTop),
                    (y.width = c ? 1 : C.plotWidth),
                    (y.height = u ? 1 : C.plotHeight),
                    c &&
                      ((v = m - o),
                      (y.width = Math.abs(v)),
                      (y.x = (0 < v ? 0 : v) + o)),
                    u &&
                      ((v = f - r),
                      (y.height = Math.abs(v)),
                      (y.y = (0 < v ? 0 : v) + r));
                }),
                b
              );
            }
            drag(m) {
              const f = this.chart,
                b = f.options.chart;
              var y = f.plotLeft;
              const C = f.plotTop,
                o = f.plotWidth,
                r = f.plotHeight,
                c = this.mouseDownX || 0,
                u = this.mouseDownY || 0,
                v = s(b.panning) ? b.panning && b.panning.enabled : b.panning,
                N = b.panKey && m[b.panKey + "Key"];
              let w = m.chartX,
                R = m.chartY,
                X = this.selectionMarker;
              if (
                (!X || !X.touch) &&
                (w < y ? (w = y) : w > y + o && (w = y + o),
                R < C ? (R = C) : R > C + r && (R = C + r),
                (this.hasDragged = Math.sqrt(
                  Math.pow(c - w, 2) + Math.pow(u - R, 2)
                )),
                10 < this.hasDragged)
              ) {
                y = f.isInsidePlot(c - y, u - C, { visiblePlotOnly: !0 });
                const { shapeType: J, attrs: K } = this.getSelectionMarkerAttrs(
                  w,
                  R
                );
                (!f.hasCartesianSeries && !f.mapView) ||
                  (!this.zoomX && !this.zoomY) ||
                  !y ||
                  N ||
                  X ||
                  ((this.selectionMarker = X = f.renderer[J]()),
                  X.attr({
                    class: "highcharts-selection-marker",
                    zIndex: 7,
                  }).add(),
                  f.styledMode ||
                    X.attr({
                      fill:
                        b.selectionMarkerFill ||
                        O("#334eff").setOpacity(0.25).get(),
                    })),
                  X && X.attr(K),
                  y && !X && v && f.pan(m, b.panning);
              }
            }
            dragStart(m) {
              const f = this.chart;
              (f.mouseIsDown = m.type),
                (f.cancelClick = !1),
                (f.mouseDownX = this.mouseDownX = m.chartX),
                (f.mouseDownY = this.mouseDownY = m.chartY);
            }
            getSelectionBox(m) {
              const f = { args: { marker: m }, result: {} };
              return (
                P(this, "getSelectionBox", f, (b) => {
                  b.result = {
                    x: m.attr ? +m.attr("x") : m.x,
                    y: m.attr ? +m.attr("y") : m.y,
                    width: m.attr ? m.attr("width") : m.width,
                    height: m.attr ? m.attr("height") : m.height,
                  };
                }),
                f.result
              );
            }
            drop(m) {
              const f = this,
                b = this.chart,
                y = this.hasPinched;
              if (this.selectionMarker) {
                const {
                    x: C,
                    y: o,
                    width: r,
                    height: c,
                  } = this.getSelectionBox(this.selectionMarker),
                  u = {
                    originalEvent: m,
                    xAxis: [],
                    yAxis: [],
                    x: C,
                    y: o,
                    width: r,
                    height: c,
                  };
                let v = !!b.mapView;
                (this.hasDragged || y) &&
                  (b.axes.forEach(function (N) {
                    if (
                      N.zoomEnabled &&
                      z(N.min) &&
                      (y || f[{ xAxis: "zoomX", yAxis: "zoomY" }[N.coll]]) &&
                      h(C) &&
                      h(o) &&
                      h(r) &&
                      h(c)
                    ) {
                      var w = N.horiz;
                      const R = m.type === "touchend" ? N.minPixelPadding : 0,
                        X = N.toValue((w ? C : o) + R);
                      (w = N.toValue((w ? C + r : o + c) - R)),
                        u[N.coll].push({
                          axis: N,
                          min: Math.min(X, w),
                          max: Math.max(X, w),
                        }),
                        (v = !0);
                    }
                  }),
                  v &&
                    P(b, "selection", u, function (N) {
                      b.zoom(S(N, y ? { animation: !1 } : null));
                    })),
                  h(b.index) &&
                    (this.selectionMarker = this.selectionMarker.destroy()),
                  y && this.scaleGroups();
              }
              b &&
                h(b.index) &&
                (E(b.container, { cursor: b._cursor }),
                (b.cancelClick = 10 < this.hasDragged),
                (b.mouseIsDown = this.hasDragged = this.hasPinched = !1),
                (this.pinchDown = []));
            }
            findNearestKDPoint(m, f, b) {
              let y;
              return (
                m.forEach(function (C) {
                  var o =
                    !(C.noSharedTooltip && f) &&
                    0 > C.options.findNearestPointBy.indexOf("y");
                  if (
                    ((C = C.searchPoint(b, o)),
                    (o = s(C, !0) && C.series) && !(o = !s(y, !0)))
                  ) {
                    {
                      o = y.distX - C.distX;
                      const r = y.dist - C.dist,
                        c =
                          (C.series.group && C.series.group.zIndex) -
                          (y.series.group && y.series.group.zIndex);
                      o =
                        o !== 0 && f
                          ? o
                          : r !== 0
                          ? r
                          : c !== 0
                          ? c
                          : y.series.index > C.series.index
                          ? -1
                          : 1;
                    }
                    o = 0 < o;
                  }
                  o && (y = C);
                }),
                y
              );
            }
            getChartCoordinatesFromPoint(m, f) {
              var b = m.series;
              const y = b.xAxis;
              b = b.yAxis;
              const C = m.shapeArgs;
              if (y && b) {
                let o = g(m.clientX, m.plotX),
                  r = m.plotY || 0;
                return (
                  m.isNode && C && h(C.x) && h(C.y) && ((o = C.x), (r = C.y)),
                  f
                    ? { chartX: b.len + b.pos - r, chartY: y.len + y.pos - o }
                    : { chartX: o + y.pos, chartY: r + b.pos }
                );
              }
              if (C && C.x && C.y) return { chartX: C.x, chartY: C.y };
            }
            getChartPosition() {
              if (this.chartPosition) return this.chartPosition;
              var { container: m } = this.chart;
              const f = p(m);
              this.chartPosition = {
                left: f.left,
                top: f.top,
                scaleX: 1,
                scaleY: 1,
              };
              const b = m.offsetWidth;
              return (
                (m = m.offsetHeight),
                2 < b &&
                  2 < m &&
                  ((this.chartPosition.scaleX = f.width / b),
                  (this.chartPosition.scaleY = f.height / m)),
                this.chartPosition
              );
            }
            getCoordinates(m) {
              const f = { xAxis: [], yAxis: [] };
              return (
                this.chart.axes.forEach(function (b) {
                  f[b.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: b,
                    value: b.toValue(m[b.horiz ? "chartX" : "chartY"]),
                  });
                }),
                f
              );
            }
            getHoverData(m, f, b, y, C, o) {
              const r = [];
              y = !(!y || !m);
              const c = function (w) {
                return (
                  w.visible &&
                  !(!C && w.directTouch) &&
                  g(w.options.enableMouseTracking, !0)
                );
              };
              let u,
                v = {
                  chartX: o ? o.chartX : void 0,
                  chartY: o ? o.chartY : void 0,
                  shared: C,
                };
              P(this, "beforeGetHoverData", v),
                (u =
                  f && !f.stickyTracking
                    ? [f]
                    : b.filter((w) => w.stickyTracking && (v.filter || c)(w)));
              const N = y || !o ? m : this.findNearestKDPoint(u, C, o);
              return (
                (f = N && N.series),
                N &&
                  (C && !f.noSharedTooltip
                    ? ((u = b.filter(function (w) {
                        return v.filter
                          ? v.filter(w)
                          : c(w) && !w.noSharedTooltip;
                      })),
                      u.forEach(function (w) {
                        let R = x(w.points, function (X) {
                          return X.x === N.x && !X.isNull;
                        });
                        s(R) &&
                          (w.boosted && w.boost && (R = w.boost.getPoint(R)),
                          r.push(R));
                      }))
                    : r.push(N)),
                (v = { hoverPoint: N }),
                P(this, "afterGetHoverData", v),
                { hoverPoint: v.hoverPoint, hoverSeries: f, hoverPoints: r }
              );
            }
            getPointFromEvent(m) {
              m = m.target;
              let f;
              for (; m && !f; ) (f = m.point), (m = m.parentNode);
              return f;
            }
            onTrackerMouseOut(m) {
              m = m.relatedTarget;
              const f = this.chart.hoverSeries;
              (this.isDirectTouch = !1),
                !f ||
                  !m ||
                  f.stickyTracking ||
                  this.inClass(m, "highcharts-tooltip") ||
                  (this.inClass(m, "highcharts-series-" + f.index) &&
                    this.inClass(m, "highcharts-tracker")) ||
                  f.onMouseOut();
            }
            inClass(m, f) {
              let b;
              for (; m; ) {
                if ((b = L(m, "class"))) {
                  if (b.indexOf(f) !== -1) return !0;
                  if (b.indexOf("highcharts-container") !== -1) return !1;
                }
                m = m.parentElement;
              }
            }
            init(m, f) {
              (this.options = f),
                (this.chart = m),
                (this.runChartClick = !(
                  !f.chart.events || !f.chart.events.click
                )),
                (this.pinchDown = []),
                (this.lastValidTouch = {}),
                this.setDOMEvents(),
                P(this, "afterInit");
            }
            normalize(m, f) {
              var b = m.touches,
                y = b
                  ? b.length
                    ? b.item(0)
                    : g(b.changedTouches, m.changedTouches)[0]
                  : m;
              return (
                f || (f = this.getChartPosition()),
                (b = y.pageX - f.left),
                (y = y.pageY - f.top),
                (b /= f.scaleX),
                (y /= f.scaleY),
                S(m, { chartX: Math.round(b), chartY: Math.round(y) })
              );
            }
            onContainerClick(m) {
              const f = this.chart,
                b = f.hoverPoint;
              m = this.normalize(m);
              const y = f.plotLeft,
                C = f.plotTop;
              f.cancelClick ||
                (b && this.inClass(m.target, "highcharts-tracker")
                  ? (P(b.series, "click", S(m, { point: b })),
                    f.hoverPoint && b.firePointEvent("click", m))
                  : (S(m, this.getCoordinates(m)),
                    f.isInsidePlot(m.chartX - y, m.chartY - C, {
                      visiblePlotOnly: !0,
                    }) && P(f, "click", m)));
            }
            onContainerMouseDown(m) {
              const f = ((m.buttons || m.button) & 1) === 1;
              (m = this.normalize(m)),
                d.isFirefox && m.button !== 0 && this.onContainerMouseMove(m),
                (typeof m.button > "u" || f) &&
                  (this.zoomOption(m),
                  f && m.preventDefault && m.preventDefault(),
                  this.dragStart(m));
            }
            onContainerMouseLeave(m) {
              const f = B[g(D.hoverChartIndex, -1)];
              (m = this.normalize(m)),
                f &&
                  m.relatedTarget &&
                  !this.inClass(m.relatedTarget, "highcharts-tooltip") &&
                  (f.pointer.reset(), (f.pointer.chartPosition = void 0));
            }
            onContainerMouseEnter(m) {
              delete this.chartPosition;
            }
            onContainerMouseMove(m) {
              const f = this.chart,
                b = f.tooltip;
              (m = this.normalize(m)),
                this.setHoverChartIndex(),
                (f.mouseIsDown === "mousedown" || this.touchSelect(m)) &&
                  this.drag(m),
                f.openMenu ||
                  (!this.inClass(m.target, "highcharts-tracker") &&
                    !f.isInsidePlot(
                      m.chartX - f.plotLeft,
                      m.chartY - f.plotTop,
                      { visiblePlotOnly: !0 }
                    )) ||
                  (b && b.shouldStickOnContact(m)) ||
                  (this.inClass(m.target, "highcharts-no-tooltip")
                    ? this.reset(!1, 0)
                    : this.runPointActions(m));
            }
            onDocumentTouchEnd(m) {
              const f = B[g(D.hoverChartIndex, -1)];
              f && f.pointer.drop(m);
            }
            onContainerTouchMove(m) {
              this.touchSelect(m)
                ? this.onContainerMouseMove(m)
                : this.touch(m);
            }
            onContainerTouchStart(m) {
              this.touchSelect(m)
                ? this.onContainerMouseDown(m)
                : (this.zoomOption(m), this.touch(m, !0));
            }
            onDocumentMouseMove(m) {
              const f = this.chart,
                b = f.tooltip,
                y = this.chartPosition;
              (m = this.normalize(m, y)),
                !y ||
                  f.isInsidePlot(m.chartX - f.plotLeft, m.chartY - f.plotTop, {
                    visiblePlotOnly: !0,
                  }) ||
                  (b && b.shouldStickOnContact(m)) ||
                  this.inClass(m.target, "highcharts-tracker") ||
                  this.reset();
            }
            onDocumentMouseUp(m) {
              const f = B[g(D.hoverChartIndex, -1)];
              f && f.pointer.drop(m);
            }
            pinch(m) {
              const f = this,
                b = f.chart,
                y = f.pinchDown,
                C = m.touches || [],
                o = C.length,
                r = f.lastValidTouch,
                c = f.hasZoom,
                u = {},
                v =
                  o === 1 &&
                  ((f.inClass(m.target, "highcharts-tracker") &&
                    b.runTrackerClick) ||
                    f.runChartClick),
                N = {};
              var w = f.chart.tooltip;
              w = o === 1 && g(w && w.options.followTouchMove, !0);
              let R = f.selectionMarker;
              1 < o ? (f.initiated = !0) : w && (f.initiated = !1),
                c &&
                  f.initiated &&
                  !v &&
                  m.cancelable !== !1 &&
                  m.preventDefault(),
                [].map.call(C, function (X) {
                  return f.normalize(X);
                }),
                m.type === "touchstart"
                  ? ([].forEach.call(C, function (X, J) {
                      y[J] = { chartX: X.chartX, chartY: X.chartY };
                    }),
                    (r.x = [y[0].chartX, y[1] && y[1].chartX]),
                    (r.y = [y[0].chartY, y[1] && y[1].chartY]),
                    b.axes.forEach(function (X) {
                      if (X.zoomEnabled) {
                        const J = b.bounds[X.horiz ? "h" : "v"],
                          K = X.minPixelPadding,
                          H = X.toPixels(
                            Math.min(g(X.options.min, X.dataMin), X.dataMin)
                          ),
                          k = X.toPixels(
                            Math.max(g(X.options.max, X.dataMax), X.dataMax)
                          ),
                          U = Math.max(H, k);
                        (J.min = Math.min(X.pos, Math.min(H, k) - K)),
                          (J.max = Math.max(X.pos + X.len, U + K));
                      }
                    }),
                    (f.res = !0))
                  : w
                  ? this.runPointActions(f.normalize(m))
                  : y.length &&
                    (P(b, "touchpan", { originalEvent: m }, () => {
                      R ||
                        (f.selectionMarker = R =
                          S({ destroy: G, touch: !0 }, b.plotBox)),
                        f.pinchTranslate(y, C, u, R, N, r),
                        (f.hasPinched = c),
                        f.scaleGroups(u, N);
                    }),
                    f.res && ((f.res = !1), this.reset(!1, 0)));
            }
            pinchTranslate(m, f, b, y, C, o) {
              this.zoomHor &&
                this.pinchTranslateDirection(!0, m, f, b, y, C, o),
                this.zoomVert &&
                  this.pinchTranslateDirection(!1, m, f, b, y, C, o);
            }
            pinchTranslateDirection(m, f, b, y, C, o, r, c) {
              const u = this.chart,
                v = m ? "x" : "y",
                N = m ? "X" : "Y",
                w = "chart" + N,
                R = m ? "width" : "height",
                X = u["plot" + (m ? "Left" : "Top")],
                J = u.inverted,
                K = u.bounds[m ? "h" : "v"],
                H = f.length === 1,
                k = f[0][w],
                U = !H && f[1][w];
              f = function () {
                typeof I == "number" &&
                  20 < Math.abs(k - U) &&
                  (tt = c || Math.abs(j - I) / Math.abs(k - U)),
                  (W = (X - j) / tt + k),
                  (_ = u["plot" + (m ? "Width" : "Height")] / tt);
              };
              let _,
                W,
                tt = c || 1,
                j = b[0][w],
                I = !H && b[1][w],
                F;
              f(),
                (b = W),
                b < K.min
                  ? ((b = K.min), (F = !0))
                  : b + _ > K.max && ((b = K.max - _), (F = !0)),
                F
                  ? ((j -= 0.8 * (j - r[v][0])),
                    typeof I == "number" && (I -= 0.8 * (I - r[v][1])),
                    f())
                  : (r[v] = [j, I]),
                J || ((o[v] = W - X), (o[R] = _)),
                (o = J ? 1 / tt : tt),
                (C[R] = _),
                (C[v] = b),
                (y[J ? (m ? "scaleY" : "scaleX") : "scale" + N] = tt),
                (y["translate" + N] = o * X + (j - o * k));
            }
            reset(m, f) {
              const b = this.chart,
                y = b.hoverSeries,
                C = b.hoverPoint,
                o = b.hoverPoints,
                r = b.tooltip,
                c = r && r.shared ? o : C;
              m &&
                c &&
                T(c).forEach(function (u) {
                  u.series.isCartesian && typeof u.plotX > "u" && (m = !1);
                }),
                m
                  ? r &&
                    c &&
                    T(c).length &&
                    (r.refresh(c),
                    r.shared && o
                      ? o.forEach(function (u) {
                          u.setState(u.state, !0),
                            u.series.isCartesian &&
                              (u.series.xAxis.crosshair &&
                                u.series.xAxis.drawCrosshair(null, u),
                              u.series.yAxis.crosshair &&
                                u.series.yAxis.drawCrosshair(null, u));
                        })
                      : C &&
                        (C.setState(C.state, !0),
                        b.axes.forEach(function (u) {
                          u.crosshair &&
                            C.series[u.coll] === u &&
                            u.drawCrosshair(null, C);
                        })))
                  : (C && C.onMouseOut(),
                    o &&
                      o.forEach(function (u) {
                        u.setState();
                      }),
                    y && y.onMouseOut(),
                    r && r.hide(f),
                    this.unDocMouseMove &&
                      (this.unDocMouseMove = this.unDocMouseMove()),
                    b.axes.forEach(function (u) {
                      u.hideCrosshair();
                    }),
                    (this.hoverX = b.hoverPoints = b.hoverPoint = null));
            }
            runPointActions(m, f, b) {
              const y = this.chart,
                C = y.tooltip && y.tooltip.options.enabled ? y.tooltip : void 0,
                o = C ? C.shared : !1;
              let r = f || y.hoverPoint,
                c = (r && r.series) || y.hoverSeries;
              (f = this.getHoverData(
                r,
                c,
                y.series,
                (!m || m.type !== "touchmove") &&
                  (!!f || (c && c.directTouch && this.isDirectTouch)),
                o,
                m
              )),
                (r = f.hoverPoint),
                (c = f.hoverSeries);
              const u = f.hoverPoints;
              f =
                c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;
              const v = o && c && !c.noSharedTooltip;
              if (r && (b || r !== y.hoverPoint || (C && C.isHidden))) {
                if (
                  ((y.hoverPoints || []).forEach(function (N) {
                    u.indexOf(N) === -1 && N.setState();
                  }),
                  y.hoverSeries !== c && c.onMouseOver(),
                  this.applyInactiveState(u),
                  (u || []).forEach(function (N) {
                    N.setState("hover");
                  }),
                  y.hoverPoint && y.hoverPoint.firePointEvent("mouseOut"),
                  !r.series)
                )
                  return;
                (y.hoverPoints = u),
                  (y.hoverPoint = r),
                  r.firePointEvent("mouseOver", void 0, () => {
                    C && r && C.refresh(v ? u : r, m);
                  });
              } else
                f &&
                  C &&
                  !C.isHidden &&
                  ((b = C.getAnchor([{}], m)),
                  y.isInsidePlot(b[0], b[1], { visiblePlotOnly: !0 }) &&
                    C.updatePosition({ plotX: b[0], plotY: b[1] }));
              this.unDocMouseMove ||
                ((this.unDocMouseMove = Y(
                  y.container.ownerDocument,
                  "mousemove",
                  function (N) {
                    const w = B[D.hoverChartIndex];
                    w && w.pointer.onDocumentMouseMove(N);
                  }
                )),
                this.eventsToUnbind.push(this.unDocMouseMove)),
                y.axes.forEach(function (N) {
                  const w = g((N.crosshair || {}).snap, !0);
                  let R;
                  w &&
                    (((R = y.hoverPoint) && R.series[N.coll] === N) ||
                      (R = x(u, (X) => X.series && X.series[N.coll] === N))),
                    R || !w ? N.drawCrosshair(m, R) : N.hideCrosshair();
                });
            }
            scaleGroups(m, f) {
              const b = this.chart;
              b.series.forEach(function (y) {
                const C = m || y.getPlotBox();
                y.group &&
                  ((y.xAxis && y.xAxis.zoomEnabled) || b.mapView) &&
                  (y.group.attr(C),
                  y.markerGroup &&
                    (y.markerGroup.attr(C),
                    y.markerGroup.clip(f ? b.clipRect : null)),
                  y.dataLabelsGroup && y.dataLabelsGroup.attr(C));
              }),
                b.clipRect.attr(f || b.clipBox);
            }
            setDOMEvents() {
              const m = this.chart.container,
                f = m.ownerDocument;
              (m.onmousedown = this.onContainerMouseDown.bind(this)),
                (m.onmousemove = this.onContainerMouseMove.bind(this)),
                (m.onclick = this.onContainerClick.bind(this)),
                this.eventsToUnbind.push(
                  Y(m, "mouseenter", this.onContainerMouseEnter.bind(this))
                ),
                this.eventsToUnbind.push(
                  Y(m, "mouseleave", this.onContainerMouseLeave.bind(this))
                ),
                D.unbindDocumentMouseUp ||
                  (D.unbindDocumentMouseUp = Y(
                    f,
                    "mouseup",
                    this.onDocumentMouseUp.bind(this)
                  ));
              let b = this.chart.renderTo.parentElement;
              for (; b && b.tagName !== "BODY"; )
                this.eventsToUnbind.push(
                  Y(b, "scroll", () => {
                    delete this.chartPosition;
                  })
                ),
                  (b = b.parentElement);
              d.hasTouch &&
                (this.eventsToUnbind.push(
                  Y(m, "touchstart", this.onContainerTouchStart.bind(this), {
                    passive: !1,
                  })
                ),
                this.eventsToUnbind.push(
                  Y(m, "touchmove", this.onContainerTouchMove.bind(this), {
                    passive: !1,
                  })
                ),
                D.unbindDocumentTouchEnd ||
                  (D.unbindDocumentTouchEnd = Y(
                    f,
                    "touchend",
                    this.onDocumentTouchEnd.bind(this),
                    { passive: !1 }
                  )));
            }
            setHoverChartIndex() {
              const m = this.chart,
                f = d.charts[g(D.hoverChartIndex, -1)];
              f &&
                f !== m &&
                f.pointer.onContainerMouseLeave({ relatedTarget: m.container }),
                (f && f.mouseIsDown) || (D.hoverChartIndex = m.index);
            }
            touch(m, f) {
              const b = this.chart;
              let y;
              this.setHoverChartIndex(),
                m.touches.length === 1
                  ? ((m = this.normalize(m)),
                    b.isInsidePlot(
                      m.chartX - b.plotLeft,
                      m.chartY - b.plotTop,
                      { visiblePlotOnly: !0 }
                    ) && !b.openMenu
                      ? (f && this.runPointActions(m),
                        m.type === "touchmove" &&
                          ((f = this.pinchDown),
                          (y = f[0]
                            ? 4 <=
                              Math.sqrt(
                                Math.pow(f[0].chartX - m.chartX, 2) +
                                  Math.pow(f[0].chartY - m.chartY, 2)
                              )
                            : !1)),
                        g(y, !0) && this.pinch(m))
                      : f && this.reset())
                  : m.touches.length === 2 && this.pinch(m);
            }
            touchSelect(m) {
              return !(
                !this.chart.zooming.singleTouch ||
                !m.touches ||
                m.touches.length !== 1
              );
            }
            zoomOption(m) {
              const f = this.chart,
                b = f.inverted;
              var y = f.zooming.type || "";
              /touch/.test(m.type) && (y = g(f.zooming.pinchType, y)),
                (this.zoomX = m = /x/.test(y)),
                (this.zoomY = y = /y/.test(y)),
                (this.zoomHor = (m && !b) || (y && b)),
                (this.zoomVert = (y && !b) || (m && b)),
                (this.hasZoom = m || y);
            }
          }
          return (
            (function (A) {
              const m = [],
                f = [];
              (A.compose = function (b) {
                M.pushUnique(f, b) &&
                  Y(b, "beforeRender", function () {
                    this.pointer = new A(this, this.options);
                  });
              }),
                (A.dissolve = function () {
                  for (let b = 0, y = m.length; b < y; ++b) m[b]();
                  m.length = 0;
                });
            })(D || (D = {})),
            D
          );
        }
      ),
      n(
        i,
        "Core/Legend/Legend.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Templating.js"],
          i["Core/Globals.js"],
          i["Core/Series/Point.js"],
          i["Core/Renderer/RendererUtilities.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G) {
          const { animObject: Y, setAnimation: L } = a,
            { format: E } = d,
            { marginNames: z } = M,
            { distribute: S } = B,
            {
              addEvent: x,
              createElement: P,
              css: h,
              defined: s,
              discardElement: l,
              find: p,
              fireEvent: g,
              isNumber: T,
              merge: D,
              pick: A,
              relativeLength: m,
              stableSort: f,
              syncTimeout: b,
            } = G;
          class y {
            constructor(o, r) {
              (this.allItems = []),
                (this.contentGroup = this.box = void 0),
                (this.display = !1),
                (this.group = void 0),
                (this.offsetWidth =
                  this.maxLegendWidth =
                  this.maxItemWidth =
                  this.legendWidth =
                  this.legendHeight =
                  this.lastLineHeight =
                  this.lastItemY =
                  this.itemY =
                  this.itemX =
                  this.itemMarginTop =
                  this.itemMarginBottom =
                  this.itemHeight =
                  this.initialItemY =
                    0),
                (this.options = void 0),
                (this.padding = 0),
                (this.pages = []),
                (this.proximate = !1),
                (this.scrollGroup = void 0),
                (this.widthOption =
                  this.totalItemWidth =
                  this.titleHeight =
                  this.symbolWidth =
                  this.symbolHeight =
                    0),
                (this.chart = o),
                this.init(o, r);
            }
            init(o, r) {
              (this.chart = o),
                this.setOptions(r),
                r.enabled &&
                  (this.render(),
                  x(this.chart, "endResize", function () {
                    this.legend.positionCheckboxes();
                  }),
                  x(this.chart, "render", () => {
                    this.proximate &&
                      (this.proximatePositions(), this.positionItems());
                  }));
            }
            setOptions(o) {
              const r = A(o.padding, 8);
              (this.options = o),
                this.chart.styledMode ||
                  ((this.itemStyle = o.itemStyle),
                  (this.itemHiddenStyle = D(
                    this.itemStyle,
                    o.itemHiddenStyle
                  ))),
                (this.itemMarginTop = o.itemMarginTop),
                (this.itemMarginBottom = o.itemMarginBottom),
                (this.padding = r),
                (this.initialItemY = r - 5),
                (this.symbolWidth = A(o.symbolWidth, 16)),
                (this.pages = []),
                (this.proximate =
                  o.layout === "proximate" && !this.chart.inverted),
                (this.baseline = void 0);
            }
            update(o, r) {
              const c = this.chart;
              this.setOptions(D(!0, this.options, o)),
                this.destroy(),
                (c.isDirtyLegend = c.isDirtyBox = !0),
                A(r, !0) && c.redraw(),
                g(this, "afterUpdate");
            }
            colorizeItem(o, r) {
              const {
                group: c,
                label: u,
                line: v,
                symbol: N,
              } = o.legendItem || {};
              if (
                (c &&
                  c[r ? "removeClass" : "addClass"](
                    "highcharts-legend-item-hidden"
                  ),
                !this.chart.styledMode)
              ) {
                const { itemHiddenStyle: w } = this,
                  R = w.color,
                  X = (r && o.color) || R,
                  J = o.options && o.options.marker;
                let K = { fill: X };
                u == null || u.css(D(r ? this.itemStyle : w)),
                  v == null || v.attr({ stroke: X }),
                  N &&
                    (J &&
                      N.isMarker &&
                      ((K = o.pointAttribs()), r || (K.stroke = K.fill = R)),
                    N.attr(K));
              }
              g(this, "afterColorizeItem", { item: o, visible: r });
            }
            positionItems() {
              this.allItems.forEach(this.positionItem, this),
                this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(o) {
              const { group: r, x: c = 0, y: u = 0 } = o.legendItem || {};
              var v = this.options,
                N = v.symbolPadding;
              const w = !v.rtl;
              (v = o.checkbox),
                r &&
                  r.element &&
                  ((N = {
                    translateX: w ? c : this.legendWidth - c - 2 * N - 4,
                    translateY: u,
                  }),
                  r[s(r.translateY) ? "animate" : "attr"](N, void 0, () => {
                    g(this, "afterPositionItem", { item: o });
                  })),
                v && ((v.x = c), (v.y = u));
            }
            destroyItem(o) {
              const r = o.checkbox,
                c = o.legendItem || {};
              for (const u of ["group", "label", "line", "symbol"])
                c[u] && (c[u] = c[u].destroy());
              r && l(r), (o.legendItem = void 0);
            }
            destroy() {
              for (const o of this.getAllItems()) this.destroyItem(o);
              for (const o of "clipRect up down pager nav box title group".split(
                " "
              ))
                this[o] && (this[o] = this[o].destroy());
              this.display = null;
            }
            positionCheckboxes() {
              const o = this.group && this.group.alignAttr,
                r = this.clipHeight || this.legendHeight,
                c = this.titleHeight;
              let u;
              o &&
                ((u = o.translateY),
                this.allItems.forEach(function (v) {
                  const N = v.checkbox;
                  let w;
                  N &&
                    ((w = u + c + N.y + (this.scrollOffset || 0) + 3),
                    h(N, {
                      left: o.translateX + v.checkboxOffset + N.x - 20 + "px",
                      top: w + "px",
                      display:
                        this.proximate || (w > u - 6 && w < u + r - 6)
                          ? ""
                          : "none",
                    }));
                }, this));
            }
            renderTitle() {
              var o = this.options;
              const r = this.padding,
                c = o.title;
              let u = 0;
              c.text &&
                (this.title ||
                  ((this.title = this.chart.renderer
                    .label(
                      c.text,
                      r - 3,
                      r - 4,
                      void 0,
                      void 0,
                      void 0,
                      o.useHTML,
                      void 0,
                      "legend-title"
                    )
                    .attr({ zIndex: 1 })),
                  this.chart.styledMode || this.title.css(c.style),
                  this.title.add(this.group)),
                c.width ||
                  this.title.css({ width: this.maxLegendWidth + "px" }),
                (o = this.title.getBBox()),
                (u = o.height),
                (this.offsetWidth = o.width),
                this.contentGroup.attr({ translateY: u })),
                (this.titleHeight = u);
            }
            setText(o) {
              const r = this.options;
              o.legendItem.label.attr({
                text: r.labelFormat
                  ? E(r.labelFormat, o, this.chart)
                  : r.labelFormatter.call(o),
              });
            }
            renderItem(o) {
              const r = (o.legendItem = o.legendItem || {});
              var c = this.chart,
                u = c.renderer;
              const v = this.options,
                N = this.symbolWidth,
                w = v.symbolPadding || 0,
                R = this.itemStyle,
                X = this.itemHiddenStyle,
                J = v.layout === "horizontal" ? A(v.itemDistance, 20) : 0,
                K = !v.rtl,
                H = !o.series,
                k = !H && o.series.drawLegendSymbol ? o.series : o;
              var U = k.options;
              const _ = this.createCheckboxForItem && U && U.showCheckbox,
                W = v.useHTML,
                tt = o.options.className;
              let j = r.label;
              (U = N + w + J + (_ ? 20 : 0)),
                j ||
                  ((r.group = u
                    .g("legend-item")
                    .addClass(
                      "highcharts-" +
                        k.type +
                        "-series highcharts-color-" +
                        o.colorIndex +
                        (tt ? " " + tt : "") +
                        (H ? " highcharts-series-" + o.index : "")
                    )
                    .attr({ zIndex: 1 })
                    .add(this.scrollGroup)),
                  (r.label = j =
                    u.text("", K ? N + w : -w, this.baseline || 0, W)),
                  c.styledMode || j.css(D(o.visible ? R : X)),
                  j
                    .attr({ align: K ? "left" : "right", zIndex: 2 })
                    .add(r.group),
                  this.baseline ||
                    ((this.fontMetrics = u.fontMetrics(j)),
                    (this.baseline =
                      this.fontMetrics.f + 3 + this.itemMarginTop),
                    j.attr("y", this.baseline),
                    (this.symbolHeight = A(v.symbolHeight, this.fontMetrics.f)),
                    v.squareSymbol &&
                      ((this.symbolWidth = A(
                        v.symbolWidth,
                        Math.max(this.symbolHeight, 16)
                      )),
                      (U = this.symbolWidth + w + J + (_ ? 20 : 0)),
                      K && j.attr("x", this.symbolWidth + w))),
                  k.drawLegendSymbol(this, o),
                  this.setItemEvents && this.setItemEvents(o, j, W)),
                _ &&
                  !o.checkbox &&
                  this.createCheckboxForItem &&
                  this.createCheckboxForItem(o),
                this.colorizeItem(o, o.visible),
                (!c.styledMode && R.width) ||
                  j.css({
                    width:
                      (v.itemWidth || this.widthOption || c.spacingBox.width) -
                      U +
                      "px",
                  }),
                this.setText(o),
                (c = j.getBBox()),
                (u = (this.fontMetrics && this.fontMetrics.h) || 0),
                (o.itemWidth = o.checkboxOffset =
                  v.itemWidth || r.labelWidth || c.width + U),
                (this.maxItemWidth = Math.max(this.maxItemWidth, o.itemWidth)),
                (this.totalItemWidth += o.itemWidth),
                (this.itemHeight = o.itemHeight =
                  Math.round(
                    r.labelHeight || (c.height > 1.5 * u ? c.height : u)
                  ));
            }
            layoutItem(o) {
              var r = this.options;
              const c = this.padding,
                u = r.layout === "horizontal",
                v = o.itemHeight,
                N = this.itemMarginBottom,
                w = this.itemMarginTop,
                R = u ? A(r.itemDistance, 20) : 0,
                X = this.maxLegendWidth;
              r =
                r.alignColumns && this.totalItemWidth > X
                  ? this.maxItemWidth
                  : o.itemWidth;
              const J = o.legendItem || {};
              u &&
                this.itemX - c + r > X &&
                ((this.itemX = c),
                this.lastLineHeight &&
                  (this.itemY += w + this.lastLineHeight + N),
                (this.lastLineHeight = 0)),
                (this.lastItemY = w + this.itemY + N),
                (this.lastLineHeight = Math.max(v, this.lastLineHeight)),
                (J.x = this.itemX),
                (J.y = this.itemY),
                u
                  ? (this.itemX += r)
                  : ((this.itemY += w + v + N), (this.lastLineHeight = v)),
                (this.offsetWidth =
                  this.widthOption ||
                  Math.max(
                    (u ? this.itemX - c - (o.checkbox ? 0 : R) : r) + c,
                    this.offsetWidth
                  ));
            }
            getAllItems() {
              let o = [];
              return (
                this.chart.series.forEach(function (r) {
                  const c = r && r.options;
                  r &&
                    A(c.showInLegend, s(c.linkedTo) ? !1 : void 0, !0) &&
                    (o = o.concat(
                      (r.legendItem || {}).labels ||
                        (c.legendType === "point" ? r.data : r)
                    ));
                }),
                g(this, "afterGetAllItems", { allItems: o }),
                o
              );
            }
            getAlignment() {
              const o = this.options;
              return this.proximate
                ? o.align.charAt(0) + "tv"
                : o.floating
                ? ""
                : o.align.charAt(0) +
                  o.verticalAlign.charAt(0) +
                  o.layout.charAt(0);
            }
            adjustMargins(o, r) {
              const c = this.chart,
                u = this.options,
                v = this.getAlignment();
              v &&
                [
                  /(lth|ct|rth)/,
                  /(rtv|rm|rbv)/,
                  /(rbh|cb|lbh)/,
                  /(lbv|lm|ltv)/,
                ].forEach(function (N, w) {
                  N.test(v) &&
                    !s(o[w]) &&
                    (c[z[w]] = Math.max(
                      c[z[w]],
                      c.legend[(w + 1) % 2 ? "legendHeight" : "legendWidth"] +
                        [1, -1, -1, 1][w] * u[w % 2 ? "x" : "y"] +
                        A(u.margin, 12) +
                        r[w] +
                        (c.titleOffset[w] || 0)
                    ));
                });
            }
            proximatePositions() {
              const o = this.chart,
                r = [],
                c = this.options.align === "left";
              this.allItems.forEach(function (v) {
                var N,
                  w = c;
                let R;
                v.yAxis &&
                  (v.xAxis.options.reversed && (w = !w),
                  v.points &&
                    (N = p(
                      w ? v.points : v.points.slice(0).reverse(),
                      function (X) {
                        return T(X.plotY);
                      }
                    )),
                  (w =
                    this.itemMarginTop +
                    v.legendItem.label.getBBox().height +
                    this.itemMarginBottom),
                  (R = v.yAxis.top - o.plotTop),
                  v.visible
                    ? ((N = N ? N.plotY : v.yAxis.height), (N += R - 0.3 * w))
                    : (N = R + v.yAxis.height),
                  r.push({ target: N, size: w, item: v }));
              }, this);
              let u;
              for (const v of S(r, o.plotHeight))
                (u = v.item.legendItem || {}),
                  T(v.pos) && (u.y = o.plotTop - o.spacing[0] + v.pos);
            }
            render() {
              const o = this.chart,
                r = o.renderer,
                c = this.options,
                u = this.padding;
              var v = this.getAllItems();
              let N,
                w = this.group,
                R = this.box;
              (this.itemX = u),
                (this.itemY = this.initialItemY),
                (this.lastItemY = this.offsetWidth = 0),
                (this.widthOption = m(c.width, o.spacingBox.width - u));
              var X = o.spacingBox.width - 2 * u - c.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) &&
                (X /= 2),
                (this.maxLegendWidth = this.widthOption || X),
                w ||
                  ((this.group = w =
                    r
                      .g("legend")
                      .addClass(c.className || "")
                      .attr({ zIndex: 7 })
                      .add()),
                  (this.contentGroup = r.g().attr({ zIndex: 1 }).add(w)),
                  (this.scrollGroup = r.g().add(this.contentGroup))),
                this.renderTitle(),
                f(
                  v,
                  (J, K) =>
                    ((J.options && J.options.legendIndex) || 0) -
                    ((K.options && K.options.legendIndex) || 0)
                ),
                c.reversed && v.reverse(),
                (this.allItems = v),
                (this.display = X = !!v.length),
                (this.itemHeight =
                  this.totalItemWidth =
                  this.maxItemWidth =
                  this.lastLineHeight =
                    0),
                v.forEach(this.renderItem, this),
                v.forEach(this.layoutItem, this),
                (v = (this.widthOption || this.offsetWidth) + u),
                (N = this.lastItemY + this.lastLineHeight + this.titleHeight),
                (N = this.handleOverflow(N)),
                (N += u),
                R ||
                  (this.box = R =
                    r
                      .rect()
                      .addClass("highcharts-legend-box")
                      .attr({ r: c.borderRadius })
                      .add(w)),
                o.styledMode ||
                  R.attr({
                    stroke: c.borderColor,
                    "stroke-width": c.borderWidth || 0,
                    fill: c.backgroundColor || "none",
                  }).shadow(c.shadow),
                0 < v &&
                  0 < N &&
                  R[R.placed ? "animate" : "attr"](
                    R.crisp.call(
                      {},
                      { x: 0, y: 0, width: v, height: N },
                      R.strokeWidth()
                    )
                  ),
                w[X ? "show" : "hide"](),
                o.styledMode && w.getStyle("display") === "none" && (v = N = 0),
                (this.legendWidth = v),
                (this.legendHeight = N),
                X && this.align(),
                this.proximate || this.positionItems(),
                g(this, "afterRender");
            }
            align(o = this.chart.spacingBox) {
              const r = this.chart,
                c = this.options;
              let u = o.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < r.titleOffset[0]
                ? (u += r.titleOffset[0])
                : /(lbh|cb|rbh)/.test(this.getAlignment()) &&
                  0 < r.titleOffset[2] &&
                  (u -= r.titleOffset[2]),
                u !== o.y && (o = D(o, { y: u })),
                r.hasRendered || (this.group.placed = !1),
                this.group.align(
                  D(c, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? "top" : c.verticalAlign,
                  }),
                  !0,
                  o
                );
            }
            handleOverflow(o) {
              const r = this,
                c = this.chart,
                u = c.renderer,
                v = this.options;
              var N = v.y;
              const w = v.verticalAlign === "top",
                R = this.padding,
                X = v.maxHeight,
                J = v.navigation,
                K = A(J.animation, !0),
                H = J.arrowSize || 12,
                k = this.pages,
                U = this.allItems,
                _ = function (Q) {
                  typeof Q == "number"
                    ? V.attr({ height: Q })
                    : V && ((r.clipRect = V.destroy()), r.contentGroup.clip()),
                    r.contentGroup.div &&
                      (r.contentGroup.div.style.clip = Q
                        ? "rect(" + R + "px,9999px," + (R + Q) + "px,0)"
                        : "auto");
                },
                W = function (Q) {
                  return (
                    (r[Q] = u
                      .circle(0, 0, 1.3 * H)
                      .translate(H / 2, H / 2)
                      .add(F)),
                    c.styledMode || r[Q].attr("fill", "rgba(0,0,0,0.0001)"),
                    r[Q]
                  );
                };
              let tt, j, I;
              N = c.spacingBox.height + (w ? -N : N) - R;
              let F = this.nav,
                V = this.clipRect;
              return (
                v.layout !== "horizontal" ||
                  v.verticalAlign === "middle" ||
                  v.floating ||
                  (N /= 2),
                X && (N = Math.min(N, X)),
                (k.length = 0),
                o && 0 < N && o > N && J.enabled !== !1
                  ? ((this.clipHeight = tt =
                      Math.max(N - 20 - this.titleHeight - R, 0)),
                    (this.currentPage = A(this.currentPage, 1)),
                    (this.fullHeight = o),
                    U.forEach((Q, $) => {
                      (I = Q.legendItem || {}), (Q = I.y || 0);
                      const et = Math.round(I.label.getBBox().height);
                      let st = k.length;
                      (!st || (Q - k[st - 1] > tt && (j || Q) !== k[st - 1])) &&
                        (k.push(j || Q), st++),
                        (I.pageIx = st - 1),
                        j && ((U[$ - 1].legendItem || {}).pageIx = st - 1),
                        $ === U.length - 1 &&
                          Q + et - k[st - 1] > tt &&
                          Q > k[st - 1] &&
                          (k.push(Q), (I.pageIx = st)),
                        Q !== j && (j = Q);
                    }),
                    V ||
                      ((V = r.clipRect = u.clipRect(0, R - 2, 9999, 0)),
                      r.contentGroup.clip(V)),
                    _(tt),
                    F ||
                      ((this.nav = F =
                        u.g().attr({ zIndex: 1 }).add(this.group)),
                      (this.up = u.symbol("triangle", 0, 0, H, H).add(F)),
                      W("upTracker").on("click", function () {
                        r.scroll(-1, K);
                      }),
                      (this.pager = u
                        .text("", 15, 10)
                        .addClass("highcharts-legend-navigation")),
                      !c.styledMode && J.style && this.pager.css(J.style),
                      this.pager.add(F),
                      (this.down = u
                        .symbol("triangle-down", 0, 0, H, H)
                        .add(F)),
                      W("downTracker").on("click", function () {
                        r.scroll(1, K);
                      })),
                    r.scroll(0),
                    (o = N))
                  : F &&
                    (_(),
                    (this.nav = F.destroy()),
                    this.scrollGroup.attr({ translateY: 1 }),
                    (this.clipHeight = 0)),
                o
              );
            }
            scroll(o, r) {
              const c = this.chart,
                u = this.pages,
                v = u.length,
                N = this.clipHeight,
                w = this.options.navigation,
                R = this.pager,
                X = this.padding;
              let J = this.currentPage + o;
              J > v && (J = v),
                0 < J &&
                  (typeof r < "u" && L(r, c),
                  this.nav.attr({
                    translateX: X,
                    translateY: N + this.padding + 7 + this.titleHeight,
                    visibility: "inherit",
                  }),
                  [this.up, this.upTracker].forEach(function (K) {
                    K.attr({
                      class:
                        J === 1
                          ? "highcharts-legend-nav-inactive"
                          : "highcharts-legend-nav-active",
                    });
                  }),
                  R.attr({ text: J + "/" + v }),
                  [this.down, this.downTracker].forEach(function (K) {
                    K.attr({
                      x: 18 + this.pager.getBBox().width,
                      class:
                        J === v
                          ? "highcharts-legend-nav-inactive"
                          : "highcharts-legend-nav-active",
                    });
                  }, this),
                  c.styledMode ||
                    (this.up.attr({
                      fill: J === 1 ? w.inactiveColor : w.activeColor,
                    }),
                    this.upTracker.css({
                      cursor: J === 1 ? "default" : "pointer",
                    }),
                    this.down.attr({
                      fill: J === v ? w.inactiveColor : w.activeColor,
                    }),
                    this.downTracker.css({
                      cursor: J === v ? "default" : "pointer",
                    })),
                  (this.scrollOffset = -u[J - 1] + this.initialItemY),
                  this.scrollGroup.animate({ translateY: this.scrollOffset }),
                  (this.currentPage = J),
                  this.positionCheckboxes(),
                  (o = Y(A(r, c.renderer.globalAnimation, !0))),
                  b(() => {
                    g(this, "afterScroll", { currentPage: J });
                  }, o.duration));
            }
            setItemEvents(o, r, c) {
              const u = this,
                v = o.legendItem || {},
                N = u.chart.renderer.boxWrapper,
                w = o instanceof O,
                R = "highcharts-legend-" + (w ? "point" : "series") + "-active",
                X = u.chart.styledMode;
              c = c ? [r, v.symbol] : [v.group];
              const J = (K) => {
                u.allItems.forEach((H) => {
                  o !== H &&
                    [H].concat(H.linkedSeries || []).forEach((k) => {
                      k.setState(K, !w);
                    });
                });
              };
              for (const K of c)
                K &&
                  K.on("mouseover", function () {
                    o.visible && J("inactive"),
                      o.setState("hover"),
                      o.visible && N.addClass(R),
                      X || r.css(u.options.itemHoverStyle);
                  })
                    .on("mouseout", function () {
                      u.chart.styledMode ||
                        r.css(D(o.visible ? u.itemStyle : u.itemHiddenStyle)),
                        J(""),
                        N.removeClass(R),
                        o.setState();
                    })
                    .on("click", function (H) {
                      const k = function () {
                        o.setVisible && o.setVisible(),
                          J(o.visible ? "inactive" : "");
                      };
                      N.removeClass(R),
                        (H = { browserEvent: H }),
                        o.firePointEvent
                          ? o.firePointEvent("legendItemClick", H, k)
                          : g(o, "legendItemClick", H, k);
                    });
            }
            createCheckboxForItem(o) {
              (o.checkbox = P(
                "input",
                {
                  type: "checkbox",
                  className: "highcharts-legend-checkbox",
                  checked: o.selected,
                  defaultChecked: o.selected,
                },
                this.options.itemCheckboxStyle,
                this.chart.container
              )),
                x(o.checkbox, "click", function (r) {
                  g(
                    o.series || o,
                    "checkboxClick",
                    { checked: r.target.checked, item: o },
                    function () {
                      o.select();
                    }
                  );
                });
            }
          }
          return (
            (function (C) {
              const o = [];
              C.compose = function (r) {
                G.pushUnique(o, r) &&
                  x(r, "beforeMargins", function () {
                    this.legend = new C(this, this.options.legend);
                  });
              };
            })(y || (y = {})),
            y
          );
        }
      ),
      n(
        i,
        "Core/Legend/LegendSymbol.js",
        [i["Core/Utilities.js"]],
        function (a) {
          const { extend: d, merge: M, pick: O } = a;
          var B;
          return (
            (function (G) {
              (G.lineMarker = function (Y, L) {
                L = this.legendItem = this.legendItem || {};
                var E = this.options;
                const z = Y.symbolWidth,
                  S = Y.symbolHeight,
                  x = S / 2,
                  P = this.chart.renderer,
                  h = L.group;
                Y = Y.baseline - Math.round(0.3 * Y.fontMetrics.b);
                let s = {},
                  l = E.marker,
                  p = 0;
                this.chart.styledMode ||
                  ((s = { "stroke-width": Math.min(E.lineWidth || 0, 24) }),
                  E.dashStyle
                    ? (s.dashstyle = E.dashStyle)
                    : E.linecap !== "square" &&
                      (s["stroke-linecap"] = "round")),
                  (L.line = P.path()
                    .addClass("highcharts-graph")
                    .attr(s)
                    .add(h)),
                  s["stroke-linecap"] &&
                    (p = Math.min(L.line.strokeWidth(), z) / 2),
                  z &&
                    L.line.attr({
                      d: [
                        ["M", p, Y],
                        ["L", z - p, Y],
                      ],
                    }),
                  l &&
                    l.enabled !== !1 &&
                    z &&
                    ((E = Math.min(O(l.radius, x), x)),
                    this.symbol.indexOf("url") === 0 &&
                      ((l = M(l, { width: S, height: S })), (E = 0)),
                    (L.symbol = L =
                      P.symbol(
                        this.symbol,
                        z / 2 - E,
                        Y - E,
                        2 * E,
                        2 * E,
                        d({ context: "legend" }, l)
                      )
                        .addClass("highcharts-point")
                        .add(h)),
                    (L.isMarker = !0));
              }),
                (G.rectangle = function (Y, L) {
                  L = L.legendItem || {};
                  const E = Y.symbolHeight,
                    z = Y.options.squareSymbol;
                  L.symbol = this.chart.renderer
                    .rect(
                      z ? (Y.symbolWidth - E) / 2 : 0,
                      Y.baseline - E + 1,
                      z ? E : Y.symbolWidth,
                      E,
                      O(Y.options.symbolRadius, E / 2)
                    )
                    .addClass("highcharts-point")
                    .attr({ zIndex: 3 })
                    .add(L.group);
                });
            })(B || (B = {})),
            B
          );
        }
      ),
      n(i, "Core/Series/SeriesDefaults.js", [], function () {
        return {
          lineWidth: 1,
          allowPointSelect: !1,
          crisp: !0,
          showCheckbox: !1,
          animation: { duration: 1e3 },
          enableMouseTracking: !0,
          events: {},
          marker: {
            enabledThreshold: 2,
            lineColor: "#ffffff",
            lineWidth: 0,
            radius: 4,
            states: {
              normal: { animation: !0 },
              hover: {
                animation: { duration: 150 },
                enabled: !0,
                radiusPlus: 2,
                lineWidthPlus: 1,
              },
              select: {
                fillColor: "#cccccc",
                lineColor: "#000000",
                lineWidth: 2,
              },
            },
          },
          point: { events: {} },
          dataLabels: {
            animation: {},
            align: "center",
            borderWidth: 0,
            defer: !0,
            formatter: function () {
              const { numberFormatter: a } = this.series.chart;
              return typeof this.y != "number" ? "" : a(this.y, -1);
            },
            padding: 5,
            style: {
              fontSize: "0.7em",
              fontWeight: "bold",
              color: "contrast",
              textOutline: "1px contrast",
            },
            verticalAlign: "bottom",
            x: 0,
            y: 0,
          },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: !0,
          states: {
            normal: { animation: !0 },
            hover: {
              animation: { duration: 150 },
              lineWidthPlus: 1,
              marker: {},
              halo: { size: 10, opacity: 0.25 },
            },
            select: { animation: { duration: 0 } },
            inactive: { animation: { duration: 150 }, opacity: 0.2 },
          },
          stickyTracking: !0,
          turboThreshold: 1e3,
          findNearestPointBy: "x",
        };
      }),
      n(
        i,
        "Core/Series/SeriesRegistry.js",
        [
          i["Core/Globals.js"],
          i["Core/Defaults.js"],
          i["Core/Series/Point.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O) {
          const { defaultOptions: B } = d,
            { extendClass: G, merge: Y } = O;
          var L;
          return (
            (function (E) {
              function z(S, x) {
                const P = B.plotOptions || {},
                  h = x.defaultOptions,
                  s = x.prototype;
                (s.type = S),
                  s.pointClass || (s.pointClass = M),
                  h && (P[S] = h),
                  (E.seriesTypes[S] = x);
              }
              (E.seriesTypes = a.seriesTypes),
                (E.registerSeriesType = z),
                (E.seriesType = function (S, x, P, h, s) {
                  const l = B.plotOptions || {};
                  return (
                    (x = x || ""),
                    (l[S] = Y(l[x], P)),
                    z(S, G(E.seriesTypes[x] || function () {}, h)),
                    (E.seriesTypes[S].prototype.type = S),
                    s && (E.seriesTypes[S].prototype.pointClass = G(M, s)),
                    E.seriesTypes[S]
                  );
                });
            })(L || (L = {})),
            L
          );
        }
      ),
      n(
        i,
        "Core/Series/Series.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Defaults.js"],
          i["Core/Foundation.js"],
          i["Core/Globals.js"],
          i["Core/Legend/LegendSymbol.js"],
          i["Core/Series/Point.js"],
          i["Core/Series/SeriesDefaults.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G, Y, L, E, z) {
          const { animObject: S, setAnimation: x } = a,
            { defaultOptions: P } = d,
            { registerEventOptions: h } = M,
            { hasTouch: s, svg: l, win: p } = O,
            { seriesTypes: g } = L,
            {
              arrayMax: T,
              arrayMin: D,
              clamp: A,
              correctFloat: m,
              defined: f,
              diffObjects: b,
              erase: y,
              error: C,
              extend: o,
              find: r,
              fireEvent: c,
              getClosestDistance: u,
              getNestedProperty: v,
              insertItem: N,
              isArray: w,
              isNumber: R,
              isString: X,
              merge: J,
              objectEach: K,
              pick: H,
              removeEvent: k,
              splat: U,
              syncTimeout: _,
            } = z;
          class W {
            constructor() {
              this.zones =
                this.yAxis =
                this.xAxis =
                this.userOptions =
                this.tooltipOptions =
                this.processedYData =
                this.processedXData =
                this.points =
                this.options =
                this.linkedSeries =
                this.index =
                this.eventsToUnbind =
                this.eventOptions =
                this.data =
                this.chart =
                this._i =
                  void 0;
            }
            init(j, I) {
              c(this, "init", { options: I });
              const F = this,
                V = j.series;
              (this.eventsToUnbind = []),
                (F.chart = j),
                (F.options = F.setOptions(I)),
                (I = F.options),
                (F.linkedSeries = []),
                F.bindAxes(),
                o(F, {
                  name: I.name,
                  state: "",
                  visible: I.visible !== !1,
                  selected: I.selected === !0,
                }),
                h(this, I);
              const Q = I.events;
              ((Q && Q.click) ||
                (I.point && I.point.events && I.point.events.click) ||
                I.allowPointSelect) &&
                (j.runTrackerClick = !0),
                F.getColor(),
                F.getSymbol(),
                F.parallelArrays.forEach(function (et) {
                  F[et + "Data"] || (F[et + "Data"] = []);
                }),
                F.isCartesian && (j.hasCartesianSeries = !0);
              let $;
              V.length && ($ = V[V.length - 1]),
                (F._i = H($ && $._i, -1) + 1),
                (F.opacity = F.options.opacity),
                j.orderItems("series", N(this, V)),
                I.dataSorting && I.dataSorting.enabled
                  ? F.setDataSortingOptions()
                  : F.points || F.data || F.setData(I.data, !1),
                c(this, "afterInit");
            }
            is(j) {
              return g[j] && this instanceof g[j];
            }
            bindAxes() {
              const j = this,
                I = j.options,
                F = j.chart;
              let V;
              c(this, "bindAxes", null, function () {
                (j.axisTypes || []).forEach(function (Q) {
                  F[Q].forEach(function ($) {
                    (V = $.options),
                      (H(I[Q], 0) === $.index ||
                        (typeof I[Q] < "u" && I[Q] === V.id)) &&
                        (N(j, $.series), (j[Q] = $), ($.isDirty = !0));
                  }),
                    j[Q] || j.optionalAxis === Q || C(18, !0, F);
                });
              }),
                c(this, "afterBindAxes");
            }
            updateParallelArrays(j, I, F) {
              const V = j.series,
                Q = R(I)
                  ? function ($) {
                      const et = $ === "y" && V.toYData ? V.toYData(j) : j[$];
                      V[$ + "Data"][I] = et;
                    }
                  : function ($) {
                      Array.prototype[I].apply(V[$ + "Data"], F);
                    };
              V.parallelArrays.forEach(Q);
            }
            hasData() {
              return (
                (this.visible &&
                  typeof this.dataMax < "u" &&
                  typeof this.dataMin < "u") ||
                (this.visible && this.yData && 0 < this.yData.length)
              );
            }
            autoIncrement(j) {
              var I = this.options;
              const F = I.pointIntervalUnit,
                V = I.relativeXValue,
                Q = this.chart.time;
              let $ = this.xIncrement,
                et;
              return (
                ($ = H($, I.pointStart, 0)),
                (this.pointInterval = et =
                  H(this.pointInterval, I.pointInterval, 1)),
                V && R(j) && (et *= j),
                F &&
                  ((I = new Q.Date($)),
                  F === "day"
                    ? Q.set("Date", I, Q.get("Date", I) + et)
                    : F === "month"
                    ? Q.set("Month", I, Q.get("Month", I) + et)
                    : F === "year" &&
                      Q.set("FullYear", I, Q.get("FullYear", I) + et),
                  (et = I.getTime() - $)),
                V && R(j) ? $ + et : ((this.xIncrement = $ + et), $)
              );
            }
            setDataSortingOptions() {
              const j = this.options;
              o(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1,
              }),
                f(j.pointRange) || (j.pointRange = 1);
            }
            setOptions(j) {
              var I, F;
              const V = this.chart;
              var Q = V.options.plotOptions,
                $ = V.userOptions || {};
              const et = J(j);
              j = V.styledMode;
              const st = { plotOptions: Q, userOptions: et };
              c(this, "setOptions", st);
              const ot = st.plotOptions[this.type];
              $ = $.plotOptions || {};
              const at = $.series || {},
                lt = P.plotOptions[this.type] || {},
                Z = $[this.type] || {};
              return (
                (this.userOptions = st.userOptions),
                (Q = J(ot, Q.series, Z, et)),
                (this.tooltipOptions = J(
                  P.tooltip,
                  (I = P.plotOptions.series) === null || I === void 0
                    ? void 0
                    : I.tooltip,
                  lt == null ? void 0 : lt.tooltip,
                  V.userOptions.tooltip,
                  (F = $.series) === null || F === void 0 ? void 0 : F.tooltip,
                  Z.tooltip,
                  et.tooltip
                )),
                (this.stickyTracking = H(
                  et.stickyTracking,
                  Z.stickyTracking,
                  at.stickyTracking,
                  this.tooltipOptions.shared && !this.noSharedTooltip
                    ? !0
                    : Q.stickyTracking
                )),
                ot.marker === null && delete Q.marker,
                (this.zoneAxis = Q.zoneAxis),
                (F = this.zones = (Q.zones || []).slice()),
                (!Q.negativeColor && !Q.negativeFillColor) ||
                  Q.zones ||
                  ((I = {
                    value: Q[this.zoneAxis + "Threshold"] || Q.threshold || 0,
                    className: "highcharts-negative",
                  }),
                  j ||
                    ((I.color = Q.negativeColor),
                    (I.fillColor = Q.negativeFillColor)),
                  F.push(I)),
                F.length &&
                  f(F[F.length - 1].value) &&
                  F.push(
                    j ? {} : { color: this.color, fillColor: this.fillColor }
                  ),
                c(this, "afterSetOptions", { options: Q }),
                Q
              );
            }
            getName() {
              return H(this.options.name, "Series " + (this.index + 1));
            }
            getCyclic(j, I, F) {
              const V = this.chart,
                Q = `${j}Index`,
                $ = `${j}Counter`,
                et =
                  (F == null ? void 0 : F.length) || V.options.chart.colorCount;
              if (!I) {
                var st = H(
                  j === "color" ? this.options.colorIndex : void 0,
                  this[Q]
                );
                f(st) ||
                  (V.series.length || (V[$] = 0),
                  (st = V[$] % et),
                  (V[$] += 1)),
                  F && (I = F[st]);
              }
              typeof st < "u" && (this[Q] = st), (this[j] = I);
            }
            getColor() {
              this.chart.styledMode
                ? this.getCyclic("color")
                : this.options.colorByPoint
                ? (this.color = "#cccccc")
                : this.getCyclic(
                    "color",
                    this.options.color || P.plotOptions[this.type].color,
                    this.chart.options.colors
                  );
            }
            getPointsCollection() {
              return (this.hasGroupedData ? this.points : this.data) || [];
            }
            getSymbol() {
              this.getCyclic(
                "symbol",
                this.options.marker.symbol,
                this.chart.options.symbols
              );
            }
            findPointIndex(j, I) {
              const F = j.id,
                V = j.x,
                Q = this.points;
              var $ = this.options.dataSorting,
                et;
              let st, ot;
              if (F) ($ = this.chart.get(F)), $ instanceof G && (et = $);
              else if (
                (this.linkedParent ||
                  this.enabledDataSorting ||
                  this.options.relativeXValue) &&
                ((et = (at) => !at.touched && at.index === j.index),
                $ && $.matchByName
                  ? (et = (at) => !at.touched && at.name === j.name)
                  : this.options.relativeXValue &&
                    (et = (at) => !at.touched && at.options.x === j.x),
                (et = r(Q, et)),
                !et)
              )
                return;
              return (
                et && ((ot = et && et.index), typeof ot < "u" && (st = !0)),
                typeof ot > "u" && R(V) && (ot = this.xData.indexOf(V, I)),
                ot !== -1 &&
                  typeof ot < "u" &&
                  this.cropped &&
                  (ot = ot >= this.cropStart ? ot - this.cropStart : ot),
                !st && R(ot) && Q[ot] && Q[ot].touched && (ot = void 0),
                ot
              );
            }
            updateData(j, I) {
              const F = this.options,
                V = F.dataSorting,
                Q = this.points,
                $ = [],
                et = this.requireSorting,
                st = j.length === Q.length;
              let ot,
                at,
                lt,
                Z = !0;
              if (
                ((this.xIncrement = null),
                j.forEach(function (q, nt) {
                  var it =
                    (f(q) &&
                      this.pointClass.prototype.optionsToObject.call(
                        { series: this },
                        q
                      )) ||
                    {};
                  const rt = it.x;
                  it.id || R(rt)
                    ? ((it = this.findPointIndex(it, lt)),
                      it === -1 || typeof it > "u"
                        ? $.push(q)
                        : Q[it] && q !== F.data[it]
                        ? (Q[it].update(q, !1, null, !1),
                          (Q[it].touched = !0),
                          et && (lt = it + 1))
                        : Q[it] && (Q[it].touched = !0),
                      (!st ||
                        nt !== it ||
                        (V && V.enabled) ||
                        this.hasDerivedData) &&
                        (ot = !0))
                    : $.push(q);
                }, this),
                ot)
              )
                for (j = Q.length; j--; )
                  (at = Q[j]) && !at.touched && at.remove && at.remove(!1, I);
              else
                !st || (V && V.enabled)
                  ? (Z = !1)
                  : (j.forEach(function (q, nt) {
                      q === Q[nt].y ||
                        Q[nt].destroyed ||
                        Q[nt].update(q, !1, null, !1);
                    }),
                    ($.length = 0));
              return (
                Q.forEach(function (q) {
                  q && (q.touched = !1);
                }),
                Z
                  ? ($.forEach(function (q) {
                      this.addPoint(q, !1, null, null, !1);
                    }, this),
                    this.xIncrement === null &&
                      this.xData &&
                      this.xData.length &&
                      ((this.xIncrement = T(this.xData)), this.autoIncrement()),
                    !0)
                  : !1
              );
            }
            setData(j, I = !0, F, V) {
              var Q;
              const $ = this,
                et = $.points,
                st = (et && et.length) || 0,
                ot = $.options,
                at = $.chart,
                lt = ot.dataSorting,
                Z = $.xAxis,
                q = ot.turboThreshold,
                nt = this.xData,
                it = this.yData;
              var rt = $.pointArrayMap;
              rt = rt && rt.length;
              const ht = ot.keys;
              let ct,
                ft = 0,
                yt = 1,
                ut = null;
              if (!at.options.chart.allowMutatingData) {
                ot.data && delete $.options.data,
                  $.userOptions.data && delete $.userOptions.data;
                var gt = J(!0, j);
              }
              if (
                ((j = gt || j || []),
                (gt = j.length),
                lt && lt.enabled && (j = this.sortData(j)),
                at.options.chart.allowMutatingData &&
                  V !== !1 &&
                  gt &&
                  st &&
                  !$.cropped &&
                  !$.hasGroupedData &&
                  $.visible &&
                  !$.boosted &&
                  (ct = this.updateData(j, F)),
                !ct)
              ) {
                if (
                  (($.xIncrement = null),
                  ($.colorCounter = 0),
                  this.parallelArrays.forEach(function (wt) {
                    $[wt + "Data"].length = 0;
                  }),
                  q && gt > q)
                )
                  if (((ut = $.getFirstValidPoint(j)), R(ut)))
                    for (F = 0; F < gt; F++)
                      (nt[F] = this.autoIncrement()), (it[F] = j[F]);
                  else if (w(ut))
                    if (rt)
                      if (ut.length === rt)
                        for (F = 0; F < gt; F++)
                          (nt[F] = this.autoIncrement()), (it[F] = j[F]);
                      else
                        for (F = 0; F < gt; F++)
                          (V = j[F]),
                            (nt[F] = V[0]),
                            (it[F] = V.slice(1, rt + 1));
                    else if (
                      (ht &&
                        ((ft = ht.indexOf("x")),
                        (yt = ht.indexOf("y")),
                        (ft = 0 <= ft ? ft : 0),
                        (yt = 0 <= yt ? yt : 1)),
                      ut.length === 1 && (yt = 0),
                      ft === yt)
                    )
                      for (F = 0; F < gt; F++)
                        (nt[F] = this.autoIncrement()), (it[F] = j[F][yt]);
                    else
                      for (F = 0; F < gt; F++)
                        (V = j[F]), (nt[F] = V[ft]), (it[F] = V[yt]);
                  else C(12, !1, at);
                else
                  for (F = 0; F < gt; F++)
                    (V = { series: $ }),
                      $.pointClass.prototype.applyOptions.apply(V, [j[F]]),
                      $.updateParallelArrays(V, F);
                for (
                  it && X(it[0]) && C(14, !0, at),
                    $.data = [],
                    $.options.data = $.userOptions.data = j,
                    F = st;
                  F--;

                )
                  (Q = et[F]) === null || Q === void 0 || Q.destroy();
                Z && (Z.minRange = Z.userMinRange),
                  ($.isDirty = at.isDirtyBox = !0),
                  ($.isDirtyData = !!et),
                  (F = !1);
              }
              ot.legendType === "point" &&
                (this.processData(), this.generatePoints()),
                I && at.redraw(F);
            }
            sortData(j) {
              const I = this,
                F = I.options.dataSorting.sortKey || "y",
                V = function (Q, $) {
                  return (
                    (f($) &&
                      Q.pointClass.prototype.optionsToObject.call(
                        { series: Q },
                        $
                      )) ||
                    {}
                  );
                };
              return (
                j.forEach(function (Q, $) {
                  (j[$] = V(I, Q)), (j[$].index = $);
                }, this),
                j
                  .concat()
                  .sort(
                    (Q, $) => (
                      (Q = v(F, Q)), ($ = v(F, $)), $ < Q ? -1 : $ > Q ? 1 : 0
                    )
                  )
                  .forEach(function (Q, $) {
                    Q.x = $;
                  }, this),
                I.linkedSeries &&
                  I.linkedSeries.forEach(function (Q) {
                    const $ = Q.options,
                      et = $.data;
                    ($.dataSorting && $.dataSorting.enabled) ||
                      !et ||
                      (et.forEach(function (st, ot) {
                        (et[ot] = V(Q, st)),
                          j[ot] && ((et[ot].x = j[ot].x), (et[ot].index = ot));
                      }),
                      Q.setData(et, !1));
                  }),
                j
              );
            }
            getProcessedData(j) {
              const I = this;
              var F = I.xAxis,
                V = I.options;
              const Q = V.cropThreshold,
                $ = j || I.getExtremesFromAll || V.getExtremesFromAll,
                et = F == null ? void 0 : F.logarithmic,
                st = I.isCartesian;
              let ot = 0,
                at;
              (j = I.xData), (V = I.yData);
              let lt = !1;
              const Z = j.length;
              if (F) {
                var q = F.getExtremes();
                (at = q.min),
                  (q = q.max),
                  (lt = !(!F.categories || F.names.length));
              }
              if (st && I.sorted && !$ && (!Q || Z > Q || I.forceCrop)) {
                if (j[Z - 1] < at || j[0] > q) (j = []), (V = []);
                else if (I.yData && (j[0] < at || j[Z - 1] > q)) {
                  var nt = this.cropData(I.xData, I.yData, at, q);
                  (j = nt.xData), (V = nt.yData), (ot = nt.start), (nt = !0);
                }
              }
              return (
                (F = u(
                  [et ? j.map(et.log2lin) : j],
                  () => I.requireSorting && !lt && C(15, !1, I.chart)
                )),
                {
                  xData: j,
                  yData: V,
                  cropped: nt,
                  cropStart: ot,
                  closestPointRange: F,
                }
              );
            }
            processData(j) {
              const I = this.xAxis;
              if (
                this.isCartesian &&
                !this.isDirty &&
                !I.isDirty &&
                !this.yAxis.isDirty &&
                !j
              )
                return !1;
              (j = this.getProcessedData()),
                (this.cropped = j.cropped),
                (this.cropStart = j.cropStart),
                (this.processedXData = j.xData),
                (this.processedYData = j.yData),
                (this.closestPointRange = this.basePointRange =
                  j.closestPointRange),
                c(this, "afterProcessData");
            }
            cropData(j, I, F, V, Q) {
              const $ = j.length;
              let et,
                st = 0,
                ot = $;
              for (Q = H(Q, this.cropShoulder), et = 0; et < $; et++)
                if (j[et] >= F) {
                  st = Math.max(0, et - Q);
                  break;
                }
              for (F = et; F < $; F++)
                if (j[F] > V) {
                  ot = F + Q;
                  break;
                }
              return {
                xData: j.slice(st, ot),
                yData: I.slice(st, ot),
                start: st,
                end: ot,
              };
            }
            generatePoints() {
              var j = this.options;
              const I = this.processedData || j.data,
                F = this.processedXData,
                V = this.processedYData,
                Q = this.pointClass,
                $ = F.length,
                et = this.cropStart || 0,
                st = this.hasGroupedData,
                ot = j.keys,
                at = [];
              j = j.dataGrouping && j.dataGrouping.groupAll ? et : 0;
              let lt,
                Z,
                q,
                nt = this.data;
              if (!nt && !st) {
                var it = [];
                (it.length = I.length), (nt = this.data = it);
              }
              for (ot && st && (this.options.keys = !1), q = 0; q < $; q++)
                (it = et + q),
                  st
                    ? ((Z = new Q().init(this, [F[q]].concat(U(V[q])))),
                      (Z.dataGroup = this.groupMap[j + q]),
                      Z.dataGroup.options &&
                        ((Z.options = Z.dataGroup.options),
                        o(Z, Z.dataGroup.options),
                        delete Z.dataLabels))
                    : (Z = nt[it]) ||
                      typeof I[it] > "u" ||
                      (nt[it] = Z = new Q().init(this, I[it], F[q])),
                  Z && ((Z.index = st ? j + q : it), (at[q] = Z));
              if (
                ((this.options.keys = ot), nt && ($ !== (lt = nt.length) || st))
              )
                for (q = 0; q < lt; q++)
                  q !== et || st || (q += $),
                    nt[q] && (nt[q].destroyElements(), (nt[q].plotX = void 0));
              (this.data = nt),
                (this.points = at),
                c(this, "afterGeneratePoints");
            }
            getXExtremes(j) {
              return { min: D(j), max: T(j) };
            }
            getExtremes(j, I) {
              const F = this.xAxis;
              var V = this.yAxis;
              const Q = this.processedXData || this.xData,
                $ = [],
                et = this.requireSorting ? this.cropShoulder : 0;
              V = V ? V.positiveValuesOnly : !1;
              let st,
                ot = 0,
                at = 0,
                lt = 0;
              j = j || this.stackedYData || this.processedYData || [];
              const Z = j.length;
              if (F) {
                var q = F.getExtremes();
                (ot = q.min), (at = q.max);
              }
              for (st = 0; st < Z; st++) {
                var nt = Q[st];
                q = j[st];
                var it = (R(q) || w(q)) && (q.length || 0 < q || !V);
                if (
                  ((nt =
                    I ||
                    this.getExtremesFromAll ||
                    this.options.getExtremesFromAll ||
                    this.cropped ||
                    !F ||
                    ((Q[st + et] || nt) >= ot && (Q[st - et] || nt) <= at)),
                  it && nt)
                )
                  if ((it = q.length))
                    for (; it--; ) R(q[it]) && ($[lt++] = q[it]);
                  else $[lt++] = q;
              }
              return (
                (j = { activeYData: $, dataMin: D($), dataMax: T($) }),
                c(this, "afterGetExtremes", { dataExtremes: j }),
                j
              );
            }
            applyExtremes() {
              const j = this.getExtremes();
              return (this.dataMin = j.dataMin), (this.dataMax = j.dataMax), j;
            }
            getFirstValidPoint(j) {
              const I = j.length;
              let F = 0,
                V = null;
              for (; V === null && F < I; ) (V = j[F]), F++;
              return V;
            }
            translate() {
              var j;
              this.processedXData || this.processData(), this.generatePoints();
              var I = this.options;
              const F = I.stacking,
                V = this.xAxis,
                Q = V.categories,
                $ = this.enabledDataSorting,
                et = this.yAxis,
                st = this.points,
                ot = st.length,
                at = this.pointPlacementToXValue(),
                lt = !!at,
                Z = I.threshold;
              I = I.startFromThreshold ? Z : 0;
              let q,
                nt,
                it,
                rt,
                ht = Number.MAX_VALUE;
              for (q = 0; q < ot; q++) {
                const ct = st[q],
                  ft = ct.x;
                let yt,
                  ut,
                  gt = ct.y,
                  wt = ct.low;
                const xt =
                  F &&
                  ((j = et.stacking) === null || j === void 0
                    ? void 0
                    : j.stacks[
                        (this.negStacks && gt < (I ? 0 : Z) ? "-" : "") +
                          this.stackKey
                      ]);
                (nt = V.translate(ft, !1, !1, !1, !0, at)),
                  (ct.plotX = R(nt) ? m(A(nt, -1e5, 1e5)) : void 0),
                  F &&
                    this.visible &&
                    xt &&
                    xt[ft] &&
                    ((rt = this.getStackIndicator(rt, ft, this.index)),
                    !ct.isNull &&
                      rt.key &&
                      ((yt = xt[ft]), (ut = yt.points[rt.key])),
                    yt &&
                      w(ut) &&
                      ((wt = ut[0]),
                      (gt = ut[1]),
                      wt === I &&
                        rt.key === xt[ft].base &&
                        (wt = H(R(Z) ? Z : et.min)),
                      et.positiveValuesOnly &&
                        f(wt) &&
                        0 >= wt &&
                        (wt = void 0),
                      (ct.total = ct.stackTotal = H(yt.total)),
                      (ct.percentage =
                        f(ct.y) && yt.total ? (ct.y / yt.total) * 100 : void 0),
                      (ct.stackY = gt),
                      this.irregularWidths ||
                        yt.setOffset(
                          this.pointXOffset || 0,
                          this.barW || 0,
                          void 0,
                          void 0,
                          void 0,
                          this.xAxis
                        ))),
                  (ct.yBottom = f(wt)
                    ? A(et.translate(wt, !1, !0, !1, !0), -1e5, 1e5)
                    : void 0),
                  this.dataModify && (gt = this.dataModify.modifyValue(gt, q));
                let St;
                R(gt) &&
                  ct.plotX !== void 0 &&
                  ((St = et.translate(gt, !1, !0, !1, !0)),
                  (St = R(St) ? A(St, -1e5, 1e5) : void 0)),
                  (ct.plotY = St),
                  (ct.isInside = this.isPointInside(ct)),
                  (ct.clientX = lt
                    ? m(V.translate(ft, !1, !1, !1, !0, at))
                    : nt),
                  (ct.negative = (ct.y || 0) < (Z || 0)),
                  (ct.category = H(Q && Q[ct.x], ct.x)),
                  ct.isNull ||
                    ct.visible === !1 ||
                    (typeof it < "u" && (ht = Math.min(ht, Math.abs(nt - it))),
                    (it = nt)),
                  (ct.zone = this.zones.length ? ct.getZone() : void 0),
                  !ct.graphic && this.group && $ && (ct.isNew = !0);
              }
              (this.closestPointRangePx = ht), c(this, "afterTranslate");
            }
            getValidPoints(j, I, F) {
              const V = this.chart;
              return (j || this.points || []).filter(function (Q) {
                const { plotX: $, plotY: et } = Q;
                return (!F && (Q.isNull || !R(et))) ||
                  (I && !V.isInsidePlot($, et, { inverted: V.inverted }))
                  ? !1
                  : Q.visible !== !1;
              });
            }
            getClipBox() {
              const { chart: j, xAxis: I, yAxis: F } = this,
                V = J(j.clipBox);
              return (
                I && I.len !== j.plotSizeX && (V.width = I.len),
                F && F.len !== j.plotSizeY && (V.height = F.len),
                V
              );
            }
            getSharedClipKey() {
              return (this.sharedClipKey =
                (this.options.xAxis || 0) + "," + (this.options.yAxis || 0));
            }
            setClip() {
              const { chart: j, group: I, markerGroup: F } = this,
                V = j.sharedClips,
                Q = j.renderer,
                $ = this.getClipBox(),
                et = this.getSharedClipKey();
              let st = V[et];
              st ? st.animate($) : (V[et] = st = Q.clipRect($)),
                I && I.clip(this.options.clip === !1 ? void 0 : st),
                F && F.clip();
            }
            animate(j) {
              const { chart: I, group: F, markerGroup: V } = this,
                Q = I.inverted;
              var $ = S(this.options.animation),
                et = [
                  this.getSharedClipKey(),
                  $.duration,
                  $.easing,
                  $.defer,
                ].join();
              let st = I.sharedClips[et],
                ot = I.sharedClips[et + "m"];
              if (j && F)
                ($ = this.getClipBox()),
                  st
                    ? st.attr("height", $.height)
                    : (($.width = 0),
                      Q && ($.x = I.plotHeight),
                      (st = I.renderer.clipRect($)),
                      (I.sharedClips[et] = st),
                      (ot = I.renderer.clipRect({
                        x: -99,
                        y: -99,
                        width: Q ? I.plotWidth + 199 : 99,
                        height: Q ? 99 : I.plotHeight + 199,
                      })),
                      (I.sharedClips[et + "m"] = ot)),
                  F.clip(st),
                  V && V.clip(ot);
              else if (st && !st.hasClass("highcharts-animating")) {
                et = this.getClipBox();
                const at = $.step;
                V &&
                  V.element.childNodes.length &&
                  ($.step = function (lt, Z) {
                    at && at.apply(Z, arguments),
                      Z.prop === "width" &&
                        ot &&
                        ot.element &&
                        ot.attr(Q ? "height" : "width", lt + 99);
                  }),
                  st.addClass("highcharts-animating").animate(et, $);
              }
            }
            afterAnimate() {
              this.setClip(),
                K(this.chart.sharedClips, (j, I, F) => {
                  j &&
                    !this.chart.container.querySelector(
                      `[clip-path="url(#${j.id})"]`
                    ) &&
                    (j.destroy(), delete F[I]);
                }),
                (this.finishedAnimating = !0),
                c(this, "afterAnimate");
            }
            drawPoints(j = this.points) {
              const I = this.chart,
                F = I.styledMode,
                { colorAxis: V, options: Q } = this,
                $ = Q.marker,
                et = this[this.specialGroup || "markerGroup"],
                st = this.xAxis,
                ot = H(
                  $.enabled,
                  !st || st.isRadial ? !0 : null,
                  this.closestPointRangePx >= $.enabledThreshold * $.radius
                );
              let at, lt, Z, q, nt, it;
              if ($.enabled !== !1 || this._hasPointMarkers)
                for (at = 0; at < j.length; at++) {
                  (lt = j[at]), (q = (Z = lt.graphic) ? "animate" : "attr");
                  var rt = lt.marker || {};
                  if (
                    ((nt = !!lt.marker),
                    ((ot && typeof rt.enabled > "u") || rt.enabled) &&
                      !lt.isNull &&
                      lt.visible !== !1)
                  ) {
                    const ht = H(rt.symbol, this.symbol, "rect");
                    (it = this.markerAttribs(lt, lt.selected && "select")),
                      this.enabledDataSorting &&
                        (lt.startXPos = st.reversed
                          ? -(it.width || 0)
                          : st.width);
                    const ct = lt.isInside !== !1;
                    !Z &&
                      ct &&
                      (0 < (it.width || 0) || lt.hasImage) &&
                      ((lt.graphic = Z =
                        I.renderer
                          .symbol(
                            ht,
                            it.x,
                            it.y,
                            it.width,
                            it.height,
                            nt ? rt : $
                          )
                          .add(et)),
                      this.enabledDataSorting &&
                        I.hasRendered &&
                        (Z.attr({ x: lt.startXPos }), (q = "animate"))),
                      Z &&
                        q === "animate" &&
                        Z[ct ? "show" : "hide"](ct).animate(it),
                      Z &&
                        ((rt = this.pointAttribs(
                          lt,
                          F || !lt.selected ? void 0 : "select"
                        )),
                        F ? V && Z.css({ fill: rt.fill }) : Z[q](rt)),
                      Z && Z.addClass(lt.getClassName(), !0);
                  } else Z && (lt.graphic = Z.destroy());
                }
            }
            markerAttribs(j, I) {
              const F = this.options;
              var V = F.marker;
              const Q = j.marker || {},
                $ = Q.symbol || V.symbol,
                et = {};
              let st = H(Q.radius, V && V.radius);
              return (
                I &&
                  ((V = V.states[I]),
                  (I = Q.states && Q.states[I]),
                  (st = H(
                    I && I.radius,
                    V && V.radius,
                    st && st + ((V && V.radiusPlus) || 0)
                  ))),
                (j.hasImage = $ && $.indexOf("url") === 0),
                j.hasImage && (st = 0),
                (j = j.pos()),
                R(st) &&
                  j &&
                  ((et.x = j[0] - st),
                  (et.y = j[1] - st),
                  F.crisp && (et.x = Math.floor(et.x))),
                st && (et.width = et.height = 2 * st),
                et
              );
            }
            pointAttribs(j, I) {
              var F = this.options.marker,
                V = j && j.options;
              const Q = (V && V.marker) || {};
              var $ = V && V.color,
                et = j && j.color;
              const st = j && j.zone && j.zone.color;
              let ot = this.color;
              return (
                (j = H(Q.lineWidth, F.lineWidth)),
                (V = 1),
                (ot = $ || st || et || ot),
                ($ = Q.fillColor || F.fillColor || ot),
                (et = Q.lineColor || F.lineColor || ot),
                (I = I || "normal"),
                (F = F.states[I] || {}),
                (I = (Q.states && Q.states[I]) || {}),
                (j = H(
                  I.lineWidth,
                  F.lineWidth,
                  j + H(I.lineWidthPlus, F.lineWidthPlus, 0)
                )),
                ($ = I.fillColor || F.fillColor || $),
                (et = I.lineColor || F.lineColor || et),
                (V = H(I.opacity, F.opacity, V)),
                { stroke: et, "stroke-width": j, fill: $, opacity: V }
              );
            }
            destroy(j) {
              const I = this,
                F = I.chart,
                V = /AppleWebKit\/533/.test(p.navigator.userAgent),
                Q = I.data || [];
              let $, et, st, ot;
              for (
                c(I, "destroy", { keepEventsForUpdate: j }),
                  this.removeEvents(j),
                  (I.axisTypes || []).forEach(function (at) {
                    (ot = I[at]) &&
                      ot.series &&
                      (y(ot.series, I), (ot.isDirty = ot.forceRedraw = !0));
                  }),
                  I.legendItem && I.chart.legend.destroyItem(I),
                  et = Q.length;
                et--;

              )
                (st = Q[et]) && st.destroy && st.destroy();
              I.clips && I.clips.forEach((at) => at.destroy()),
                z.clearTimeout(I.animationTimeout),
                K(I, function (at, lt) {
                  at instanceof E &&
                    !at.survive &&
                    (($ = V && lt === "group" ? "hide" : "destroy"), at[$]());
                }),
                F.hoverSeries === I && (F.hoverSeries = void 0),
                y(F.series, I),
                F.orderItems("series"),
                K(I, function (at, lt) {
                  (j && lt === "hcEvents") || delete I[lt];
                });
            }
            applyZones() {
              const j = this,
                I = this.chart,
                F = I.renderer,
                V = this.zones,
                Q = this.clips || [],
                $ = this.graph,
                et = this.area,
                st = Math.max(I.plotWidth, I.plotHeight),
                ot = this[(this.zoneAxis || "y") + "Axis"],
                at = I.inverted;
              let lt,
                Z,
                q,
                nt,
                it,
                rt,
                ht,
                ct,
                ft,
                yt,
                ut,
                gt = !1;
              V.length && ($ || et) && ot && typeof ot.min < "u"
                ? ((it = ot.reversed),
                  (rt = ot.horiz),
                  $ && !this.showLine && $.hide(),
                  et && et.hide(),
                  (nt = ot.getExtremes()),
                  V.forEach(function (wt, xt) {
                    (lt = it
                      ? rt
                        ? I.plotWidth
                        : 0
                      : rt
                      ? 0
                      : ot.toPixels(nt.min) || 0),
                      (lt = A(H(Z, lt), 0, st)),
                      (Z = A(
                        Math.round(ot.toPixels(H(wt.value, nt.max), !0) || 0),
                        0,
                        st
                      )),
                      gt && (lt = Z = ot.toPixels(nt.max)),
                      (ht = Math.abs(lt - Z)),
                      (ct = Math.min(lt, Z)),
                      (ft = Math.max(lt, Z)),
                      ot.isXAxis
                        ? ((q = {
                            x: at ? ft : ct,
                            y: 0,
                            width: ht,
                            height: st,
                          }),
                          rt || (q.x = I.plotHeight - q.x))
                        : ((q = {
                            x: 0,
                            y: at ? ft : ct,
                            width: st,
                            height: ht,
                          }),
                          rt && (q.y = I.plotWidth - q.y)),
                      Q[xt] ? Q[xt].animate(q) : (Q[xt] = F.clipRect(q)),
                      (yt = j["zone-area-" + xt]),
                      (ut = j["zone-graph-" + xt]),
                      $ && ut && ut.clip(Q[xt]),
                      et && yt && yt.clip(Q[xt]),
                      (gt = wt.value > nt.max),
                      j.resetZones && Z === 0 && (Z = void 0);
                  }),
                  (this.clips = Q))
                : j.visible && ($ && $.show(), et && et.show());
            }
            plotGroup(j, I, F, V, Q) {
              let $ = this[j];
              const et = !$;
              return (
                (F = { visibility: F, zIndex: V || 0.1 }),
                typeof this.opacity > "u" ||
                  this.chart.styledMode ||
                  this.state === "inactive" ||
                  (F.opacity = this.opacity),
                et && (this[j] = $ = this.chart.renderer.g().add(Q)),
                $.addClass(
                  "highcharts-" +
                    I +
                    " highcharts-series-" +
                    this.index +
                    " highcharts-" +
                    this.type +
                    "-series " +
                    (f(this.colorIndex)
                      ? "highcharts-color-" + this.colorIndex + " "
                      : "") +
                    (this.options.className || "") +
                    ($.hasClass("highcharts-tracker")
                      ? " highcharts-tracker"
                      : ""),
                  !0
                ),
                $.attr(F)[et ? "attr" : "animate"](this.getPlotBox(I)),
                $
              );
            }
            getPlotBox(j) {
              let I = this.xAxis,
                F = this.yAxis;
              const V = this.chart;
              return (
                (j =
                  V.inverted &&
                  !V.polar &&
                  I &&
                  this.invertible !== !1 &&
                  j === "series"),
                V.inverted && ((I = F), (F = this.xAxis)),
                {
                  translateX: I ? I.left : V.plotLeft,
                  translateY: F ? F.top : V.plotTop,
                  rotation: j ? 90 : 0,
                  rotationOriginX: j ? (I.len - F.len) / 2 : 0,
                  rotationOriginY: j ? (I.len + F.len) / 2 : 0,
                  scaleX: j ? -1 : 1,
                  scaleY: 1,
                }
              );
            }
            removeEvents(j) {
              j || k(this),
                this.eventsToUnbind.length &&
                  (this.eventsToUnbind.forEach(function (I) {
                    I();
                  }),
                  (this.eventsToUnbind.length = 0));
            }
            render() {
              const j = this;
              var I = j.chart;
              const F = j.options,
                V = S(F.animation),
                Q = j.visible ? "inherit" : "hidden",
                $ = F.zIndex,
                et = j.hasRendered;
              I = I.seriesGroup;
              let st = j.finishedAnimating ? 0 : V.duration;
              c(this, "render"),
                j.plotGroup("group", "series", Q, $, I),
                (j.markerGroup = j.plotGroup(
                  "markerGroup",
                  "markers",
                  Q,
                  $,
                  I
                )),
                F.clip !== !1 && j.setClip(),
                j.animate && st && j.animate(!0),
                j.drawGraph && (j.drawGraph(), j.applyZones()),
                j.visible && j.drawPoints(),
                j.drawDataLabels && j.drawDataLabels(),
                j.redrawPoints && j.redrawPoints(),
                j.drawTracker && F.enableMouseTracking && j.drawTracker(),
                j.animate && st && j.animate(),
                et ||
                  (st && V.defer && (st += V.defer),
                  (j.animationTimeout = _(function () {
                    j.afterAnimate();
                  }, st || 0))),
                (j.isDirty = !1),
                (j.hasRendered = !0),
                c(j, "afterRender");
            }
            redraw() {
              const j = this.isDirty || this.isDirtyData;
              this.translate(), this.render(), j && delete this.kdTree;
            }
            searchPoint(j, I) {
              const F = this.xAxis,
                V = this.yAxis,
                Q = this.chart.inverted;
              return this.searchKDTree(
                {
                  clientX: Q ? F.len - j.chartY + F.pos : j.chartX - F.pos,
                  plotY: Q ? V.len - j.chartX + V.pos : j.chartY - V.pos,
                },
                I,
                j
              );
            }
            buildKDTree(j) {
              function I(Q, $, et) {
                var st = Q && Q.length;
                let ot;
                if (st)
                  return (
                    (ot = F.kdAxisArray[$ % et]),
                    Q.sort(function (at, lt) {
                      return at[ot] - lt[ot];
                    }),
                    (st = Math.floor(st / 2)),
                    {
                      point: Q[st],
                      left: I(Q.slice(0, st), $ + 1, et),
                      right: I(Q.slice(st + 1), $ + 1, et),
                    }
                  );
              }
              this.buildingKdTree = !0;
              const F = this,
                V = -1 < F.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete F.kdTree,
                _(
                  function () {
                    (F.kdTree = I(
                      F.getValidPoints(null, !F.directTouch),
                      V,
                      V
                    )),
                      (F.buildingKdTree = !1);
                  },
                  F.options.kdNow || (j && j.type === "touchstart") ? 0 : 1
                );
            }
            searchKDTree(j, I, F) {
              function V(ot, at, lt, Z) {
                const q = at.point;
                var nt = Q.kdAxisArray[lt % Z];
                let it = q;
                var rt = f(ot[$]) && f(q[$]) ? Math.pow(ot[$] - q[$], 2) : null,
                  ht =
                    f(ot[et]) && f(q[et]) ? Math.pow(ot[et] - q[et], 2) : null;
                return (
                  (ht = (rt || 0) + (ht || 0)),
                  (q.dist = f(ht) ? Math.sqrt(ht) : Number.MAX_VALUE),
                  (q.distX = f(rt) ? Math.sqrt(rt) : Number.MAX_VALUE),
                  (nt = ot[nt] - q[nt]),
                  (ht = 0 > nt ? "left" : "right"),
                  (rt = 0 > nt ? "right" : "left"),
                  at[ht] &&
                    ((ht = V(ot, at[ht], lt + 1, Z)),
                    (it = ht[st] < it[st] ? ht : q)),
                  at[rt] &&
                    Math.sqrt(nt * nt) < it[st] &&
                    ((ot = V(ot, at[rt], lt + 1, Z)),
                    (it = ot[st] < it[st] ? ot : it)),
                  it
                );
              }
              const Q = this,
                $ = this.kdAxisArray[0],
                et = this.kdAxisArray[1],
                st = I ? "distX" : "dist";
              if (
                ((I = -1 < Q.options.findNearestPointBy.indexOf("y") ? 2 : 1),
                this.kdTree || this.buildingKdTree || this.buildKDTree(F),
                this.kdTree)
              )
                return V(j, this.kdTree, I, I);
            }
            pointPlacementToXValue() {
              const {
                options: { pointPlacement: j, pointRange: I },
                xAxis: F,
              } = this;
              let V = j;
              return (
                V === "between" && (V = F.reversed ? -0.5 : 0.5),
                R(V) ? V * (I || F.pointRange) : 0
              );
            }
            isPointInside(j) {
              const { chart: I, xAxis: F, yAxis: V } = this;
              return (
                typeof j.plotY < "u" &&
                typeof j.plotX < "u" &&
                0 <= j.plotY &&
                j.plotY <= (V ? V.len : I.plotHeight) &&
                0 <= j.plotX &&
                j.plotX <= (F ? F.len : I.plotWidth)
              );
            }
            drawTracker() {
              const j = this,
                I = j.options,
                F = I.trackByArea,
                V = [].concat(F ? j.areaPath : j.graphPath),
                Q = j.chart,
                $ = Q.pointer,
                et = Q.renderer,
                st = Q.options.tooltip.snap,
                ot = j.tracker,
                at = function (Z) {
                  I.enableMouseTracking &&
                    Q.hoverSeries !== j &&
                    j.onMouseOver();
                },
                lt = "rgba(192,192,192," + (l ? 1e-4 : 0.002) + ")";
              ot
                ? ot.attr({ d: V })
                : j.graph &&
                  ((j.tracker = et
                    .path(V)
                    .attr({
                      visibility: j.visible ? "inherit" : "hidden",
                      zIndex: 2,
                    })
                    .addClass(
                      F ? "highcharts-tracker-area" : "highcharts-tracker-line"
                    )
                    .add(j.group)),
                  Q.styledMode ||
                    j.tracker.attr({
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      stroke: lt,
                      fill: F ? lt : "none",
                      "stroke-width": j.graph.strokeWidth() + (F ? 0 : 2 * st),
                    }),
                  [j.tracker, j.markerGroup, j.dataLabelsGroup].forEach(
                    function (Z) {
                      Z &&
                        (Z.addClass("highcharts-tracker")
                          .on("mouseover", at)
                          .on("mouseout", function (q) {
                            $.onTrackerMouseOut(q);
                          }),
                        I.cursor &&
                          !Q.styledMode &&
                          Z.css({ cursor: I.cursor }),
                        s) &&
                        Z.on("touchstart", at);
                    }
                  )),
                c(this, "afterDrawTracker");
            }
            addPoint(j, I, F, V, Q) {
              const $ = this.options,
                et = this.data,
                st = this.chart;
              var ot = this.xAxis;
              ot = ot && ot.hasNames && ot.names;
              const at = $.data,
                lt = this.xData;
              let Z, q;
              I = H(I, !0);
              const nt = { series: this };
              this.pointClass.prototype.applyOptions.apply(nt, [j]);
              const it = nt.x;
              if (((q = lt.length), this.requireSorting && it < lt[q - 1]))
                for (Z = !0; q && lt[q - 1] > it; ) q--;
              this.updateParallelArrays(nt, "splice", [q, 0, 0]),
                this.updateParallelArrays(nt, q),
                ot && nt.name && (ot[it] = nt.name),
                at.splice(q, 0, j),
                (Z || this.processedData) &&
                  (this.data.splice(q, 0, null), this.processData()),
                $.legendType === "point" && this.generatePoints(),
                F &&
                  (et[0] && et[0].remove
                    ? et[0].remove(!1)
                    : (et.shift(),
                      this.updateParallelArrays(nt, "shift"),
                      at.shift())),
                Q !== !1 && c(this, "addPoint", { point: nt }),
                (this.isDirtyData = this.isDirty = !0),
                I && st.redraw(V);
            }
            removePoint(j, I, F) {
              const V = this,
                Q = V.data,
                $ = Q[j],
                et = V.points,
                st = V.chart,
                ot = function () {
                  et && et.length === Q.length && et.splice(j, 1),
                    Q.splice(j, 1),
                    V.options.data.splice(j, 1),
                    V.updateParallelArrays($ || { series: V }, "splice", [
                      j,
                      1,
                    ]),
                    $ && $.destroy(),
                    (V.isDirty = !0),
                    (V.isDirtyData = !0),
                    I && st.redraw();
                };
              x(F, st),
                (I = H(I, !0)),
                $ ? $.firePointEvent("remove", null, ot) : ot();
            }
            remove(j, I, F, V) {
              function Q() {
                $.destroy(V),
                  (et.isDirtyLegend = et.isDirtyBox = !0),
                  et.linkSeries(V),
                  H(j, !0) && et.redraw(I);
              }
              const $ = this,
                et = $.chart;
              F !== !1 ? c($, "remove", null, Q) : Q();
            }
            update(j, I) {
              (j = b(j, this.userOptions)), c(this, "update", { options: j });
              const F = this,
                V = F.chart;
              var Q = F.userOptions;
              const $ = F.initialType || F.type;
              var et = V.options.plotOptions;
              const st = g[$].prototype;
              var ot = F.finishedAnimating && { animation: !1 };
              const at = {};
              let lt,
                Z = [
                  "colorIndex",
                  "eventOptions",
                  "navigatorSeries",
                  "symbolIndex",
                  "baseSeries",
                ],
                q = j.type || Q.type || V.options.chart.type;
              const nt = !(
                this.hasDerivedData ||
                (q && q !== this.type) ||
                typeof j.pointStart < "u" ||
                typeof j.pointInterval < "u" ||
                typeof j.relativeXValue < "u" ||
                j.joinBy ||
                j.mapData ||
                F.hasOptionChanged("dataGrouping") ||
                F.hasOptionChanged("pointStart") ||
                F.hasOptionChanged("pointInterval") ||
                F.hasOptionChanged("pointIntervalUnit") ||
                F.hasOptionChanged("keys")
              );
              if (
                ((q = q || $),
                nt &&
                  (Z.push(
                    "data",
                    "isDirtyData",
                    "points",
                    "processedData",
                    "processedXData",
                    "processedYData",
                    "xIncrement",
                    "cropped",
                    "_hasPointMarkers",
                    "_hasPointLabels",
                    "clips",
                    "nodes",
                    "layout",
                    "level",
                    "mapMap",
                    "mapData",
                    "minY",
                    "maxY",
                    "minX",
                    "maxX"
                  ),
                  j.visible !== !1 && Z.push("area", "graph"),
                  F.parallelArrays.forEach(function (it) {
                    Z.push(it + "Data");
                  }),
                  j.data &&
                    (j.dataSorting && o(F.options.dataSorting, j.dataSorting),
                    this.setData(j.data, !1))),
                (j = J(
                  Q,
                  ot,
                  {
                    index: typeof Q.index > "u" ? F.index : Q.index,
                    pointStart: H(
                      et && et.series && et.series.pointStart,
                      Q.pointStart,
                      F.xData[0]
                    ),
                  },
                  !nt && { data: F.options.data },
                  j
                )),
                nt && j.data && (j.data = F.options.data),
                (Z = [
                  "group",
                  "markerGroup",
                  "dataLabelsGroup",
                  "transformGroup",
                ].concat(Z)),
                Z.forEach(function (it) {
                  (Z[it] = F[it]), delete F[it];
                }),
                (et = !1),
                g[q])
              ) {
                if (((et = q !== F.type), F.remove(!1, !1, !1, !0), et))
                  if (Object.setPrototypeOf)
                    Object.setPrototypeOf(F, g[q].prototype);
                  else {
                    ot =
                      Object.hasOwnProperty.call(F, "hcEvents") && F.hcEvents;
                    for (lt in st) F[lt] = void 0;
                    o(F, g[q].prototype),
                      ot ? (F.hcEvents = ot) : delete F.hcEvents;
                  }
              } else C(17, !0, V, { missingModuleFor: q });
              if (
                (Z.forEach(function (it) {
                  F[it] = Z[it];
                }),
                F.init(V, j),
                nt && this.points)
              ) {
                if (((j = F.options), j.visible === !1))
                  (at.graphic = 1), (at.dataLabel = 1);
                else if (!F._hasPointLabels) {
                  const { marker: it, dataLabels: rt } = j;
                  (Q = Q.marker || {}),
                    !it ||
                      (it.enabled !== !1 &&
                        Q.symbol === it.symbol &&
                        Q.height === it.height &&
                        Q.width === it.width) ||
                      (at.graphic = 1),
                    rt && rt.enabled === !1 && (at.dataLabel = 1);
                }
                for (const it of this.points)
                  it &&
                    it.series &&
                    (it.resolveColor(),
                    Object.keys(at).length && it.destroyElements(at),
                    j.showInLegend === !1 &&
                      it.legendItem &&
                      V.legend.destroyItem(it));
              }
              (F.initialType = $),
                V.linkSeries(),
                et && F.linkedSeries.length && (F.isDirtyData = !0),
                c(this, "afterUpdate"),
                H(I, !0) && V.redraw(nt ? void 0 : !1);
            }
            setName(j) {
              (this.name = this.options.name = this.userOptions.name = j),
                (this.chart.isDirtyLegend = !0);
            }
            hasOptionChanged(j) {
              const I = this.options[j],
                F = this.chart.options.plotOptions,
                V = this.userOptions[j];
              return V
                ? I !== V
                : I !==
                    H(
                      F && F[this.type] && F[this.type][j],
                      F && F.series && F.series[j],
                      I
                    );
            }
            onMouseOver() {
              const j = this.chart,
                I = j.hoverSeries;
              j.pointer.setHoverChartIndex(),
                I && I !== this && I.onMouseOut(),
                this.options.events.mouseOver && c(this, "mouseOver"),
                this.setState("hover"),
                (j.hoverSeries = this);
            }
            onMouseOut() {
              const j = this.options,
                I = this.chart,
                F = I.tooltip,
                V = I.hoverPoint;
              (I.hoverSeries = null),
                V && V.onMouseOut(),
                this && j.events.mouseOut && c(this, "mouseOut"),
                !F ||
                  this.stickyTracking ||
                  (F.shared && !this.noSharedTooltip) ||
                  F.hide(),
                I.series.forEach(function (Q) {
                  Q.setState("", !0);
                });
            }
            setState(j, I) {
              const F = this;
              var V = F.options;
              const Q = F.graph,
                $ = V.inactiveOtherPoints,
                et = V.states,
                st = H(
                  et[j || "normal"] && et[j || "normal"].animation,
                  F.chart.options.chart.animation
                );
              let ot = V.lineWidth,
                at = 0,
                lt = V.opacity;
              if (
                ((j = j || ""),
                F.state !== j &&
                  ([F.group, F.markerGroup, F.dataLabelsGroup].forEach(
                    function (Z) {
                      Z &&
                        (F.state &&
                          Z.removeClass("highcharts-series-" + F.state),
                        j && Z.addClass("highcharts-series-" + j));
                    }
                  ),
                  (F.state = j),
                  !F.chart.styledMode))
              ) {
                if (et[j] && et[j].enabled === !1) return;
                if (
                  (j &&
                    ((ot = et[j].lineWidth || ot + (et[j].lineWidthPlus || 0)),
                    (lt = H(et[j].opacity, lt))),
                  Q && !Q.dashstyle && R(ot))
                )
                  for (
                    V = { "stroke-width": ot }, Q.animate(V, st);
                    F["zone-graph-" + at];

                  )
                    F["zone-graph-" + at].animate(V, st), (at += 1);
                $ ||
                  [
                    F.group,
                    F.markerGroup,
                    F.dataLabelsGroup,
                    F.labelBySeries,
                  ].forEach(function (Z) {
                    Z && Z.animate({ opacity: lt }, st);
                  });
              }
              I && $ && F.points && F.setAllPointsToState(j || void 0);
            }
            setAllPointsToState(j) {
              this.points.forEach(function (I) {
                I.setState && I.setState(j);
              });
            }
            setVisible(j, I) {
              const F = this,
                V = F.chart,
                Q = V.options.chart.ignoreHiddenSeries,
                $ = F.visible,
                et = (F.visible =
                  j =
                  F.options.visible =
                  F.userOptions.visible =
                    typeof j > "u" ? !$ : j)
                  ? "show"
                  : "hide";
              [
                "group",
                "dataLabelsGroup",
                "markerGroup",
                "tracker",
                "tt",
              ].forEach(function (st) {
                F[st] && F[st][et]();
              }),
                (V.hoverSeries === F ||
                  (V.hoverPoint && V.hoverPoint.series) === F) &&
                  F.onMouseOut(),
                F.legendItem && V.legend.colorizeItem(F, j),
                (F.isDirty = !0),
                F.options.stacking &&
                  V.series.forEach(function (st) {
                    st.options.stacking && st.visible && (st.isDirty = !0);
                  }),
                F.linkedSeries.forEach(function (st) {
                  st.setVisible(j, !1);
                }),
                Q && (V.isDirtyBox = !0),
                c(F, et),
                I !== !1 && V.redraw();
            }
            show() {
              this.setVisible(!0);
            }
            hide() {
              this.setVisible(!1);
            }
            select(j) {
              (this.selected =
                j =
                this.options.selected =
                  typeof j > "u" ? !this.selected : j),
                this.checkbox && (this.checkbox.checked = j),
                c(this, j ? "select" : "unselect");
            }
            shouldShowTooltip(j, I, F = {}) {
              return (
                (F.series = this),
                (F.visiblePlotOnly = !0),
                this.chart.isInsidePlot(j, I, F)
              );
            }
            drawLegendSymbol(j, I) {
              var F;
              (F = B[this.options.legendSymbol || "rectangle"]) === null ||
                F === void 0 ||
                F.call(this, j, I);
            }
          }
          return (
            (W.defaultOptions = Y),
            (W.types = L.seriesTypes),
            (W.registerType = L.registerSeriesType),
            o(W.prototype, {
              axisTypes: ["xAxis", "yAxis"],
              coll: "series",
              colorCounter: 0,
              cropShoulder: 1,
              directTouch: !1,
              isCartesian: !0,
              kdAxisArray: ["clientX", "plotY"],
              parallelArrays: ["x", "y"],
              pointClass: G,
              requireSorting: !0,
              sorted: !0,
            }),
            (L.series = W),
            W
          );
        }
      ),
      n(
        i,
        "Core/Chart/Chart.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Axis/Axis.js"],
          i["Core/Defaults.js"],
          i["Core/Templating.js"],
          i["Core/Foundation.js"],
          i["Core/Globals.js"],
          i["Core/Renderer/RendererRegistry.js"],
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Renderer/SVG/SVGRenderer.js"],
          i["Core/Time.js"],
          i["Core/Utilities.js"],
          i["Core/Renderer/HTML/AST.js"],
        ],
        function (a, d, M, O, B, G, Y, L, E, z, S, x, P) {
          const { animate: h, animObject: s, setAnimation: l } = a,
            { defaultOptions: p, defaultTime: g } = M,
            { numberFormat: T } = O,
            { registerEventOptions: D } = B,
            { charts: A, doc: m, marginNames: f, svg: b, win: y } = G,
            { seriesTypes: C } = E,
            {
              addEvent: o,
              attr: r,
              createElement: c,
              css: u,
              defined: v,
              diffObjects: N,
              discardElement: w,
              erase: R,
              error: X,
              extend: J,
              find: K,
              fireEvent: H,
              getStyle: k,
              isArray: U,
              isNumber: _,
              isObject: W,
              isString: tt,
              merge: j,
              objectEach: I,
              pick: F,
              pInt: V,
              relativeLength: Q,
              removeEvent: $,
              splat: et,
              syncTimeout: st,
              uniqueKey: ot,
            } = x;
          class at {
            static chart(Z, q, nt) {
              return new at(Z, q, nt);
            }
            constructor(Z, q, nt) {
              (this.series =
                this.renderTo =
                this.renderer =
                this.pointer =
                this.pointCount =
                this.plotWidth =
                this.plotTop =
                this.plotLeft =
                this.plotHeight =
                this.plotBox =
                this.options =
                this.numberFormatter =
                this.margin =
                this.labelCollectors =
                this.isResizing =
                this.index =
                this.eventOptions =
                this.container =
                this.colorCounter =
                this.clipBox =
                this.chartWidth =
                this.chartHeight =
                this.bounds =
                this.axisOffset =
                this.axes =
                  void 0),
                (this.sharedClips = {}),
                (this.zooming =
                  this.yAxis =
                  this.xAxis =
                  this.userOptions =
                  this.titleOffset =
                  this.time =
                  this.symbolCounter =
                  this.spacingBox =
                  this.spacing =
                    void 0),
                this.getArgs(Z, q, nt);
            }
            getArgs(Z, q, nt) {
              tt(Z) || Z.nodeName
                ? ((this.renderTo = Z), this.init(q, nt))
                : this.init(Z, q);
            }
            setZoomOptions() {
              const Z = this.options.chart,
                q = Z.zooming;
              this.zooming = Object.assign(Object.assign({}, q), {
                type: F(Z.zoomType, q.type),
                key: F(Z.zoomKey, q.key),
                pinchType: F(Z.pinchType, q.pinchType),
                singleTouch: F(Z.zoomBySingleTouch, q.singleTouch, !1),
                resetButton: j(q.resetButton, Z.resetZoomButton),
              });
            }
            init(Z, q) {
              H(this, "init", { args: arguments }, function () {
                const nt = j(p, Z),
                  it = nt.chart;
                (this.userOptions = J({}, Z)),
                  (this.margin = []),
                  (this.spacing = []),
                  (this.bounds = { h: {}, v: {} }),
                  (this.labelCollectors = []),
                  (this.callback = q),
                  (this.isResizing = 0),
                  (this.options = nt),
                  (this.axes = []),
                  (this.series = []),
                  (this.time =
                    Z.time && Object.keys(Z.time).length
                      ? new S(Z.time)
                      : G.time),
                  (this.numberFormatter = it.numberFormatter || T),
                  (this.styledMode = it.styledMode),
                  (this.hasCartesianSeries = it.showAxes),
                  (this.index = A.length),
                  A.push(this),
                  G.chartCount++,
                  D(this, it),
                  (this.xAxis = []),
                  (this.yAxis = []),
                  (this.pointCount =
                    this.colorCounter =
                    this.symbolCounter =
                      0),
                  this.setZoomOptions(),
                  H(this, "afterInit"),
                  this.firstRender();
              });
            }
            initSeries(Z) {
              var q = this.options.chart;
              q = Z.type || q.type;
              const nt = C[q];
              return (
                nt || X(17, !0, this, { missingModuleFor: q }),
                (q = new nt()),
                typeof q.init == "function" && q.init(this, Z),
                q
              );
            }
            setSeriesData() {
              this.getSeriesOrderByLinks().forEach(function (Z) {
                Z.points ||
                  Z.data ||
                  !Z.enabledDataSorting ||
                  Z.setData(Z.options.data, !1);
              });
            }
            getSeriesOrderByLinks() {
              return this.series.concat().sort(function (Z, q) {
                return Z.linkedSeries.length || q.linkedSeries.length
                  ? q.linkedSeries.length - Z.linkedSeries.length
                  : 0;
              });
            }
            orderItems(Z, q = 0) {
              const nt = this[Z],
                it = (this.options[Z] = et(this.options[Z]).slice());
              if (
                ((Z = this.userOptions[Z] =
                  this.userOptions[Z] ? et(this.userOptions[Z]).slice() : []),
                this.hasRendered && (it.splice(q), Z.splice(q)),
                nt)
              )
                for (let rt = q, ht = nt.length; rt < ht; ++rt)
                  (q = nt[rt]) &&
                    ((q.index = rt),
                    q instanceof L && (q.name = q.getName()),
                    q.options.isInternal ||
                      ((it[rt] = q.options), (Z[rt] = q.userOptions)));
            }
            isInsidePlot(Z, q, nt = {}) {
              const {
                inverted: it,
                plotBox: rt,
                plotLeft: ht,
                plotTop: ct,
                scrollablePlotBox: ft,
              } = this;
              var yt = 0;
              let ut = 0;
              nt.visiblePlotOnly &&
                this.scrollingContainer &&
                ({ scrollLeft: yt, scrollTop: ut } = this.scrollingContainer);
              const gt = nt.series,
                wt = (nt.visiblePlotOnly && ft) || rt;
              var xt = nt.inverted ? q : Z;
              if (
                ((q = nt.inverted ? Z : q),
                (Z = { x: xt, y: q, isInsidePlot: !0, options: nt }),
                !nt.ignoreX)
              ) {
                const St = (gt &&
                  (it && !this.polar ? gt.yAxis : gt.xAxis)) || {
                  pos: ht,
                  len: 1 / 0,
                };
                (xt = nt.paneCoordinates ? St.pos + xt : ht + xt),
                  (xt >= Math.max(yt + ht, St.pos) &&
                    xt <= Math.min(yt + ht + wt.width, St.pos + St.len)) ||
                    (Z.isInsidePlot = !1);
              }
              return (
                !nt.ignoreY &&
                  Z.isInsidePlot &&
                  ((yt = (!it && nt.axis && !nt.axis.isXAxis && nt.axis) ||
                    (gt && (it ? gt.xAxis : gt.yAxis)) || {
                      pos: ct,
                      len: 1 / 0,
                    }),
                  (nt = nt.paneCoordinates ? yt.pos + q : ct + q),
                  (nt >= Math.max(ut + ct, yt.pos) &&
                    nt <= Math.min(ut + ct + wt.height, yt.pos + yt.len)) ||
                    (Z.isInsidePlot = !1)),
                H(this, "afterIsInsidePlot", Z),
                Z.isInsidePlot
              );
            }
            redraw(Z) {
              H(this, "beforeRedraw");
              const q = this.hasCartesianSeries
                  ? this.axes
                  : this.colorAxis || [],
                nt = this.series,
                it = this.pointer,
                rt = this.legend,
                ht = this.userOptions.legend,
                ct = this.renderer,
                ft = ct.isHidden(),
                yt = [];
              let ut,
                gt,
                wt = this.isDirtyBox,
                xt = this.isDirtyLegend,
                St;
              for (
                ct.rootFontSize = ct.boxWrapper.getStyle("font-size"),
                  this.setResponsive && this.setResponsive(!1),
                  l(this.hasRendered ? Z : !1, this),
                  ft && this.temporaryDisplay(),
                  this.layOutTitles(!1),
                  Z = nt.length;
                Z--;

              )
                if (
                  ((St = nt[Z]),
                  (St.options.stacking || St.options.centerInCategory) &&
                    ((gt = !0), St.isDirty))
                ) {
                  ut = !0;
                  break;
                }
              if (ut)
                for (Z = nt.length; Z--; )
                  (St = nt[Z]), St.options.stacking && (St.isDirty = !0);
              nt.forEach(function (kt) {
                kt.isDirty &&
                  (kt.options.legendType === "point"
                    ? (typeof kt.updateTotals == "function" &&
                        kt.updateTotals(),
                      (xt = !0))
                    : ht && (ht.labelFormatter || ht.labelFormat) && (xt = !0)),
                  kt.isDirtyData && H(kt, "updatedData");
              }),
                xt &&
                  rt &&
                  rt.options.enabled &&
                  (rt.render(), (this.isDirtyLegend = !1)),
                gt && this.getStacks(),
                q.forEach(function (kt) {
                  kt.updateNames(), kt.setScale();
                }),
                this.getMargins(),
                q.forEach(function (kt) {
                  kt.isDirty && (wt = !0);
                }),
                q.forEach(function (kt) {
                  const Nt = kt.min + "," + kt.max;
                  kt.extKey !== Nt &&
                    ((kt.extKey = Nt),
                    yt.push(function () {
                      H(
                        kt,
                        "afterSetExtremes",
                        J(kt.eventArgs, kt.getExtremes())
                      ),
                        delete kt.eventArgs;
                    })),
                    (wt || gt) && kt.redraw();
                }),
                wt && this.drawChartBox(),
                H(this, "predraw"),
                nt.forEach(function (kt) {
                  (wt || kt.isDirty) && kt.visible && kt.redraw(),
                    (kt.isDirtyData = !1);
                }),
                it && it.reset(!0),
                ct.draw(),
                H(this, "redraw"),
                H(this, "render"),
                ft && this.temporaryDisplay(!0),
                yt.forEach(function (kt) {
                  kt.call();
                });
            }
            get(Z) {
              function q(rt) {
                return rt.id === Z || (rt.options && rt.options.id === Z);
              }
              const nt = this.series;
              let it = K(this.axes, q) || K(this.series, q);
              for (let rt = 0; !it && rt < nt.length; rt++)
                it = K(nt[rt].points || [], q);
              return it;
            }
            getAxes() {
              const Z = this.options;
              H(this, "getAxes");
              for (const q of ["xAxis", "yAxis"]) {
                const nt = (Z[q] = et(Z[q] || {}));
                for (const it of nt) new d(this, it, q);
              }
              H(this, "afterGetAxes");
            }
            getSelectedPoints() {
              return this.series.reduce(
                (Z, q) => (
                  q.getPointsCollection().forEach((nt) => {
                    F(nt.selectedStaging, nt.selected) && Z.push(nt);
                  }),
                  Z
                ),
                []
              );
            }
            getSelectedSeries() {
              return this.series.filter(function (Z) {
                return Z.selected;
              });
            }
            setTitle(Z, q, nt) {
              this.applyDescription("title", Z),
                this.applyDescription("subtitle", q),
                this.applyDescription("caption", void 0),
                this.layOutTitles(nt);
            }
            applyDescription(Z, q) {
              const nt = this,
                it = (this.options[Z] = j(this.options[Z], q));
              let rt = this[Z];
              rt && q && (this[Z] = rt = rt.destroy()),
                it &&
                  !rt &&
                  ((rt = this.renderer
                    .text(it.text, 0, 0, it.useHTML)
                    .attr({
                      align: it.align,
                      class: "highcharts-" + Z,
                      zIndex: it.zIndex || 4,
                    })
                    .add()),
                  (rt.update = function (ht, ct) {
                    nt.applyDescription(Z, ht), nt.layOutTitles(ct);
                  }),
                  this.styledMode ||
                    rt.css(
                      J(
                        Z === "title"
                          ? { fontSize: this.options.isStock ? "1em" : "1.2em" }
                          : {},
                        it.style
                      )
                    ),
                  (this[Z] = rt));
            }
            layOutTitles(Z = !0) {
              const q = [0, 0, 0],
                nt = this.renderer,
                it = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (ht) {
                const ct = this[ht],
                  ft = this.options[ht],
                  yt = ft.verticalAlign || "top";
                if (
                  ((ht =
                    ht === "title"
                      ? yt === "top"
                        ? -3
                        : 0
                      : yt === "top"
                      ? q[0] + 2
                      : 0),
                  ct)
                ) {
                  ct.css({
                    width:
                      (ft.width || it.width + (ft.widthAdjust || 0)) + "px",
                  });
                  const ut = nt.fontMetrics(ct).b,
                    gt = Math.round(ct.getBBox(ft.useHTML).height);
                  ct.align(
                    J({ y: yt === "bottom" ? ut : ht + ut, height: gt }, ft),
                    !1,
                    "spacingBox"
                  ),
                    ft.floating ||
                      (yt === "top"
                        ? (q[0] = Math.ceil(q[0] + gt))
                        : yt === "bottom" && (q[2] = Math.ceil(q[2] + gt)));
                }
              }, this),
                q[0] &&
                  (this.options.title.verticalAlign || "top") === "top" &&
                  (q[0] += this.options.title.margin),
                q[2] &&
                  this.options.caption.verticalAlign === "bottom" &&
                  (q[2] += this.options.caption.margin);
              const rt =
                !this.titleOffset || this.titleOffset.join(",") !== q.join(",");
              (this.titleOffset = q),
                H(this, "afterLayOutTitles"),
                !this.isDirtyBox &&
                  rt &&
                  ((this.isDirtyBox = this.isDirtyLegend = rt),
                  this.hasRendered && Z && this.isDirtyBox && this.redraw());
            }
            getContainerBox() {
              return {
                width: k(this.renderTo, "width", !0) || 0,
                height: k(this.renderTo, "height", !0) || 0,
              };
            }
            getChartSize() {
              var Z = this.options.chart;
              const q = Z.width;
              Z = Z.height;
              const nt = this.getContainerBox();
              (this.chartWidth = Math.max(0, q || nt.width || 600)),
                (this.chartHeight = Math.max(
                  0,
                  Q(Z, this.chartWidth) || (1 < nt.height ? nt.height : 400)
                )),
                (this.containerBox = nt);
            }
            temporaryDisplay(Z) {
              let q = this.renderTo;
              if (Z)
                for (; q && q.style; )
                  q.hcOrigStyle && (u(q, q.hcOrigStyle), delete q.hcOrigStyle),
                    q.hcOrigDetached &&
                      (m.body.removeChild(q), (q.hcOrigDetached = !1)),
                    (q = q.parentNode);
              else
                for (
                  ;
                  q &&
                  q.style &&
                  (m.body.contains(q) ||
                    q.parentNode ||
                    ((q.hcOrigDetached = !0), m.body.appendChild(q)),
                  (k(q, "display", !1) === "none" || q.hcOricDetached) &&
                    ((q.hcOrigStyle = {
                      display: q.style.display,
                      height: q.style.height,
                      overflow: q.style.overflow,
                    }),
                    (Z = { display: "block", overflow: "hidden" }),
                    q !== this.renderTo && (Z.height = 0),
                    u(q, Z),
                    q.offsetWidth ||
                      q.style.setProperty("display", "block", "important")),
                  (q = q.parentNode),
                  q !== m.body);

                );
            }
            setClassName(Z) {
              this.container.className = "highcharts-container " + (Z || "");
            }
            getContainer() {
              const Z = this.options,
                q = Z.chart;
              var nt = ot();
              let it,
                rt = this.renderTo;
              rt || (this.renderTo = rt = q.renderTo),
                tt(rt) && (this.renderTo = rt = m.getElementById(rt)),
                rt || X(13, !0, this);
              var ht = V(r(rt, "data-highcharts-chart"));
              _(ht) && A[ht] && A[ht].hasRendered && A[ht].destroy(),
                r(rt, "data-highcharts-chart", this.index),
                (rt.innerHTML = P.emptyHTML),
                q.skipClone || rt.offsetWidth || this.temporaryDisplay(),
                this.getChartSize(),
                (ht = this.chartWidth);
              const ct = this.chartHeight;
              if (
                (u(rt, { overflow: "hidden" }),
                this.styledMode ||
                  (it = J(
                    {
                      position: "relative",
                      overflow: "hidden",
                      width: ht + "px",
                      height: ct + "px",
                      textAlign: "left",
                      lineHeight: "normal",
                      zIndex: 0,
                      "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                      userSelect: "none",
                      "touch-action": "manipulation",
                      outline: "none",
                    },
                    q.style || {}
                  )),
                (this.container = nt = c("div", { id: nt }, it, rt)),
                (this._cursor = nt.style.cursor),
                (this.renderer = new (
                  q.renderer || !b ? Y.getRendererType(q.renderer) : z
                )(
                  nt,
                  ht,
                  ct,
                  void 0,
                  q.forExport,
                  Z.exporting && Z.exporting.allowHTML,
                  this.styledMode
                )),
                (this.containerBox = this.getContainerBox()),
                l(void 0, this),
                this.setClassName(q.className),
                this.styledMode)
              )
                for (const ft in Z.defs) this.renderer.definition(Z.defs[ft]);
              else this.renderer.setStyle(q.style);
              (this.renderer.chartIndex = this.index),
                H(this, "afterGetContainer");
            }
            getMargins(Z) {
              const { spacing: q, margin: nt, titleOffset: it } = this;
              this.resetMargins(),
                it[0] &&
                  !v(nt[0]) &&
                  (this.plotTop = Math.max(this.plotTop, it[0] + q[0])),
                it[2] &&
                  !v(nt[2]) &&
                  (this.marginBottom = Math.max(
                    this.marginBottom,
                    it[2] + q[2]
                  )),
                this.legend &&
                  this.legend.display &&
                  this.legend.adjustMargins(nt, q),
                H(this, "getMargins"),
                Z || this.getAxisMargins();
            }
            getAxisMargins() {
              const Z = this,
                q = (Z.axisOffset = [0, 0, 0, 0]),
                nt = Z.colorAxis,
                it = Z.margin,
                rt = function (ht) {
                  ht.forEach(function (ct) {
                    ct.visible && ct.getOffset();
                  });
                };
              Z.hasCartesianSeries ? rt(Z.axes) : nt && nt.length && rt(nt),
                f.forEach(function (ht, ct) {
                  v(it[ct]) || (Z[ht] += q[ct]);
                }),
                Z.setChartSize();
            }
            getOptions() {
              return N(this.userOptions, p);
            }
            reflow(Z) {
              const q = this;
              var nt = q.options.chart;
              nt = v(nt.width) && v(nt.height);
              const it = q.containerBox,
                rt = q.getContainerBox();
              delete q.pointer.chartPosition,
                !nt &&
                  !q.isPrinting &&
                  it &&
                  rt.width &&
                  ((rt.width !== it.width || rt.height !== it.height) &&
                    (x.clearTimeout(q.reflowTimeout),
                    (q.reflowTimeout = st(
                      function () {
                        q.container && q.setSize(void 0, void 0, !1);
                      },
                      Z ? 100 : 0
                    ))),
                  (q.containerBox = rt));
            }
            setReflow() {
              const Z = this;
              var q = (nt) => {
                var it;
                !((it = Z.options) === null || it === void 0) &&
                  it.chart.reflow &&
                  Z.hasLoaded &&
                  Z.reflow(nt);
              };
              typeof ResizeObserver == "function"
                ? new ResizeObserver(q).observe(Z.renderTo)
                : ((q = o(y, "resize", q)), o(this, "destroy", q));
            }
            setSize(Z, q, nt) {
              const it = this,
                rt = it.renderer;
              (it.isResizing += 1),
                l(nt, it),
                (nt = rt.globalAnimation),
                (it.oldChartHeight = it.chartHeight),
                (it.oldChartWidth = it.chartWidth),
                typeof Z < "u" && (it.options.chart.width = Z),
                typeof q < "u" && (it.options.chart.height = q),
                it.getChartSize(),
                it.styledMode ||
                  (nt ? h : u)(
                    it.container,
                    {
                      width: it.chartWidth + "px",
                      height: it.chartHeight + "px",
                    },
                    nt
                  ),
                it.setChartSize(!0),
                rt.setSize(it.chartWidth, it.chartHeight, nt),
                it.axes.forEach(function (ht) {
                  (ht.isDirty = !0), ht.setScale();
                }),
                (it.isDirtyLegend = !0),
                (it.isDirtyBox = !0),
                it.layOutTitles(),
                it.getMargins(),
                it.redraw(nt),
                (it.oldChartHeight = null),
                H(it, "resize"),
                st(function () {
                  it &&
                    H(it, "endResize", null, function () {
                      --it.isResizing;
                    });
                }, s(nt).duration);
            }
            setChartSize(Z) {
              var q = this.inverted;
              const nt = this.renderer;
              var it = this.chartWidth,
                rt = this.chartHeight;
              const ht = this.options.chart,
                ct = this.spacing,
                ft = this.clipOffset;
              let yt, ut, gt, wt;
              (this.plotLeft = yt = Math.round(this.plotLeft)),
                (this.plotTop = ut = Math.round(this.plotTop)),
                (this.plotWidth = gt =
                  Math.max(0, Math.round(it - yt - this.marginRight))),
                (this.plotHeight = wt =
                  Math.max(0, Math.round(rt - ut - this.marginBottom))),
                (this.plotSizeX = q ? wt : gt),
                (this.plotSizeY = q ? gt : wt),
                (this.plotBorderWidth = ht.plotBorderWidth || 0),
                (this.spacingBox = nt.spacingBox =
                  {
                    x: ct[3],
                    y: ct[0],
                    width: it - ct[3] - ct[1],
                    height: rt - ct[0] - ct[2],
                  }),
                (this.plotBox = nt.plotBox =
                  { x: yt, y: ut, width: gt, height: wt }),
                (q = 2 * Math.floor(this.plotBorderWidth / 2)),
                (it = Math.ceil(Math.max(q, ft[3]) / 2)),
                (rt = Math.ceil(Math.max(q, ft[0]) / 2)),
                (this.clipBox = {
                  x: it,
                  y: rt,
                  width: Math.floor(
                    this.plotSizeX - Math.max(q, ft[1]) / 2 - it
                  ),
                  height: Math.max(
                    0,
                    Math.floor(this.plotSizeY - Math.max(q, ft[2]) / 2 - rt)
                  ),
                }),
                Z ||
                  (this.axes.forEach(function (xt) {
                    xt.setAxisSize(), xt.setAxisTranslation();
                  }),
                  nt.alignElements()),
                H(this, "afterSetChartSize", { skipAxes: Z });
            }
            resetMargins() {
              H(this, "resetMargins");
              const Z = this,
                q = Z.options.chart;
              ["margin", "spacing"].forEach(function (nt) {
                const it = q[nt],
                  rt = W(it) ? it : [it, it, it, it];
                ["Top", "Right", "Bottom", "Left"].forEach(function (ht, ct) {
                  Z[nt][ct] = F(q[nt + ht], rt[ct]);
                });
              }),
                f.forEach(function (nt, it) {
                  Z[nt] = F(Z.margin[it], Z.spacing[it]);
                }),
                (Z.axisOffset = [0, 0, 0, 0]),
                (Z.clipOffset = [0, 0, 0, 0]);
            }
            drawChartBox() {
              const Z = this.options.chart,
                q = this.renderer,
                nt = this.chartWidth,
                it = this.chartHeight,
                rt = this.styledMode,
                ht = this.plotBGImage;
              var ct = Z.backgroundColor;
              const ft = Z.plotBackgroundColor,
                yt = Z.plotBackgroundImage,
                ut = this.plotLeft,
                gt = this.plotTop,
                wt = this.plotWidth,
                xt = this.plotHeight,
                St = this.plotBox,
                kt = this.clipRect,
                Nt = this.clipBox;
              let Mt = this.chartBackground,
                qt = this.plotBackground,
                ge = this.plotBorder,
                Dt,
                ke,
                Jt = "animate";
              Mt ||
                ((this.chartBackground = Mt =
                  q.rect().addClass("highcharts-background").add()),
                (Jt = "attr")),
                rt
                  ? (Dt = ke = Mt.strokeWidth())
                  : ((Dt = Z.borderWidth || 0),
                    (ke = Dt + (Z.shadow ? 8 : 0)),
                    (ct = { fill: ct || "none" }),
                    (Dt || Mt["stroke-width"]) &&
                      ((ct.stroke = Z.borderColor), (ct["stroke-width"] = Dt)),
                    Mt.attr(ct).shadow(Z.shadow)),
                Mt[Jt]({
                  x: ke / 2,
                  y: ke / 2,
                  width: nt - ke - (Dt % 2),
                  height: it - ke - (Dt % 2),
                  r: Z.borderRadius,
                }),
                (Jt = "animate"),
                qt ||
                  ((Jt = "attr"),
                  (this.plotBackground = qt =
                    q.rect().addClass("highcharts-plot-background").add())),
                qt[Jt](St),
                rt ||
                  (qt.attr({ fill: ft || "none" }).shadow(Z.plotShadow),
                  yt &&
                    (ht
                      ? (yt !== ht.attr("href") && ht.attr("href", yt),
                        ht.animate(St))
                      : (this.plotBGImage = q
                          .image(yt, ut, gt, wt, xt)
                          .add()))),
                kt
                  ? kt.animate({ width: Nt.width, height: Nt.height })
                  : (this.clipRect = q.clipRect(Nt)),
                (Jt = "animate"),
                ge ||
                  ((Jt = "attr"),
                  (this.plotBorder = ge =
                    q
                      .rect()
                      .addClass("highcharts-plot-border")
                      .attr({ zIndex: 1 })
                      .add())),
                rt ||
                  ge.attr({
                    stroke: Z.plotBorderColor,
                    "stroke-width": Z.plotBorderWidth || 0,
                    fill: "none",
                  }),
                ge[Jt](
                  ge.crisp(
                    { x: ut, y: gt, width: wt, height: xt },
                    -ge.strokeWidth()
                  )
                ),
                (this.isDirtyBox = !1),
                H(this, "afterDrawChartBox");
            }
            propFromSeries() {
              const Z = this,
                q = Z.options.chart,
                nt = Z.options.series;
              let it, rt, ht;
              ["inverted", "angular", "polar"].forEach(function (ct) {
                for (
                  rt = C[q.type],
                    ht = q[ct] || (rt && rt.prototype[ct]),
                    it = nt && nt.length;
                  !ht && it--;

                )
                  (rt = C[nt[it].type]) && rt.prototype[ct] && (ht = !0);
                Z[ct] = ht;
              });
            }
            linkSeries(Z) {
              const q = this,
                nt = q.series;
              nt.forEach(function (it) {
                it.linkedSeries.length = 0;
              }),
                nt.forEach(function (it) {
                  let rt = it.options.linkedTo;
                  tt(rt) &&
                    (rt =
                      rt === ":previous"
                        ? q.series[it.index - 1]
                        : q.get(rt)) &&
                    rt.linkedParent !== it &&
                    (rt.linkedSeries.push(it),
                    (it.linkedParent = rt),
                    rt.enabledDataSorting && it.setDataSortingOptions(),
                    (it.visible = F(
                      it.options.visible,
                      rt.options.visible,
                      it.visible
                    )));
                }),
                H(this, "afterLinkSeries", { isUpdating: Z });
            }
            renderSeries() {
              this.series.forEach(function (Z) {
                Z.translate(), Z.render();
              });
            }
            render() {
              const Z = this.axes,
                q = this.colorAxis,
                nt = this.renderer,
                it = function (ut) {
                  ut.forEach(function (gt) {
                    gt.visible && gt.render();
                  });
                };
              let rt = 0;
              this.setTitle(),
                H(this, "beforeMargins"),
                this.getStacks && this.getStacks(),
                this.getMargins(!0),
                this.setChartSize();
              const ht = this.plotWidth;
              Z.some(function (ut) {
                if (
                  ut.horiz &&
                  ut.visible &&
                  ut.options.labels.enabled &&
                  ut.series.length
                )
                  return (rt = 21), !0;
              });
              const ct = (this.plotHeight = Math.max(this.plotHeight - rt, 0));
              Z.forEach(function (ut) {
                ut.setScale();
              }),
                this.getAxisMargins();
              const ft = 1.1 < ht / this.plotWidth,
                yt = 1.05 < ct / this.plotHeight;
              (ft || yt) &&
                (Z.forEach(function (ut) {
                  ((ut.horiz && ft) || (!ut.horiz && yt)) &&
                    ut.setTickInterval(!0);
                }),
                this.getMargins()),
                this.drawChartBox(),
                this.hasCartesianSeries ? it(Z) : q && q.length && it(q),
                this.seriesGroup ||
                  (this.seriesGroup = nt
                    .g("series-group")
                    .attr({ zIndex: 3 })
                    .shadow(this.options.chart.seriesGroupShadow)
                    .add()),
                this.renderSeries(),
                this.addCredits(),
                this.setResponsive && this.setResponsive(),
                (this.hasRendered = !0);
            }
            addCredits(Z) {
              const q = this,
                nt = j(!0, this.options.credits, Z);
              nt.enabled &&
                !this.credits &&
                ((this.credits = this.renderer
                  .text(nt.text + (this.mapCredits || ""), 0, 0)
                  .addClass("highcharts-credits")
                  .on("click", function () {
                    nt.href && (y.location.href = nt.href);
                  })
                  .attr({ align: nt.position.align, zIndex: 8 })),
                q.styledMode || this.credits.css(nt.style),
                this.credits.add().align(nt.position),
                (this.credits.update = function (it) {
                  (q.credits = q.credits.destroy()), q.addCredits(it);
                }));
            }
            destroy() {
              const Z = this,
                q = Z.axes,
                nt = Z.series,
                it = Z.container,
                rt = it && it.parentNode;
              let ht;
              for (
                H(Z, "destroy"),
                  Z.renderer.forExport ? R(A, Z) : (A[Z.index] = void 0),
                  G.chartCount--,
                  Z.renderTo.removeAttribute("data-highcharts-chart"),
                  $(Z),
                  ht = q.length;
                ht--;

              )
                q[ht] = q[ht].destroy();
              for (
                this.scroller &&
                  this.scroller.destroy &&
                  this.scroller.destroy(),
                  ht = nt.length;
                ht--;

              )
                nt[ht] = nt[ht].destroy();
              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer"
                .split(" ")
                .forEach(function (ct) {
                  const ft = Z[ct];
                  ft && ft.destroy && (Z[ct] = ft.destroy());
                }),
                it && ((it.innerHTML = P.emptyHTML), $(it), rt && w(it)),
                I(Z, function (ct, ft) {
                  delete Z[ft];
                });
            }
            firstRender() {
              const Z = this,
                q = Z.options;
              Z.getContainer(),
                Z.resetMargins(),
                Z.setChartSize(),
                Z.propFromSeries(),
                Z.getAxes();
              const nt = U(q.series) ? q.series : [];
              (q.series = []),
                nt.forEach(function (it) {
                  Z.initSeries(it);
                }),
                Z.linkSeries(),
                Z.setSeriesData(),
                H(Z, "beforeRender"),
                Z.render(),
                Z.pointer.getChartPosition(),
                !Z.renderer.imgCount && !Z.hasLoaded && Z.onload(),
                Z.temporaryDisplay(!0);
            }
            onload() {
              this.callbacks.concat([this.callback]).forEach(function (Z) {
                Z && typeof this.index < "u" && Z.apply(this, [this]);
              }, this),
                H(this, "load"),
                H(this, "render"),
                v(this.index) && this.setReflow(),
                this.warnIfA11yModuleNotLoaded(),
                (this.hasLoaded = !0);
            }
            warnIfA11yModuleNotLoaded() {
              const { options: Z, title: q } = this;
              Z &&
                !this.accessibility &&
                (this.renderer.boxWrapper.attr({
                  role: "img",
                  "aria-label": ((q && q.element.textContent) || "").replace(
                    /</g,
                    "&lt;"
                  ),
                }),
                (Z.accessibility && Z.accessibility.enabled === !1) ||
                  X(
                    'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
                    !1,
                    this
                  ));
            }
            addSeries(Z, q, nt) {
              const it = this;
              let rt;
              return (
                Z &&
                  ((q = F(q, !0)),
                  H(it, "addSeries", { options: Z }, function () {
                    (rt = it.initSeries(Z)),
                      (it.isDirtyLegend = !0),
                      it.linkSeries(),
                      rt.enabledDataSorting && rt.setData(Z.data, !1),
                      H(it, "afterAddSeries", { series: rt }),
                      q && it.redraw(nt);
                  })),
                rt
              );
            }
            addAxis(Z, q, nt, it) {
              return this.createAxis(q ? "xAxis" : "yAxis", {
                axis: Z,
                redraw: nt,
                animation: it,
              });
            }
            addColorAxis(Z, q, nt) {
              return this.createAxis("colorAxis", {
                axis: Z,
                redraw: q,
                animation: nt,
              });
            }
            createAxis(Z, q) {
              return (
                (Z = new d(this, q.axis, Z)),
                F(q.redraw, !0) && this.redraw(q.animation),
                Z
              );
            }
            showLoading(Z) {
              const q = this,
                nt = q.options,
                it = nt.loading,
                rt = function () {
                  ht &&
                    u(ht, {
                      left: q.plotLeft + "px",
                      top: q.plotTop + "px",
                      width: q.plotWidth + "px",
                      height: q.plotHeight + "px",
                    });
                };
              let ht = q.loadingDiv,
                ct = q.loadingSpan;
              ht ||
                (q.loadingDiv = ht =
                  c(
                    "div",
                    {
                      className: "highcharts-loading highcharts-loading-hidden",
                    },
                    null,
                    q.container
                  )),
                ct ||
                  ((q.loadingSpan = ct =
                    c(
                      "span",
                      { className: "highcharts-loading-inner" },
                      null,
                      ht
                    )),
                  o(q, "redraw", rt)),
                (ht.className = "highcharts-loading"),
                P.setElementHTML(ct, F(Z, nt.lang.loading, "")),
                q.styledMode ||
                  (u(ht, J(it.style, { zIndex: 10 })),
                  u(ct, it.labelStyle),
                  q.loadingShown ||
                    (u(ht, { opacity: 0, display: "" }),
                    h(
                      ht,
                      { opacity: it.style.opacity || 0.5 },
                      { duration: it.showDuration || 0 }
                    ))),
                (q.loadingShown = !0),
                rt();
            }
            hideLoading() {
              const Z = this.options,
                q = this.loadingDiv;
              q &&
                ((q.className = "highcharts-loading highcharts-loading-hidden"),
                this.styledMode ||
                  h(
                    q,
                    { opacity: 0 },
                    {
                      duration: Z.loading.hideDuration || 100,
                      complete: function () {
                        u(q, { display: "none" });
                      },
                    }
                  )),
                (this.loadingShown = !1);
            }
            update(Z, q, nt, it) {
              const rt = this,
                ht = {
                  credits: "addCredits",
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption",
                },
                ct = Z.isResponsiveOptions,
                ft = [];
              let yt, ut;
              H(rt, "update", { options: Z }),
                ct || rt.setResponsive(!1, !0),
                (Z = N(Z, rt.options)),
                (rt.userOptions = j(rt.userOptions, Z));
              var gt = Z.chart;
              if (gt) {
                if (
                  (j(!0, rt.options.chart, gt),
                  this.setZoomOptions(),
                  "className" in gt && rt.setClassName(gt.className),
                  "inverted" in gt || "polar" in gt || "type" in gt)
                ) {
                  rt.propFromSeries();
                  var wt = !0;
                }
                "alignTicks" in gt && (wt = !0),
                  "events" in gt && D(this, gt),
                  I(gt, function (xt, St) {
                    rt.propsRequireUpdateSeries.indexOf("chart." + St) !== -1 &&
                      (yt = !0),
                      rt.propsRequireDirtyBox.indexOf(St) !== -1 &&
                        (rt.isDirtyBox = !0),
                      rt.propsRequireReflow.indexOf(St) !== -1 &&
                        (ct ? (rt.isDirtyBox = !0) : (ut = !0));
                  }),
                  !rt.styledMode &&
                    gt.style &&
                    rt.renderer.setStyle(rt.options.chart.style || {});
              }
              !rt.styledMode && Z.colors && (this.options.colors = Z.colors),
                Z.time &&
                  (this.time === g && (this.time = new S(Z.time)),
                  j(!0, rt.options.time, Z.time)),
                I(Z, function (xt, St) {
                  rt[St] && typeof rt[St].update == "function"
                    ? rt[St].update(xt, !1)
                    : typeof rt[ht[St]] == "function"
                    ? rt[ht[St]](xt)
                    : St !== "colors" &&
                      rt.collectionsWithUpdate.indexOf(St) === -1 &&
                      j(!0, rt.options[St], Z[St]),
                    St !== "chart" &&
                      rt.propsRequireUpdateSeries.indexOf(St) !== -1 &&
                      (yt = !0);
                }),
                this.collectionsWithUpdate.forEach(function (xt) {
                  Z[xt] &&
                    (et(Z[xt]).forEach(function (St, kt) {
                      const Nt = v(St.id);
                      let Mt;
                      Nt && (Mt = rt.get(St.id)),
                        !Mt &&
                          rt[xt] &&
                          (Mt = rt[xt][F(St.index, kt)]) &&
                          ((Nt && v(Mt.options.id)) || Mt.options.isInternal) &&
                          (Mt = void 0),
                        Mt &&
                          Mt.coll === xt &&
                          (Mt.update(St, !1), nt && (Mt.touched = !0)),
                        !Mt &&
                          nt &&
                          rt.collectionsWithInit[xt] &&
                          (rt.collectionsWithInit[xt][0].apply(
                            rt,
                            [St]
                              .concat(rt.collectionsWithInit[xt][1] || [])
                              .concat([!1])
                          ).touched = !0);
                    }),
                    nt &&
                      rt[xt].forEach(function (St) {
                        St.touched || St.options.isInternal
                          ? delete St.touched
                          : ft.push(St);
                      }));
                }),
                ft.forEach(function (xt) {
                  xt.chart && xt.remove && xt.remove(!1);
                }),
                wt &&
                  rt.axes.forEach(function (xt) {
                    xt.update({}, !1);
                  }),
                yt &&
                  rt.getSeriesOrderByLinks().forEach(function (xt) {
                    xt.chart && xt.update({}, !1);
                  }, this),
                (wt = gt && gt.width),
                (gt =
                  gt &&
                  (tt(gt.height)
                    ? Q(gt.height, wt || rt.chartWidth)
                    : gt.height)),
                ut ||
                (_(wt) && wt !== rt.chartWidth) ||
                (_(gt) && gt !== rt.chartHeight)
                  ? rt.setSize(wt, gt, it)
                  : F(q, !0) && rt.redraw(it),
                H(rt, "afterUpdate", { options: Z, redraw: q, animation: it });
            }
            setSubtitle(Z, q) {
              this.applyDescription("subtitle", Z), this.layOutTitles(q);
            }
            setCaption(Z, q) {
              this.applyDescription("caption", Z), this.layOutTitles(q);
            }
            showResetZoom() {
              function Z() {
                q.zoomOut();
              }
              const q = this,
                nt = p.lang,
                it = q.zooming.resetButton,
                rt = it.theme,
                ht =
                  it.relativeTo === "chart" || it.relativeTo === "spacingBox"
                    ? null
                    : "scrollablePlotBox";
              H(this, "beforeShowResetZoom", null, function () {
                q.resetZoomButton = q.renderer
                  .button(nt.resetZoom, null, null, Z, rt)
                  .attr({ align: it.position.align, title: nt.resetZoomTitle })
                  .addClass("highcharts-reset-zoom")
                  .add()
                  .align(it.position, !1, ht);
              }),
                H(this, "afterShowResetZoom");
            }
            zoomOut() {
              H(this, "selection", { resetSelection: !0 }, this.zoom);
            }
            zoom(Z) {
              const q = this,
                nt = q.pointer;
              let it = !1,
                rt;
              !Z || Z.resetSelection
                ? (q.axes.forEach(function (ct) {
                    rt = ct.zoom();
                  }),
                  (nt.initiated = !1))
                : Z.xAxis.concat(Z.yAxis).forEach(function (ct) {
                    const ft = ct.axis;
                    ((nt[ft.isXAxis ? "zoomX" : "zoomY"] &&
                      v(nt.mouseDownX) &&
                      v(nt.mouseDownY) &&
                      q.isInsidePlot(
                        nt.mouseDownX - q.plotLeft,
                        nt.mouseDownY - q.plotTop,
                        { axis: ft }
                      )) ||
                      !v(q.inverted ? nt.mouseDownX : nt.mouseDownY)) &&
                      ((rt = ft.zoom(ct.min, ct.max)),
                      ft.displayBtn && (it = !0));
                  });
              const ht = q.resetZoomButton;
              it && !ht
                ? q.showResetZoom()
                : !it && W(ht) && (q.resetZoomButton = ht.destroy()),
                rt &&
                  q.redraw(
                    F(
                      q.options.chart.animation,
                      Z && Z.animation,
                      100 > q.pointCount
                    )
                  );
            }
            pan(Z, q) {
              const nt = this,
                it = nt.hoverPoints;
              q = typeof q == "object" ? q : { enabled: q, type: "x" };
              const rt = nt.options.chart;
              rt && rt.panning && (rt.panning = q);
              const ht = q.type;
              let ct;
              H(this, "pan", { originalEvent: Z }, function () {
                it &&
                  it.forEach(function (ut) {
                    ut.setState();
                  });
                let ft = nt.xAxis;
                ht === "xy"
                  ? (ft = ft.concat(nt.yAxis))
                  : ht === "y" && (ft = nt.yAxis);
                const yt = {};
                ft.forEach(function (ut) {
                  if (ut.options.panningEnabled && !ut.options.isInternal) {
                    var gt = ut.horiz,
                      wt = Z[gt ? "chartX" : "chartY"];
                    gt = gt ? "mouseDownX" : "mouseDownY";
                    var xt = nt[gt],
                      St = ut.minPointOffset || 0,
                      kt =
                        (ut.reversed && !nt.inverted) ||
                        (!ut.reversed && nt.inverted)
                          ? -1
                          : 1,
                      Nt = ut.getExtremes(),
                      Mt = ut.toValue(xt - wt, !0) + St * kt,
                      qt =
                        ut.toValue(xt + ut.len - wt, !0) -
                        (St * kt || (ut.isXAxis && ut.pointRangePadding) || 0),
                      ge = qt < Mt;
                    (kt = ut.hasVerticalPanning()),
                      (xt = ge ? qt : Mt),
                      (Mt = ge ? Mt : qt);
                    var Dt = ut.panningState;
                    !kt ||
                      ut.isXAxis ||
                      (Dt && !Dt.isDirty) ||
                      ut.series.forEach(function (ke) {
                        var Jt = ke.getProcessedData(!0);
                        (Jt = ke.getExtremes(Jt.yData, !0)),
                          Dt ||
                            (Dt = {
                              startMin: Number.MAX_VALUE,
                              startMax: -Number.MAX_VALUE,
                            }),
                          _(Jt.dataMin) &&
                            _(Jt.dataMax) &&
                            ((Dt.startMin = Math.min(
                              F(ke.options.threshold, 1 / 0),
                              Jt.dataMin,
                              Dt.startMin
                            )),
                            (Dt.startMax = Math.max(
                              F(ke.options.threshold, -1 / 0),
                              Jt.dataMax,
                              Dt.startMax
                            )));
                      }),
                      (kt = Math.min(
                        F(Dt && Dt.startMin, Nt.dataMin),
                        St
                          ? Nt.min
                          : ut.toValue(ut.toPixels(Nt.min) - ut.minPixelPadding)
                      )),
                      (qt = Math.max(
                        F(Dt && Dt.startMax, Nt.dataMax),
                        St
                          ? Nt.max
                          : ut.toValue(ut.toPixels(Nt.max) + ut.minPixelPadding)
                      )),
                      (ut.panningState = Dt),
                      ut.isOrdinal ||
                        ((St = kt - xt),
                        0 < St && ((Mt += St), (xt = kt)),
                        (St = Mt - qt),
                        0 < St && ((Mt = qt), (xt -= St)),
                        ut.series.length &&
                          xt !== Nt.min &&
                          Mt !== Nt.max &&
                          xt >= kt &&
                          Mt <= qt &&
                          (ut.setExtremes(xt, Mt, !1, !1, { trigger: "pan" }),
                          !nt.resetZoomButton &&
                            xt !== kt &&
                            Mt !== qt &&
                            ht.match("y") &&
                            (nt.showResetZoom(), (ut.displayBtn = !1)),
                          (ct = !0)),
                        (yt[gt] = wt));
                  }
                }),
                  I(yt, (ut, gt) => {
                    nt[gt] = ut;
                  }),
                  ct && nt.redraw(!1),
                  u(nt.container, { cursor: "move" });
              });
            }
          }
          return (
            J(at.prototype, {
              callbacks: [],
              collectionsWithInit: {
                xAxis: [at.prototype.addAxis, [!0]],
                yAxis: [at.prototype.addAxis, [!1]],
                series: [at.prototype.addSeries],
              },
              collectionsWithUpdate: ["xAxis", "yAxis", "series"],
              propsRequireDirtyBox:
                "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(
                  " "
                ),
              propsRequireReflow:
                "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(
                  " "
                ),
              propsRequireUpdateSeries:
                "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(
                  " "
                ),
            }),
            at
          );
        }
      ),
      n(
        i,
        "Extensions/ScrollablePlotArea.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Axis/Axis.js"],
          i["Core/Chart/Chart.js"],
          i["Core/Series/Series.js"],
          i["Core/Renderer/RendererRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G) {
          const { stop: Y } = a,
            {
              addEvent: L,
              createElement: E,
              defined: z,
              merge: S,
              pick: x,
            } = G;
          L(M, "afterSetChartSize", function (P) {
            var h = this.options.chart.scrollablePlotArea,
              s = h && h.minWidth;
            h = h && h.minHeight;
            let l;
            this.renderer.forExport ||
              (s
                ? (this.scrollablePixelsX = s =
                    Math.max(0, s - this.chartWidth)) &&
                  ((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
                    S(this.plotBox)),
                  (this.plotBox.width = this.plotWidth += s),
                  this.inverted
                    ? (this.clipBox.height += s)
                    : (this.clipBox.width += s),
                  (l = { 1: { name: "right", value: s } }))
                : h &&
                  ((this.scrollablePixelsY = s =
                    Math.max(0, h - this.chartHeight)),
                  z(s) &&
                    ((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
                      S(this.plotBox)),
                    (this.plotBox.height = this.plotHeight += s),
                    this.inverted
                      ? (this.clipBox.width += s)
                      : (this.clipBox.height += s),
                    (l = { 2: { name: "bottom", value: s } }))),
              l &&
                !P.skipAxes &&
                this.axes.forEach(function (p) {
                  l[p.side]
                    ? (p.getPlotLinePath = function () {
                        let g = l[p.side].name,
                          T = this[g],
                          D;
                        return (
                          (this[g] = T - l[p.side].value),
                          (D = d.prototype.getPlotLinePath.apply(
                            this,
                            arguments
                          )),
                          (this[g] = T),
                          D
                        );
                      })
                    : (p.setAxisSize(), p.setAxisTranslation());
                }));
          }),
            L(M, "render", function () {
              this.scrollablePixelsX || this.scrollablePixelsY
                ? (this.setUpScrolling && this.setUpScrolling(),
                  this.applyFixed())
                : this.fixedDiv && this.applyFixed();
            }),
            (M.prototype.setUpScrolling = function () {
              const P = {
                WebkitOverflowScrolling: "touch",
                overflowX: "hidden",
                overflowY: "hidden",
              };
              this.scrollablePixelsX && (P.overflowX = "auto"),
                this.scrollablePixelsY && (P.overflowY = "auto"),
                (this.scrollingParent = E(
                  "div",
                  { className: "highcharts-scrolling-parent" },
                  { position: "relative" },
                  this.renderTo
                )),
                (this.scrollingContainer = E(
                  "div",
                  { className: "highcharts-scrolling" },
                  P,
                  this.scrollingParent
                ));
              let h;
              L(this.scrollingContainer, "scroll", () => {
                this.pointer &&
                  (delete this.pointer.chartPosition,
                  this.hoverPoint && (h = this.hoverPoint),
                  this.pointer.runPointActions(void 0, h, !0));
              }),
                (this.innerContainer = E(
                  "div",
                  { className: "highcharts-inner-container" },
                  null,
                  this.scrollingContainer
                )),
                this.innerContainer.appendChild(this.container),
                (this.setUpScrolling = null);
            }),
            (M.prototype.moveFixedElements = function () {
              let P = this.container,
                h = this.fixedRenderer,
                s =
                  ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(
                    " "
                  ),
                l;
              this.scrollablePixelsX && !this.inverted
                ? (l = ".highcharts-yaxis")
                : (this.scrollablePixelsX && this.inverted) ||
                  (this.scrollablePixelsY && !this.inverted)
                ? (l = ".highcharts-xaxis")
                : this.scrollablePixelsY &&
                  this.inverted &&
                  (l = ".highcharts-yaxis"),
                l &&
                  s.push(
                    `${l}:not(.highcharts-radial-axis)`,
                    `${l}-labels:not(.highcharts-radial-axis-labels)`
                  ),
                s.forEach(function (p) {
                  [].forEach.call(P.querySelectorAll(p), function (g) {
                    (g.namespaceURI === h.SVG_NS
                      ? h.box
                      : h.box.parentNode
                    ).appendChild(g),
                      (g.style.pointerEvents = "auto");
                  });
                });
            }),
            (M.prototype.applyFixed = function () {
              var P = !this.fixedDiv,
                h = this.options.chart,
                s = h.scrollablePlotArea,
                l = B.getRendererType();
              P
                ? ((this.fixedDiv = E(
                    "div",
                    { className: "highcharts-fixed" },
                    {
                      position: "absolute",
                      overflow: "hidden",
                      pointerEvents: "none",
                      zIndex: ((h.style && h.style.zIndex) || 0) + 2,
                      top: 0,
                    },
                    null,
                    !0
                  )),
                  this.scrollingContainer &&
                    this.scrollingContainer.parentNode.insertBefore(
                      this.fixedDiv,
                      this.scrollingContainer
                    ),
                  (this.renderTo.style.overflow = "visible"),
                  (this.fixedRenderer = h =
                    new l(
                      this.fixedDiv,
                      this.chartWidth,
                      this.chartHeight,
                      this.options.chart.style
                    )),
                  (this.scrollableMask = h
                    .path()
                    .attr({
                      fill: this.options.chart.backgroundColor || "#fff",
                      "fill-opacity": x(s.opacity, 0.85),
                      zIndex: -1,
                    })
                    .addClass("highcharts-scrollable-mask")
                    .add()),
                  L(this, "afterShowResetZoom", this.moveFixedElements),
                  L(this, "afterApplyDrilldown", this.moveFixedElements),
                  L(this, "afterLayOutTitles", this.moveFixedElements))
                : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight),
                (this.scrollableDirty || P) &&
                  ((this.scrollableDirty = !1), this.moveFixedElements()),
                (h = this.chartWidth + (this.scrollablePixelsX || 0)),
                (l = this.chartHeight + (this.scrollablePixelsY || 0)),
                Y(this.container),
                (this.container.style.width = h + "px"),
                (this.container.style.height = l + "px"),
                this.renderer.boxWrapper.attr({
                  width: h,
                  height: l,
                  viewBox: [0, 0, h, l].join(" "),
                }),
                this.chartBackground.attr({ width: h, height: l }),
                (this.scrollingContainer.style.height =
                  this.chartHeight + "px"),
                P &&
                  (s.scrollPositionX &&
                    (this.scrollingContainer.scrollLeft =
                      this.scrollablePixelsX * s.scrollPositionX),
                  s.scrollPositionY &&
                    (this.scrollingContainer.scrollTop =
                      this.scrollablePixelsY * s.scrollPositionY)),
                (l = this.axisOffset),
                (P = this.plotTop - l[0] - 1),
                (s = this.plotLeft - l[3] - 1),
                (h = this.plotTop + this.plotHeight + l[2] + 1),
                (l = this.plotLeft + this.plotWidth + l[1] + 1);
              let p =
                  this.plotLeft +
                  this.plotWidth -
                  (this.scrollablePixelsX || 0),
                g =
                  this.plotTop +
                  this.plotHeight -
                  (this.scrollablePixelsY || 0);
              (P = this.scrollablePixelsX
                ? [
                    ["M", 0, P],
                    ["L", this.plotLeft - 1, P],
                    ["L", this.plotLeft - 1, h],
                    ["L", 0, h],
                    ["Z"],
                    ["M", p, P],
                    ["L", this.chartWidth, P],
                    ["L", this.chartWidth, h],
                    ["L", p, h],
                    ["Z"],
                  ]
                : this.scrollablePixelsY
                ? [
                    ["M", s, 0],
                    ["L", s, this.plotTop - 1],
                    ["L", l, this.plotTop - 1],
                    ["L", l, 0],
                    ["Z"],
                    ["M", s, g],
                    ["L", s, this.chartHeight],
                    ["L", l, this.chartHeight],
                    ["L", l, g],
                    ["Z"],
                  ]
                : [["M", 0, 0]]),
                this.redrawTrigger !== "adjustHeight" &&
                  this.scrollableMask.attr({ d: P });
            }),
            L(d, "afterInit", function () {
              this.chart.scrollableDirty = !0;
            }),
            L(O, "show", function () {
              this.chart.scrollableDirty = !0;
            });
        }
      ),
      n(
        i,
        "Core/Axis/Stacking/StackItem.js",
        [
          i["Core/Templating.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { format: O } = a,
            { series: B } = d,
            {
              destroyObjectProperties: G,
              fireEvent: Y,
              isNumber: L,
              pick: E,
            } = M;
          class z {
            constructor(x, P, h, s, l) {
              const p = x.chart.inverted,
                g = x.reversed;
              (this.axis = x),
                (x = this.isNegative = !!h != !!g),
                (this.options = P = P || {}),
                (this.x = s),
                (this.cumulative = this.total = null),
                (this.points = {}),
                (this.hasValidPoints = !1),
                (this.stack = l),
                (this.rightCliff = this.leftCliff = 0),
                (this.alignOptions = {
                  align: P.align || (p ? (x ? "left" : "right") : "center"),
                  verticalAlign:
                    P.verticalAlign || (p ? "middle" : x ? "bottom" : "top"),
                  y: P.y,
                  x: P.x,
                }),
                (this.textAlign =
                  P.textAlign || (p ? (x ? "right" : "left") : "center"));
            }
            destroy() {
              G(this, this.axis);
            }
            render(x) {
              const P = this.axis.chart,
                h = this.options;
              var s = h.format;
              (s = s ? O(s, this, P) : h.formatter.call(this)),
                this.label
                  ? this.label.attr({ text: s, visibility: "hidden" })
                  : ((this.label = P.renderer.label(
                      s,
                      null,
                      void 0,
                      h.shape,
                      void 0,
                      void 0,
                      h.useHTML,
                      !1,
                      "stack-labels"
                    )),
                    (s = {
                      r: h.borderRadius || 0,
                      text: s,
                      padding: E(h.padding, 5),
                      visibility: "hidden",
                    }),
                    P.styledMode ||
                      ((s.fill = h.backgroundColor),
                      (s.stroke = h.borderColor),
                      (s["stroke-width"] = h.borderWidth),
                      this.label.css(h.style || {})),
                    this.label.attr(s),
                    this.label.added || this.label.add(x)),
                (this.label.labelrank = P.plotSizeY),
                Y(this, "afterRender");
            }
            setOffset(x, P, h, s, l, p) {
              const {
                  alignOptions: g,
                  axis: T,
                  label: D,
                  options: A,
                  textAlign: m,
                } = this,
                f = T.chart;
              h = this.getStackBox({
                xOffset: x,
                width: P,
                boxBottom: h,
                boxTop: s,
                defaultX: l,
                xAxis: p,
              });
              var { verticalAlign: b } = g;
              if (D && h) {
                (s = D.getBBox()),
                  (l = D.padding),
                  (p = E(A.overflow, "justify") === "justify"),
                  (g.x = A.x || 0),
                  (g.y = A.y || 0);
                const { x: y, y: C } = this.adjustStackPosition({
                  labelBox: s,
                  verticalAlign: b,
                  textAlign: m,
                });
                (h.x -= y),
                  (h.y -= C),
                  D.align(g, !1, h),
                  (b = f.isInsidePlot(
                    D.alignAttr.x + g.x + y,
                    D.alignAttr.y + g.y + C
                  )) || (p = !1),
                  p &&
                    B.prototype.justifyDataLabel.call(
                      T,
                      D,
                      g,
                      D.alignAttr,
                      s,
                      h
                    ),
                  D.attr({
                    x: D.alignAttr.x,
                    y: D.alignAttr.y,
                    rotation: A.rotation,
                    rotationOriginX: s.width / 2,
                    rotationOriginY: s.height / 2,
                  }),
                  E(!p && A.crop, !0) &&
                    (b =
                      L(D.x) &&
                      L(D.y) &&
                      f.isInsidePlot(D.x - l + D.width, D.y) &&
                      f.isInsidePlot(D.x + l, D.y)),
                  D[b ? "show" : "hide"]();
              }
              Y(this, "afterSetOffset", { xOffset: x, width: P });
            }
            adjustStackPosition({
              labelBox: x,
              verticalAlign: P,
              textAlign: h,
            }) {
              const s = {
                bottom: 0,
                middle: 1,
                top: 2,
                right: 1,
                center: 0,
                left: -1,
              };
              return {
                x: x.width / 2 + (x.width / 2) * s[h],
                y: (x.height / 2) * s[P],
              };
            }
            getStackBox(x) {
              var P = this.axis;
              const h = P.chart,
                {
                  boxTop: s,
                  defaultX: l,
                  xOffset: p,
                  width: g,
                  boxBottom: T,
                } = x;
              var D = P.stacking.usePercentage ? 100 : E(s, this.total, 0);
              (D = P.toPixels(D)), (x = x.xAxis || h.xAxis[0]);
              const A = E(l, x.translate(this.x)) + p;
              (P = P.toPixels(
                T ||
                  (L(P.min) && P.logarithmic && P.logarithmic.lin2log(P.min)) ||
                  0
              )),
                (P = Math.abs(D - P));
              const m = this.isNegative;
              return h.inverted
                ? {
                    x: (m ? D : D - P) - h.plotLeft,
                    y: x.height - A - g,
                    width: P,
                    height: g,
                  }
                : {
                    x: A + x.transB - h.plotLeft,
                    y: (m ? D - P : D) - h.plotTop,
                    width: g,
                    height: P,
                  };
            }
          }
          return z;
        }
      ),
      n(
        i,
        "Core/Axis/Stacking/StackingAxis.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Axis/Axis.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Axis/Stacking/StackItem.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B) {
          function G() {
            const o = this,
              r = o.inverted;
            o.yAxis.forEach((c) => {
              c.stacking &&
                c.stacking.stacks &&
                c.hasVisibleSeries &&
                (c.stacking.oldStacks = c.stacking.stacks);
            }),
              o.series.forEach((c) => {
                const u = (c.xAxis && c.xAxis.options) || {};
                !c.options.stacking ||
                  (c.visible !== !0 &&
                    o.options.chart.ignoreHiddenSeries !== !1) ||
                  (c.stackKey = [
                    c.type,
                    b(c.options.stack, ""),
                    r ? u.top : u.left,
                    r ? u.height : u.width,
                  ].join());
              });
          }
          function Y() {
            const o = this.stacking;
            if (o) {
              var r = o.stacks;
              f(r, function (c, u) {
                T(c), (r[u] = null);
              }),
                o && o.stackTotalGroup && o.stackTotalGroup.destroy();
            }
          }
          function L() {
            this.coll !== "yAxis" ||
              this.stacking ||
              (this.stacking = new y(this));
          }
          function E(o, r, c, u) {
            return (
              !g(o) || o.x !== r || (u && o.stackKey !== u)
                ? (o = { x: r, index: 0, key: u, stackKey: u })
                : o.index++,
              (o.key = [c, r, o.index].join()),
              o
            );
          }
          function z() {
            const o = this,
              r = o.stackKey,
              c = o.yAxis.stacking.stacks,
              u = o.processedXData,
              v = o[o.options.stacking + "Stacker"];
            let N;
            v &&
              [r, "-" + r].forEach((w) => {
                let R = u.length,
                  X;
                for (; R--; ) {
                  var J = u[R];
                  (N = o.getStackIndicator(N, J, o.index, w)),
                    (X = (J = c[w] && c[w][J]) && J.points[N.key]) &&
                      v.call(o, X, J, R);
                }
              });
          }
          function S(o, r, c) {
            (r = r.total ? 100 / r.total : 0),
              (o[0] = p(o[0] * r)),
              (o[1] = p(o[1] * r)),
              (this.stackedYData[c] = o[1]);
          }
          function x() {
            const o = this.yAxis.stacking;
            this.options.centerInCategory &&
            (this.is("column") || this.is("columnrange")) &&
            !this.options.stacking &&
            1 < this.chart.series.length
              ? s.setStackedPoints.call(this, "group")
              : o &&
                f(o.stacks, (r, c) => {
                  c.slice(-5) === "group" &&
                    (f(r, (u) => u.destroy()), delete o.stacks[c]);
                });
          }
          function P(o) {
            var r = this.chart;
            const c = o || this.options.stacking;
            if (
              c &&
              (this.visible === !0 || r.options.chart.ignoreHiddenSeries === !1)
            ) {
              var u = this.processedXData,
                v = this.processedYData,
                N = [],
                w = v.length,
                R = this.options,
                X = R.threshold,
                J = b(R.startFromThreshold && X, 0);
              (R = R.stack), (o = o ? `${this.type},${c}` : this.stackKey);
              var K = "-" + o,
                H = this.negStacks;
              r = c === "group" ? r.yAxis[0] : this.yAxis;
              var k = r.stacking.stacks,
                U = r.stacking.oldStacks,
                _,
                W;
              for (r.stacking.stacksTouched += 1, W = 0; W < w; W++) {
                var tt = u[W],
                  j = v[W],
                  I = this.getStackIndicator(I, tt, this.index),
                  F = I.key,
                  V = (_ = H && j < (J ? 0 : X)) ? K : o;
                k[V] || (k[V] = {}),
                  k[V][tt] ||
                    (U[V] && U[V][tt]
                      ? ((k[V][tt] = U[V][tt]), (k[V][tt].total = null))
                      : (k[V][tt] = new O(
                          r,
                          r.options.stackLabels,
                          !!_,
                          tt,
                          R
                        ))),
                  (V = k[V][tt]),
                  j !== null
                    ? ((V.points[F] = V.points[this.index] =
                        [b(V.cumulative, J)]),
                      g(V.cumulative) || (V.base = F),
                      (V.touched = r.stacking.stacksTouched),
                      0 < I.index &&
                        this.singleStacks === !1 &&
                        (V.points[F][0] =
                          V.points[this.index + "," + tt + ",0"][0]))
                    : (V.points[F] = V.points[this.index] = null),
                  c === "percent"
                    ? ((_ = _ ? o : K),
                      H && k[_] && k[_][tt]
                        ? ((_ = k[_][tt]),
                          (V.total = _.total =
                            Math.max(_.total, V.total) + Math.abs(j) || 0))
                        : (V.total = p(V.total + (Math.abs(j) || 0))))
                    : c === "group"
                    ? (A(j) && (j = j[0]),
                      j !== null && (V.total = (V.total || 0) + 1))
                    : (V.total = p(V.total + (j || 0))),
                  (V.cumulative =
                    c === "group"
                      ? (V.total || 1) - 1
                      : p(b(V.cumulative, J) + (j || 0))),
                  j !== null &&
                    (V.points[F].push(V.cumulative),
                    (N[W] = V.cumulative),
                    (V.hasValidPoints = !0));
              }
              c === "percent" && (r.stacking.usePercentage = !0),
                c !== "group" && (this.stackedYData = N),
                (r.stacking.oldStacks = {});
            }
          }
          const { getDeferredAnimation: h } = a,
            {
              series: { prototype: s },
            } = M,
            {
              addEvent: l,
              correctFloat: p,
              defined: g,
              destroyObjectProperties: T,
              fireEvent: D,
              isArray: A,
              isNumber: m,
              objectEach: f,
              pick: b,
            } = B;
          class y {
            constructor(r) {
              (this.oldStacks = {}),
                (this.stacks = {}),
                (this.stacksTouched = 0),
                (this.axis = r);
            }
            buildStacks() {
              const r = this.axis,
                c = r.series,
                u = r.options.reversedStacks,
                v = c.length;
              let N, w;
              for (this.usePercentage = !1, w = v; w--; )
                (N = c[u ? w : v - w - 1]),
                  N.setStackedPoints(),
                  N.setGroupedPoints();
              for (w = 0; w < v; w++) c[w].modifyStacks();
              D(r, "afterBuildStacks");
            }
            cleanStacks() {
              let r;
              this.oldStacks && (r = this.stacks = this.oldStacks),
                f(r, function (c) {
                  f(c, function (u) {
                    u.cumulative = u.total;
                  });
                });
            }
            resetStacks() {
              f(this.stacks, (r) => {
                f(r, (c, u) => {
                  m(c.touched) && c.touched < this.stacksTouched
                    ? (c.destroy(), delete r[u])
                    : ((c.total = null), (c.cumulative = null));
                });
              });
            }
            renderStackTotals() {
              var r = this.axis;
              const c = r.chart,
                u = c.renderer,
                v = this.stacks;
              r = h(
                c,
                (r.options.stackLabels && r.options.stackLabels.animation) || !1
              );
              const N = (this.stackTotalGroup =
                this.stackTotalGroup ||
                u.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add());
              N.translate(c.plotLeft, c.plotTop),
                f(v, function (w) {
                  f(w, function (R) {
                    R.render(N);
                  });
                }),
                N.animate({ opacity: 1 }, r);
            }
          }
          var C;
          return (
            (function (o) {
              const r = [];
              o.compose = function (c, u, v) {
                B.pushUnique(r, c) && (l(c, "init", L), l(c, "destroy", Y)),
                  B.pushUnique(r, u) && (u.prototype.getStacks = G),
                  B.pushUnique(r, v) &&
                    ((c = v.prototype),
                    (c.getStackIndicator = E),
                    (c.modifyStacks = z),
                    (c.percentStacker = S),
                    (c.setGroupedPoints = x),
                    (c.setStackedPoints = P));
              };
            })(C || (C = {})),
            C
          );
        }
      ),
      n(
        i,
        "Series/Line/LineSeries.js",
        [
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { defined: O, merge: B } = M;
          class G extends a {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            drawGraph() {
              const L = this,
                E = this.options,
                z = (this.gappedPath || this.getGraphPath).call(this),
                S = this.chart.styledMode;
              let x = [["graph", "highcharts-graph"]];
              S ||
                x[0].push(E.lineColor || this.color || "#cccccc", E.dashStyle),
                (x = L.getZonesGraphs(x)),
                x.forEach(function (P, h) {
                  var s = P[0];
                  let l = L[s];
                  const p = l ? "animate" : "attr";
                  l
                    ? ((l.endX = L.preventGraphAnimation ? null : z.xMap),
                      l.animate({ d: z }))
                    : z.length &&
                      (L[s] = l =
                        L.chart.renderer
                          .path(z)
                          .addClass(P[1])
                          .attr({ zIndex: 1 })
                          .add(L.group)),
                    l &&
                      !S &&
                      ((s = {
                        stroke: P[2],
                        "stroke-width": E.lineWidth || 0,
                        fill: (L.fillGraph && L.color) || "none",
                      }),
                      P[3]
                        ? (s.dashstyle = P[3])
                        : E.linecap !== "square" &&
                          (s["stroke-linecap"] = s["stroke-linejoin"] =
                            "round"),
                      l[p](s).shadow(2 > h && E.shadow)),
                    l && ((l.startX = z.xMap), (l.isArea = z.isArea));
                });
            }
            getGraphPath(L, E, z) {
              const S = this,
                x = S.options,
                P = [],
                h = [];
              let s,
                l = x.step;
              L = L || S.points;
              const p = L.reversed;
              return (
                p && L.reverse(),
                (l = { right: 1, center: 2 }[l] || (l && 3)) &&
                  p &&
                  (l = 4 - l),
                (L = this.getValidPoints(L, !1, !(x.connectNulls && !E && !z))),
                L.forEach(function (g, T) {
                  const D = g.plotX,
                    A = g.plotY,
                    m = L[T - 1],
                    f = g.isNull || typeof A != "number";
                  (g.leftCliff || (m && m.rightCliff)) && !z && (s = !0),
                    f && !O(E) && 0 < T
                      ? (s = !x.connectNulls)
                      : f && !E
                      ? (s = !0)
                      : (T === 0 || s
                          ? (T = [["M", g.plotX, g.plotY]])
                          : S.getPointSpline
                          ? (T = [S.getPointSpline(L, g, T)])
                          : l
                          ? ((T =
                              l === 1
                                ? [["L", m.plotX, A]]
                                : l === 2
                                ? [
                                    ["L", (m.plotX + D) / 2, m.plotY],
                                    ["L", (m.plotX + D) / 2, A],
                                  ]
                                : [["L", D, m.plotY]]),
                            T.push(["L", D, A]))
                          : (T = [["L", D, A]]),
                        h.push(g.x),
                        l && (h.push(g.x), l === 2 && h.push(g.x)),
                        P.push.apply(P, T),
                        (s = !1));
                }),
                (P.xMap = h),
                (S.graphPath = P)
              );
            }
            getZonesGraphs(L) {
              return (
                this.zones.forEach(function (E, z) {
                  (z = [
                    "zone-graph-" + z,
                    "highcharts-graph highcharts-zone-graph-" +
                      z +
                      " " +
                      (E.className || ""),
                  ]),
                    this.chart.styledMode ||
                      z.push(
                        E.color || this.color,
                        E.dashStyle || this.options.dashStyle
                      ),
                    L.push(z);
                }, this),
                L
              );
            }
          }
          return (
            (G.defaultOptions = B(a.defaultOptions, {
              legendSymbol: "lineMarker",
            })),
            d.registerSeriesType("line", G),
            G
          );
        }
      ),
      n(
        i,
        "Series/Area/AreaSeries.js",
        [
          i["Core/Color/Color.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const {
              seriesTypes: { line: O },
            } = d,
            { extend: B, merge: G, objectEach: Y, pick: L } = M;
          class E extends O {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            drawGraph() {
              (this.areaPath = []), super.drawGraph.apply(this);
              const S = this,
                x = this.areaPath,
                P = this.options,
                h = [["area", "highcharts-area", this.color, P.fillColor]];
              this.zones.forEach(function (s, l) {
                h.push([
                  "zone-area-" + l,
                  "highcharts-area highcharts-zone-area-" +
                    l +
                    " " +
                    s.className,
                  s.color || S.color,
                  s.fillColor || P.fillColor,
                ]);
              }),
                h.forEach(function (s) {
                  const l = s[0],
                    p = {};
                  let g = S[l];
                  const T = g ? "animate" : "attr";
                  g
                    ? ((g.endX = S.preventGraphAnimation ? null : x.xMap),
                      g.animate({ d: x }))
                    : ((p.zIndex = 0),
                      (g = S[l] =
                        S.chart.renderer.path(x).addClass(s[1]).add(S.group)),
                      (g.isArea = !0)),
                    S.chart.styledMode ||
                      (s[3]
                        ? (p.fill = s[3])
                        : ((p.fill = s[2]),
                          (p["fill-opacity"] = L(P.fillOpacity, 0.75)))),
                    g[T](p),
                    (g.startX = x.xMap),
                    (g.shiftUnit = P.step ? 2 : 1);
                });
            }
            getGraphPath(S) {
              var x = O.prototype.getGraphPath,
                P = this.options;
              const h = P.stacking,
                s = this.yAxis,
                l = [],
                p = [],
                g = this.index,
                T = s.stacking.stacks[this.stackKey],
                D = P.threshold,
                A = Math.round(s.getThreshold(P.threshold));
              P = L(P.connectNulls, h === "percent");
              var m = function (C, o, r) {
                var c = S[C];
                C = h && T[c.x].points[g];
                const u = c[r + "Null"] || 0;
                r = c[r + "Cliff"] || 0;
                let v, N;
                (c = !0),
                  r || u
                    ? ((v = (u ? C[0] : C[1]) + r), (N = C[0] + r), (c = !!u))
                    : !h && S[o] && S[o].isNull && (v = N = D),
                  typeof v < "u" &&
                    (p.push({
                      plotX: f,
                      plotY: v === null ? A : s.getThreshold(v),
                      isNull: c,
                      isCliff: !0,
                    }),
                    l.push({
                      plotX: f,
                      plotY: N === null ? A : s.getThreshold(N),
                      doCurve: !1,
                    }));
              };
              let f;
              (S = S || this.points), h && (S = this.getStackPoints(S));
              for (let C = 0, o = S.length; C < o; ++C) {
                h ||
                  (S[C].leftCliff =
                    S[C].rightCliff =
                    S[C].leftNull =
                    S[C].rightNull =
                      void 0);
                var b = S[C].isNull;
                f = L(S[C].rectPlotX, S[C].plotX);
                var y = h ? L(S[C].yBottom, A) : A;
                (!b || P) &&
                  (P || m(C, C - 1, "left"),
                  (b && !h && P) ||
                    (p.push(S[C]), l.push({ x: C, plotX: f, plotY: y })),
                  P || m(C, C + 1, "right"));
              }
              return (
                (m = x.call(this, p, !0, !0)),
                (l.reversed = !0),
                (b = x.call(this, l, !0, !0)),
                (y = b[0]) && y[0] === "M" && (b[0] = ["L", y[1], y[2]]),
                (b = m.concat(b)),
                b.length && b.push(["Z"]),
                (x = x.call(this, p, !1, P)),
                (b.xMap = m.xMap),
                (this.areaPath = b),
                x
              );
            }
            getStackPoints(S) {
              const x = this,
                P = [],
                h = [],
                s = this.xAxis,
                l = this.yAxis,
                p = l.stacking.stacks[this.stackKey],
                g = {},
                T = l.series,
                D = T.length,
                A = l.options.reversedStacks ? 1 : -1,
                m = T.indexOf(x);
              if (((S = S || this.points), this.options.stacking)) {
                for (let b = 0; b < S.length; b++)
                  (S[b].leftNull = S[b].rightNull = void 0), (g[S[b].x] = S[b]);
                Y(p, function (b, y) {
                  b.total !== null && h.push(y);
                }),
                  h.sort(function (b, y) {
                    return b - y;
                  });
                const f = T.map((b) => b.visible);
                h.forEach(function (b, y) {
                  let C = 0,
                    o,
                    r;
                  if (g[b] && !g[b].isNull)
                    P.push(g[b]),
                      [-1, 1].forEach(function (c) {
                        const u = c === 1 ? "rightNull" : "leftNull",
                          v = p[h[y + c]];
                        let N = 0;
                        if (v) {
                          let w = m;
                          for (; 0 <= w && w < D; ) {
                            const R = T[w].index;
                            (o = v.points[R]),
                              o ||
                                (R === x.index
                                  ? (g[b][u] = !0)
                                  : f[w] &&
                                    (r = p[b].points[R]) &&
                                    (N -= r[1] - r[0])),
                              (w += A);
                          }
                        }
                        g[b][c === 1 ? "rightCliff" : "leftCliff"] = N;
                      });
                  else {
                    let c = m;
                    for (; 0 <= c && c < D; ) {
                      if ((o = p[b].points[T[c].index])) {
                        C = o[1];
                        break;
                      }
                      c += A;
                    }
                    (C = L(C, 0)),
                      (C = l.translate(C, 0, 1, 0, 1)),
                      P.push({
                        isNull: !0,
                        plotX: s.translate(b, 0, 0, 0, 1),
                        x: b,
                        plotY: C,
                        yBottom: C,
                      });
                  }
                });
              }
              return P;
            }
          }
          return (
            (E.defaultOptions = G(O.defaultOptions, {
              threshold: 0,
              legendSymbol: "rectangle",
            })),
            B(E.prototype, { singleStacks: !1 }),
            d.registerSeriesType("area", E),
            E
          );
        }
      ),
      n(
        i,
        "Series/Spline/SplineSeries.js",
        [i["Core/Series/SeriesRegistry.js"], i["Core/Utilities.js"]],
        function (a, d) {
          const { line: M } = a.seriesTypes,
            { merge: O, pick: B } = d;
          class G extends M {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            getPointSpline(L, E, z) {
              const S = E.plotX || 0,
                x = E.plotY || 0,
                P = L[z - 1];
              z = L[z + 1];
              let h, s, l;
              if (
                P &&
                !P.isNull &&
                P.doCurve !== !1 &&
                !E.isCliff &&
                z &&
                !z.isNull &&
                z.doCurve !== !1 &&
                !E.isCliff
              ) {
                L = P.plotY || 0;
                var p = z.plotX || 0;
                z = z.plotY || 0;
                let g = 0;
                (h = (1.5 * S + (P.plotX || 0)) / 2.5),
                  (s = (1.5 * x + L) / 2.5),
                  (p = (1.5 * S + p) / 2.5),
                  (l = (1.5 * x + z) / 2.5),
                  p !== h && (g = ((l - s) * (p - S)) / (p - h) + x - l),
                  (s += g),
                  (l += g),
                  s > L && s > x
                    ? ((s = Math.max(L, x)), (l = 2 * x - s))
                    : s < L && s < x && ((s = Math.min(L, x)), (l = 2 * x - s)),
                  l > z && l > x
                    ? ((l = Math.max(z, x)), (s = 2 * x - l))
                    : l < z && l < x && ((l = Math.min(z, x)), (s = 2 * x - l)),
                  (E.rightContX = p),
                  (E.rightContY = l);
              }
              return (
                (E = [
                  "C",
                  B(P.rightContX, P.plotX, 0),
                  B(P.rightContY, P.plotY, 0),
                  B(h, S, 0),
                  B(s, x, 0),
                  S,
                  x,
                ]),
                (P.rightContX = P.rightContY = void 0),
                E
              );
            }
          }
          return (
            (G.defaultOptions = O(M.defaultOptions)),
            a.registerSeriesType("spline", G),
            G
          );
        }
      ),
      n(
        i,
        "Series/AreaSpline/AreaSplineSeries.js",
        [
          i["Series/Spline/SplineSeries.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const {
              area: O,
              area: { prototype: B },
            } = d.seriesTypes,
            { extend: G, merge: Y } = M;
          class L extends a {
            constructor() {
              super(...arguments),
                (this.options = this.points = this.data = void 0);
            }
          }
          return (
            (L.defaultOptions = Y(a.defaultOptions, O.defaultOptions)),
            G(L.prototype, {
              getGraphPath: B.getGraphPath,
              getStackPoints: B.getStackPoints,
              drawGraph: B.drawGraph,
            }),
            d.registerSeriesType("areaspline", L),
            L
          );
        }
      ),
      n(i, "Series/Column/ColumnSeriesDefaults.js", [], function () {
        return {
          borderRadius: 3,
          centerInCategory: !1,
          groupPadding: 0.2,
          marker: null,
          pointPadding: 0.1,
          minPointLength: 0,
          cropThreshold: 50,
          pointRange: null,
          states: {
            hover: { halo: !1, brightness: 0.1 },
            select: { color: "#cccccc", borderColor: "#000000" },
          },
          dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 },
          startFromThreshold: !0,
          stickyTracking: !1,
          tooltip: { distance: 6 },
          threshold: 0,
          borderColor: "#ffffff",
        };
      }),
      n(
        i,
        "Series/Column/ColumnSeries.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Color/Color.js"],
          i["Series/Column/ColumnSeriesDefaults.js"],
          i["Core/Globals.js"],
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G, Y) {
          const { animObject: L } = a,
            { parse: E } = d,
            { hasTouch: z, noop: S } = O,
            {
              clamp: x,
              defined: P,
              extend: h,
              fireEvent: s,
              isArray: l,
              isNumber: p,
              merge: g,
              pick: T,
              objectEach: D,
            } = Y;
          class A extends B {
            constructor() {
              super(...arguments),
                (this.points =
                  this.options =
                  this.group =
                  this.data =
                  this.borderWidth =
                    void 0);
            }
            animate(f) {
              const b = this,
                y = this.yAxis,
                C = y.pos,
                o = b.options,
                r = this.chart.inverted,
                c = {},
                u = r ? "translateX" : "translateY";
              let v;
              f
                ? ((c.scaleY = 0.001),
                  (f = x(y.toPixels(o.threshold), C, C + y.len)),
                  r ? (c.translateX = f - y.len) : (c.translateY = f),
                  b.clipBox && b.setClip(),
                  b.group.attr(c))
                : ((v = Number(b.group.attr(u))),
                  b.group.animate(
                    { scaleY: 1 },
                    h(L(b.options.animation), {
                      step: function (N, w) {
                        b.group &&
                          ((c[u] = v + w.pos * (C - v)), b.group.attr(c));
                      },
                    })
                  ));
            }
            init(f, b) {
              super.init.apply(this, arguments);
              const y = this;
              (f = y.chart),
                f.hasRendered &&
                  f.series.forEach(function (C) {
                    C.type === y.type && (C.isDirty = !0);
                  });
            }
            getColumnMetrics() {
              const f = this;
              var b = f.options;
              const y = f.xAxis,
                C = f.yAxis;
              var o = y.options.reversedStacks;
              o = (y.reversed && !o) || (!y.reversed && o);
              const r = {};
              let c,
                u = 0;
              b.grouping === !1
                ? (u = 1)
                : f.chart.series.forEach(function (R) {
                    const X = R.yAxis,
                      J = R.options;
                    let K;
                    R.type !== f.type ||
                      (!R.visible &&
                        f.chart.options.chart.ignoreHiddenSeries) ||
                      C.len !== X.len ||
                      C.pos !== X.pos ||
                      (J.stacking && J.stacking !== "group"
                        ? ((c = R.stackKey),
                          typeof r[c] > "u" && (r[c] = u++),
                          (K = r[c]))
                        : J.grouping !== !1 && (K = u++),
                      (R.columnIndex = K));
                  });
              const v = Math.min(
                  Math.abs(y.transA) *
                    ((y.ordinal && y.ordinal.slope) ||
                      b.pointRange ||
                      y.closestPointRange ||
                      y.tickInterval ||
                      1),
                  y.len
                ),
                N = v * b.groupPadding,
                w = (v - 2 * N) / (u || 1);
              return (
                (b = Math.min(
                  b.maxPointWidth || y.len,
                  T(b.pointWidth, w * (1 - 2 * b.pointPadding))
                )),
                (f.columnMetrics = {
                  width: b,
                  offset:
                    (w - b) / 2 +
                    (N + ((f.columnIndex || 0) + (o ? 1 : 0)) * w - v / 2) *
                      (o ? -1 : 1),
                  paddedWidth: w,
                  columnCount: u,
                }),
                f.columnMetrics
              );
            }
            crispCol(f, b, y, C) {
              var o = this.borderWidth,
                r = -(o % 2 ? 0.5 : 0);
              return (
                (o = o % 2 ? 0.5 : 1),
                this.options.crisp &&
                  ((y = Math.round(f + y) + r),
                  (f = Math.round(f) + r),
                  (y -= f)),
                (C = Math.round(b + C) + o),
                (r = 0.5 >= Math.abs(b) && 0.5 < C),
                (b = Math.round(b) + o),
                (C -= b),
                r && C && (--b, (C += 1)),
                { x: f, y: b, width: y, height: C }
              );
            }
            adjustForMissingColumns(f, b, y, C) {
              const o = this.options.stacking;
              if (!y.isNull && 1 < C.columnCount) {
                const r = this.yAxis.options.reversedStacks;
                let c = 0,
                  u = r ? 0 : -C.columnCount;
                D(this.yAxis.stacking && this.yAxis.stacking.stacks, (v) => {
                  if (typeof y.x == "number") {
                    const N = v[y.x.toString()];
                    N &&
                      ((v = N.points[this.index]),
                      o
                        ? (v && (c = u), N.hasValidPoints && (r ? u++ : u--))
                        : l(v) &&
                          ((v = Object.keys(N.points)
                            .filter(
                              (w) =>
                                !w.match(",") &&
                                N.points[w] &&
                                1 < N.points[w].length
                            )
                            .map(parseFloat)
                            .sort((w, R) => R - w)),
                          (c = v.indexOf(this.index)),
                          (u = v.length)));
                  }
                }),
                  (f =
                    (y.plotX || 0) +
                    ((u - 1) * C.paddedWidth + b) / 2 -
                    b -
                    c * C.paddedWidth);
              }
              return f;
            }
            translate() {
              const f = this,
                b = f.chart,
                y = f.options;
              var C = (f.dense = 2 > f.closestPointRange * f.xAxis.transA);
              C = f.borderWidth = T(y.borderWidth, C ? 0 : 1);
              const o = f.xAxis,
                r = f.yAxis,
                c = y.threshold,
                u = T(y.minPointLength, 5),
                v = f.getColumnMetrics(),
                N = v.width,
                w = (f.pointXOffset = v.offset),
                R = f.dataMin,
                X = f.dataMax;
              let J = (f.barW = Math.max(N, 1 + 2 * C)),
                K = (f.translatedThreshold = r.getThreshold(c));
              b.inverted && (K -= 0.5),
                y.pointPadding && (J = Math.ceil(J)),
                B.prototype.translate.apply(f),
                f.points.forEach(function (H) {
                  const k = T(H.yBottom, K);
                  var U = 999 + Math.abs(k),
                    _ = H.plotX || 0;
                  U = x(H.plotY, -U, r.len + U);
                  let W = Math.min(U, k),
                    tt = Math.max(U, k) - W,
                    j = N,
                    I = _ + w,
                    F = J;
                  u &&
                    Math.abs(tt) < u &&
                    ((tt = u),
                    (_ =
                      (!r.reversed && !H.negative) ||
                      (r.reversed && H.negative)),
                    p(c) &&
                      p(X) &&
                      H.y === c &&
                      X <= c &&
                      (r.min || 0) < c &&
                      (R !== X || (r.max || 0) <= c) &&
                      ((_ = !_), (H.negative = !H.negative)),
                    (W = Math.abs(W - K) > u ? k - u : K - (_ ? u : 0))),
                    P(H.options.pointWidth) &&
                      ((j = F = Math.ceil(H.options.pointWidth)),
                      (I -= Math.round((j - N) / 2))),
                    y.centerInCategory &&
                      (I = f.adjustForMissingColumns(I, j, H, v)),
                    (H.barX = I),
                    (H.pointWidth = j),
                    (H.tooltipPos = b.inverted
                      ? [
                          x(
                            r.len + r.pos - b.plotLeft - U,
                            r.pos - b.plotLeft,
                            r.len + r.pos - b.plotLeft
                          ),
                          o.len + o.pos - b.plotTop - I - F / 2,
                          tt,
                        ]
                      : [
                          o.left - b.plotLeft + I + F / 2,
                          x(
                            U + r.pos - b.plotTop,
                            r.pos - b.plotTop,
                            r.len + r.pos - b.plotTop
                          ),
                          tt,
                        ]),
                    (H.shapeType =
                      f.pointClass.prototype.shapeType || "roundedRect"),
                    (H.shapeArgs = f.crispCol(
                      I,
                      H.isNull ? K : W,
                      F,
                      H.isNull ? 0 : tt
                    ));
                }),
                s(this, "afterColumnTranslate");
            }
            drawGraph() {
              this.group[this.dense ? "addClass" : "removeClass"](
                "highcharts-dense-data"
              );
            }
            pointAttribs(f, b) {
              const y = this.options;
              var C = this.pointAttrToOptions || {},
                o = C.stroke || "borderColor";
              const r = C["stroke-width"] || "borderWidth";
              let c,
                u = (f && f.color) || this.color,
                v = (f && f[o]) || y[o] || u;
              C = (f && f.options.dashStyle) || y.dashStyle;
              let N = (f && f[r]) || y[r] || this[r] || 0,
                w = T(f && f.opacity, y.opacity, 1);
              return (
                f &&
                  this.zones.length &&
                  ((c = f.getZone()),
                  (u =
                    f.options.color ||
                    (c && (c.color || f.nonZonedColor)) ||
                    this.color),
                  c &&
                    ((v = c.borderColor || v),
                    (C = c.dashStyle || C),
                    (N = c.borderWidth || N))),
                b &&
                  f &&
                  ((f = g(
                    y.states[b],
                    (f.options.states && f.options.states[b]) || {}
                  )),
                  (b = f.brightness),
                  (u =
                    f.color ||
                    (typeof b < "u" && E(u).brighten(f.brightness).get()) ||
                    u),
                  (v = f[o] || v),
                  (N = f[r] || N),
                  (C = f.dashStyle || C),
                  (w = T(f.opacity, w))),
                (o = { fill: u, stroke: v, "stroke-width": N, opacity: w }),
                C && (o.dashstyle = C),
                o
              );
            }
            drawPoints(f = this.points) {
              const b = this,
                y = this.chart,
                C = b.options,
                o = y.renderer,
                r = C.animationLimit || 250;
              let c;
              f.forEach(function (u) {
                let v = u.graphic,
                  N = !!v,
                  w = v && y.pointCount < r ? "animate" : "attr";
                p(u.plotY) && u.y !== null
                  ? ((c = u.shapeArgs),
                    v && u.hasNewShapeType() && (v = v.destroy()),
                    b.enabledDataSorting &&
                      (u.startXPos = b.xAxis.reversed
                        ? -((c && c.width) || 0)
                        : b.xAxis.width),
                    v ||
                      ((u.graphic = v =
                        o[u.shapeType](c).add(u.group || b.group)) &&
                        b.enabledDataSorting &&
                        y.hasRendered &&
                        y.pointCount < r &&
                        (v.attr({ x: u.startXPos }),
                        (N = !0),
                        (w = "animate"))),
                    v && N && v[w](g(c)),
                    y.styledMode ||
                      v[w](b.pointAttribs(u, u.selected && "select")).shadow(
                        u.allowShadow !== !1 && C.shadow
                      ),
                    v &&
                      (v.addClass(u.getClassName(), !0),
                      v.attr({ visibility: u.visible ? "inherit" : "hidden" })))
                  : v && (u.graphic = v.destroy());
              });
            }
            drawTracker(f = this.points) {
              const b = this,
                y = b.chart,
                C = y.pointer,
                o = function (c) {
                  const u = C.getPointFromEvent(c);
                  typeof u < "u" &&
                    b.options.enableMouseTracking &&
                    ((C.isDirectTouch = !0), u.onMouseOver(c));
                };
              let r;
              f.forEach(function (c) {
                (r = l(c.dataLabels)
                  ? c.dataLabels
                  : c.dataLabel
                  ? [c.dataLabel]
                  : []),
                  c.graphic && (c.graphic.element.point = c),
                  r.forEach(function (u) {
                    u.div ? (u.div.point = c) : (u.element.point = c);
                  });
              }),
                b._hasTracking ||
                  (b.trackerGroups.forEach(function (c) {
                    b[c] &&
                      (b[c]
                        .addClass("highcharts-tracker")
                        .on("mouseover", o)
                        .on("mouseout", function (u) {
                          C.onTrackerMouseOut(u);
                        }),
                      z && b[c].on("touchstart", o),
                      !y.styledMode &&
                        b.options.cursor &&
                        b[c].css({ cursor: b.options.cursor }));
                  }),
                  (b._hasTracking = !0)),
                s(this, "afterDrawTracker");
            }
            remove() {
              const f = this,
                b = f.chart;
              b.hasRendered &&
                b.series.forEach(function (y) {
                  y.type === f.type && (y.isDirty = !0);
                }),
                B.prototype.remove.apply(f, arguments);
            }
          }
          return (
            (A.defaultOptions = g(B.defaultOptions, M)),
            h(A.prototype, {
              cropShoulder: 0,
              directTouch: !0,
              getSymbol: S,
              negStacks: !0,
              trackerGroups: ["group", "dataLabelsGroup"],
            }),
            G.registerSeriesType("column", A),
            A
          );
        }
      ),
      n(
        i,
        "Core/Series/DataLabel.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Templating.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { getDeferredAnimation: O } = a,
            { format: B } = d,
            {
              defined: G,
              extend: Y,
              fireEvent: L,
              isArray: E,
              isString: z,
              merge: S,
              objectEach: x,
              pick: P,
              splat: h,
            } = M;
          var s;
          return (
            (function (l) {
              function p(C, o, r, c, u) {
                const v = this.chart;
                var N = this.isCartesian && v.inverted;
                const w = this.enabledDataSorting;
                var R = C.plotX,
                  X = C.plotY;
                const J = r.rotation;
                var K = r.align;
                X =
                  G(R) &&
                  G(X) &&
                  v.isInsidePlot(R, Math.round(X), {
                    inverted: N,
                    paneCoordinates: !0,
                    series: this,
                  });
                let H = P(r.overflow, w ? "none" : "justify") === "justify";
                if (
                  ((N =
                    this.visible &&
                    C.visible !== !1 &&
                    G(R) &&
                    (C.series.forceDL ||
                      (w && !H) ||
                      X ||
                      (P(r.inside, !!this.options.stacking) &&
                        c &&
                        v.isInsidePlot(R, N ? c.x + 1 : c.y + c.height - 1, {
                          inverted: N,
                          paneCoordinates: !0,
                          series: this,
                        })))),
                  (R = C.pos()),
                  N && R)
                ) {
                  J && o.attr({ align: K }), (K = o.getBBox(!0));
                  var k = [0, 0],
                    U = v.renderer.fontMetrics(o).b;
                  if (
                    ((c = Y(
                      { x: R[0], y: Math.round(R[1]), width: 0, height: 0 },
                      c
                    )),
                    Y(r, { width: K.width, height: K.height }),
                    J
                      ? ((H = !1),
                        (k = v.renderer.rotCorr(U, J)),
                        (U = {
                          x: c.x + (r.x || 0) + c.width / 2 + k.x,
                          y:
                            c.y +
                            (r.y || 0) +
                            { top: 0, middle: 0.5, bottom: 1 }[
                              r.verticalAlign
                            ] *
                              c.height,
                        }),
                        (k = [
                          K.x - Number(o.attr("x")),
                          K.y - Number(o.attr("y")),
                        ]),
                        w &&
                          this.xAxis &&
                          !H &&
                          this.setDataLabelStartPos(C, o, u, X, U),
                        o[u ? "attr" : "animate"](U))
                      : (w &&
                          this.xAxis &&
                          !H &&
                          this.setDataLabelStartPos(C, o, u, X, c),
                        o.align(r, void 0, c),
                        (U = o.alignAttr)),
                    H && 0 <= c.height)
                  )
                    this.justifyDataLabel(o, r, U, K, c, u);
                  else if (P(r.crop, !0)) {
                    let { x: _, y: W } = U;
                    (_ += k[0]),
                      (W += k[1]),
                      (N =
                        v.isInsidePlot(_, W, {
                          paneCoordinates: !0,
                          series: this,
                        }) &&
                        v.isInsidePlot(_ + K.width, W + K.height, {
                          paneCoordinates: !0,
                          series: this,
                        }));
                  }
                  r.shape &&
                    !J &&
                    o[u ? "attr" : "animate"]({ anchorX: R[0], anchorY: R[1] });
                }
                u && w && (o.placed = !1),
                  N || (w && !H) ? o.show() : (o.hide(), (o.placed = !1));
              }
              function g(C, o) {
                var r = o.filter;
                return r
                  ? ((o = r.operator),
                    (C = C[r.property]),
                    (r = r.value),
                    (o === ">" && C > r) ||
                      (o === "<" && C < r) ||
                      (o === ">=" && C >= r) ||
                      (o === "<=" && C <= r) ||
                      (o === "==" && C == r) ||
                      (o === "===" && C === r))
                  : !0;
              }
              function T() {
                return this.plotGroup(
                  "dataLabelsGroup",
                  "data-labels",
                  this.hasRendered ? "inherit" : "hidden",
                  this.options.dataLabels.zIndex || 6
                );
              }
              function D(C) {
                const o = this.hasRendered || 0,
                  r = this.initDataLabelsGroup().attr({ opacity: +o });
                return (
                  !o &&
                    r &&
                    (this.visible && r.show(),
                    this.options.animation
                      ? r.animate({ opacity: 1 }, C)
                      : r.attr({ opacity: 1 })),
                  r
                );
              }
              function A(C = this.points) {
                var o, r;
                const c = this,
                  u = c.chart,
                  v = c.options,
                  N = u.renderer,
                  { backgroundColor: w, plotBackgroundColor: R } =
                    u.options.chart,
                  X = u.options.plotOptions,
                  J = N.getContrast((z(R) && R) || (z(w) && w) || "#000000");
                let K = v.dataLabels,
                  H,
                  k;
                var U = h(K)[0];
                const _ = U.animation;
                (U = U.defer ? O(u, _, c) : { defer: 0, duration: 0 }),
                  (K = f(
                    f(
                      (o = X == null ? void 0 : X.series) === null ||
                        o === void 0
                        ? void 0
                        : o.dataLabels,
                      (r = X == null ? void 0 : X[c.type]) === null ||
                        r === void 0
                        ? void 0
                        : r.dataLabels
                    ),
                    K
                  )),
                  L(this, "drawDataLabels"),
                  (E(K) || K.enabled || c._hasPointLabels) &&
                    ((k = this.initDataLabels(U)),
                    C.forEach((W) => {
                      var tt;
                      const j = W.dataLabels || [];
                      for (
                        H = h(
                          f(
                            K,
                            W.dlOptions ||
                              ((tt = W.options) === null || tt === void 0
                                ? void 0
                                : tt.dataLabels)
                          )
                        ),
                          H.forEach((I, F) => {
                            var V,
                              Q =
                                I.enabled &&
                                (!W.isNull || W.dataLabelOnNull) &&
                                g(W, I);
                            const $ = W.connectors
                                ? W.connectors[F]
                                : W.connector,
                              et = I.style || {};
                            let st = {},
                              ot = j[F],
                              at = !ot;
                            const lt = P(I.distance, W.labelDistance);
                            if (Q) {
                              var Z = P(I[W.formatPrefix + "Format"], I.format),
                                q = W.getLabelConfig();
                              if (
                                ((q = G(Z)
                                  ? B(Z, q, u)
                                  : (
                                      I[W.formatPrefix + "Formatter"] ||
                                      I.formatter
                                    ).call(q, I)),
                                (Z = I.rotation),
                                u.styledMode ||
                                  ((et.color = P(
                                    I.color,
                                    et.color,
                                    z(c.color) ? c.color : void 0,
                                    "#000000"
                                  )),
                                  et.color === "contrast"
                                    ? ((W.contrastColor = N.getContrast(
                                        W.color || c.color
                                      )),
                                      (et.color =
                                        (!G(lt) && I.inside) ||
                                        0 > (lt || 0) ||
                                        v.stacking
                                          ? W.contrastColor
                                          : J))
                                    : delete W.contrastColor,
                                  v.cursor && (et.cursor = v.cursor)),
                                (st = {
                                  r: I.borderRadius || 0,
                                  rotation: Z,
                                  padding: I.padding,
                                  zIndex: 1,
                                }),
                                !u.styledMode)
                              ) {
                                const { backgroundColor: nt, borderColor: it } =
                                  I;
                                (st.fill = nt === "auto" ? W.color : nt),
                                  (st.stroke = it === "auto" ? W.color : it),
                                  (st["stroke-width"] = I.borderWidth);
                              }
                              x(st, (nt, it) => {
                                typeof nt > "u" && delete st[it];
                              });
                            }
                            !ot ||
                              (Q &&
                                G(q) &&
                                !!ot.div == !!I.useHTML &&
                                ((ot.rotation && I.rotation) ||
                                  ot.rotation === I.rotation)) ||
                              ((ot = void 0),
                              (at = !0),
                              $ &&
                                W.connector &&
                                ((W.connector = W.connector.destroy()),
                                W.connectors &&
                                  (W.connectors.length === 1
                                    ? delete W.connectors
                                    : delete W.connectors[F]))),
                              Q &&
                                G(q) &&
                                (ot
                                  ? (st.text = q)
                                  : (ot = Z
                                      ? N.text(q, 0, 0, I.useHTML).addClass(
                                          "highcharts-data-label"
                                        )
                                      : N.label(
                                          q,
                                          0,
                                          0,
                                          I.shape,
                                          void 0,
                                          void 0,
                                          I.useHTML,
                                          void 0,
                                          "data-label"
                                        )) &&
                                    ot.addClass(
                                      " highcharts-data-label-color-" +
                                        W.colorIndex +
                                        " " +
                                        (I.className || "") +
                                        (I.useHTML ? " highcharts-tracker" : "")
                                    ),
                                ot &&
                                  ((ot.options = I),
                                  ot.attr(st),
                                  u.styledMode || ot.css(et).shadow(I.shadow),
                                  (Q =
                                    I[W.formatPrefix + "TextPath"] ||
                                    I.textPath) &&
                                    !I.useHTML &&
                                    (ot.setTextPath(
                                      ((V = W.getDataLabelPath) === null ||
                                      V === void 0
                                        ? void 0
                                        : V.call(W, ot)) || W.graphic,
                                      Q
                                    ),
                                    W.dataLabelPath &&
                                      !Q.enabled &&
                                      (W.dataLabelPath =
                                        W.dataLabelPath.destroy())),
                                  ot.added || ot.add(k),
                                  c.alignDataLabel(W, ot, I, void 0, at),
                                  (ot.isActive = !0),
                                  j[F] && j[F] !== ot && j[F].destroy(),
                                  (j[F] = ot)));
                          }),
                          tt = j.length;
                        tt--;

                      )
                        j[tt].isActive
                          ? (j[tt].isActive = !1)
                          : (j[tt].destroy(), j.splice(tt, 1));
                      (W.dataLabel = j[0]), (W.dataLabels = j);
                    })),
                  L(this, "afterDrawDataLabels");
              }
              function m(C, o, r, c, u, v) {
                const N = this.chart,
                  w = o.align,
                  R = o.verticalAlign,
                  X = C.box ? 0 : C.padding || 0;
                let { x: J = 0, y: K = 0 } = o,
                  H,
                  k;
                return (
                  (H = (r.x || 0) + X),
                  0 > H &&
                    (w === "right" && 0 <= J
                      ? ((o.align = "left"), (o.inside = !0))
                      : (J -= H),
                    (k = !0)),
                  (H = (r.x || 0) + c.width - X),
                  H > N.plotWidth &&
                    (w === "left" && 0 >= J
                      ? ((o.align = "right"), (o.inside = !0))
                      : (J += N.plotWidth - H),
                    (k = !0)),
                  (H = r.y + X),
                  0 > H &&
                    (R === "bottom" && 0 <= K
                      ? ((o.verticalAlign = "top"), (o.inside = !0))
                      : (K -= H),
                    (k = !0)),
                  (H = (r.y || 0) + c.height - X),
                  H > N.plotHeight &&
                    (R === "top" && 0 >= K
                      ? ((o.verticalAlign = "bottom"), (o.inside = !0))
                      : (K += N.plotHeight - H),
                    (k = !0)),
                  k &&
                    ((o.x = J),
                    (o.y = K),
                    (C.placed = !v),
                    C.align(o, void 0, u)),
                  k
                );
              }
              function f(C, o) {
                let r = [],
                  c;
                if (E(C) && !E(o))
                  r = C.map(function (u) {
                    return S(u, o);
                  });
                else if (E(o) && !E(C))
                  r = o.map(function (u) {
                    return S(C, u);
                  });
                else if (!E(C) && !E(o)) r = S(C, o);
                else if (E(C) && E(o))
                  for (c = Math.max(C.length, o.length); c--; )
                    r[c] = S(C[c], o[c]);
                return r;
              }
              function b(C, o, r, c, u) {
                const v = this.chart,
                  N = v.inverted,
                  w = this.xAxis,
                  R = w.reversed,
                  X = N ? o.height / 2 : o.width / 2;
                (C = (C = C.pointWidth) ? C / 2 : 0),
                  (o.startXPos = N ? u.x : R ? -X - C : w.width - X + C),
                  (o.startYPos = N
                    ? R
                      ? this.yAxis.height - X + C
                      : -X - C
                    : u.y),
                  c
                    ? o.visibility === "hidden" &&
                      (o.show(), o.attr({ opacity: 0 }).animate({ opacity: 1 }))
                    : o
                        .attr({ opacity: 1 })
                        .animate({ opacity: 0 }, void 0, o.hide),
                  v.hasRendered &&
                    (r && o.attr({ x: o.startXPos, y: o.startYPos }),
                    (o.placed = !0));
              }
              const y = [];
              l.compose = function (C) {
                M.pushUnique(y, C) &&
                  ((C = C.prototype),
                  (C.initDataLabelsGroup = T),
                  (C.initDataLabels = D),
                  (C.alignDataLabel = p),
                  (C.drawDataLabels = A),
                  (C.justifyDataLabel = m),
                  (C.setDataLabelStartPos = b));
              };
            })(s || (s = {})),
            s
          );
        }
      ),
      n(
        i,
        "Series/Column/ColumnDataLabel.js",
        [
          i["Core/Series/DataLabel.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { series: O } = d,
            { merge: B, pick: G } = M;
          var Y;
          return (
            (function (L) {
              function E(S, x, P, h, s) {
                let l = this.chart.inverted;
                var p = S.series;
                let g = (p.xAxis ? p.xAxis.len : this.chart.plotSizeX) || 0;
                p = (p.yAxis ? p.yAxis.len : this.chart.plotSizeY) || 0;
                var T = S.dlBox || S.shapeArgs;
                let D = G(S.below, S.plotY > G(this.translatedThreshold, p)),
                  A = G(P.inside, !!this.options.stacking);
                T &&
                  ((h = B(T)),
                  0 > h.y && ((h.height += h.y), (h.y = 0)),
                  (T = h.y + h.height - p),
                  0 < T && T < h.height && (h.height -= T),
                  l &&
                    (h = {
                      x: p - h.y - h.height,
                      y: g - h.x - h.width,
                      width: h.height,
                      height: h.width,
                    }),
                  A ||
                    (l
                      ? ((h.x += D ? 0 : h.width), (h.width = 0))
                      : ((h.y += D ? h.height : 0), (h.height = 0)))),
                  (P.align = G(
                    P.align,
                    !l || A ? "center" : D ? "right" : "left"
                  )),
                  (P.verticalAlign = G(
                    P.verticalAlign,
                    l || A ? "middle" : D ? "top" : "bottom"
                  )),
                  O.prototype.alignDataLabel.call(this, S, x, P, h, s),
                  P.inside &&
                    S.contrastColor &&
                    x.css({ color: S.contrastColor });
              }
              const z = [];
              L.compose = function (S) {
                a.compose(O),
                  M.pushUnique(z, S) && (S.prototype.alignDataLabel = E);
              };
            })(Y || (Y = {})),
            Y
          );
        }
      ),
      n(
        i,
        "Series/Bar/BarSeries.js",
        [
          i["Series/Column/ColumnSeries.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { extend: O, merge: B } = M;
          class G extends a {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
          }
          return (
            (G.defaultOptions = B(a.defaultOptions, {})),
            O(G.prototype, { inverted: !0 }),
            d.registerSeriesType("bar", G),
            G
          );
        }
      ),
      n(i, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {
        return {
          lineWidth: 0,
          findNearestPointBy: "xy",
          jitter: { x: 0, y: 0 },
          marker: { enabled: !0 },
          tooltip: {
            headerFormat:
              '<span style="color:{point.color}"></span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
          },
        };
      }),
      n(
        i,
        "Series/Scatter/ScatterSeries.js",
        [
          i["Series/Scatter/ScatterSeriesDefaults.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { column: O, line: B } = d.seriesTypes,
            { addEvent: G, extend: Y, merge: L } = M;
          class E extends B {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            applyJitter() {
              const S = this,
                x = this.options.jitter,
                P = this.points.length;
              x &&
                this.points.forEach(function (h, s) {
                  ["x", "y"].forEach(function (l, p) {
                    let g = "plot" + l.toUpperCase(),
                      T,
                      D;
                    if (x[l] && !h.isNull) {
                      var A = S[l + "Axis"];
                      (D = x[l] * A.transA),
                        A &&
                          !A.isLog &&
                          ((T = Math.max(0, h[g] - D)),
                          (A = Math.min(A.len, h[g] + D)),
                          (p = 1e4 * Math.sin(s + p * P)),
                          (p -= Math.floor(p)),
                          (h[g] = T + (A - T) * p),
                          l === "x" && (h.clientX = h.plotX));
                    }
                  });
                });
            }
            drawGraph() {
              this.options.lineWidth
                ? super.drawGraph()
                : this.graph && (this.graph = this.graph.destroy());
            }
          }
          return (
            (E.defaultOptions = L(B.defaultOptions, a)),
            Y(E.prototype, {
              drawTracker: O.prototype.drawTracker,
              sorted: !1,
              requireSorting: !1,
              noSharedTooltip: !0,
              trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
              takeOrdinalPosition: !1,
            }),
            G(E, "afterTranslate", function () {
              this.applyJitter();
            }),
            d.registerSeriesType("scatter", E),
            E
          );
        }
      ),
      n(
        i,
        "Series/CenteredUtilities.js",
        [
          i["Core/Globals.js"],
          i["Core/Series/Series.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { deg2rad: O } = a,
            { fireEvent: B, isNumber: G, pick: Y, relativeLength: L } = M;
          var E;
          return (
            (function (z) {
              (z.getCenter = function () {
                var S = this.options,
                  x = this.chart;
                const P = 2 * (S.slicedOffset || 0),
                  h = x.plotWidth - 2 * P,
                  s = x.plotHeight - 2 * P;
                var l = S.center;
                const p = Math.min(h, s),
                  g = S.thickness;
                var T = S.size;
                let D = S.innerSize || 0;
                for (
                  typeof T == "string" && (T = parseFloat(T)),
                    typeof D == "string" && (D = parseFloat(D)),
                    S = [
                      Y(l[0], "50%"),
                      Y(l[1], "50%"),
                      Y(T && 0 > T ? void 0 : S.size, "100%"),
                      Y(D && 0 > D ? void 0 : S.innerSize || 0, "0%"),
                    ],
                    !x.angular || this instanceof d || (S[3] = 0),
                    l = 0;
                  4 > l;
                  ++l
                )
                  (T = S[l]),
                    (x = 2 > l || (l === 2 && /%$/.test(T))),
                    (S[l] = L(T, [h, s, p, S[2]][l]) + (x ? P : 0));
                return (
                  S[3] > S[2] && (S[3] = S[2]),
                  G(g) && 2 * g < S[2] && 0 < g && (S[3] = S[2] - 2 * g),
                  B(this, "afterGetCenter", { positions: S }),
                  S
                );
              }),
                (z.getStartAndEndRadians = function (S, x) {
                  return (
                    (S = G(S) ? S : 0),
                    (x = G(x) && x > S && 360 > x - S ? x : S + 360),
                    { start: O * (S + -90), end: O * (x + -90) }
                  );
                });
            })(E || (E = {})),
            E
          );
        }
      ),
      n(
        i,
        "Series/Pie/PiePoint.js",
        [
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Series/Point.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M) {
          const { setAnimation: O } = a,
            {
              addEvent: B,
              defined: G,
              extend: Y,
              isNumber: L,
              pick: E,
              relativeLength: z,
            } = M;
          class S extends d {
            constructor() {
              super(...arguments),
                (this.series = this.options = this.labelDistance = void 0);
            }
            getConnectorPath() {
              const P = this.labelPosition,
                h = this.series.options.dataLabels,
                s = this.connectorShapes;
              let l = h.connectorShape;
              return (
                s[l] && (l = s[l]),
                l.call(
                  this,
                  { x: P.computed.x, y: P.computed.y, alignment: P.alignment },
                  P.connectorPosition,
                  h
                )
              );
            }
            getTranslate() {
              return this.sliced
                ? this.slicedTranslation
                : { translateX: 0, translateY: 0 };
            }
            haloPath(P) {
              const h = this.shapeArgs;
              return this.sliced || !this.visible
                ? []
                : this.series.chart.renderer.symbols.arc(
                    h.x,
                    h.y,
                    h.r + P,
                    h.r + P,
                    {
                      innerR: h.r - 1,
                      start: h.start,
                      end: h.end,
                      borderRadius: h.borderRadius,
                    }
                  );
            }
            init() {
              super.init.apply(this, arguments),
                (this.name = E(this.name, "Slice"));
              const P = (h) => {
                this.slice(h.type === "select");
              };
              return B(this, "select", P), B(this, "unselect", P), this;
            }
            isValid() {
              return L(this.y) && 0 <= this.y;
            }
            setVisible(P, h) {
              const s = this.series,
                l = s.chart,
                p = s.options.ignoreHiddenPoint;
              (h = E(h, p)),
                P !== this.visible &&
                  ((this.visible =
                    this.options.visible =
                    P =
                      typeof P > "u" ? !this.visible : P),
                  (s.options.data[s.data.indexOf(this)] = this.options),
                  ["graphic", "dataLabel", "connector"].forEach((g) => {
                    this[g] && this[g][P ? "show" : "hide"](P);
                  }),
                  this.legendItem && l.legend.colorizeItem(this, P),
                  P || this.state !== "hover" || this.setState(""),
                  p && (s.isDirty = !0),
                  h && l.redraw());
            }
            slice(P, h, s) {
              const l = this.series;
              O(s, l.chart),
                E(h, !0),
                (this.sliced = this.options.sliced = G(P) ? P : !this.sliced),
                (l.options.data[l.data.indexOf(this)] = this.options),
                this.graphic && this.graphic.animate(this.getTranslate());
            }
          }
          return (
            Y(S.prototype, {
              connectorShapes: {
                fixedOffset: function (x, P, h) {
                  const s = P.breakAt;
                  return (
                    (P = P.touchingSliceAt),
                    [
                      ["M", x.x, x.y],
                      h.softConnector
                        ? [
                            "C",
                            x.x + (x.alignment === "left" ? -5 : 5),
                            x.y,
                            2 * s.x - P.x,
                            2 * s.y - P.y,
                            s.x,
                            s.y,
                          ]
                        : ["L", s.x, s.y],
                      ["L", P.x, P.y],
                    ]
                  );
                },
                straight: function (x, P) {
                  return (
                    (P = P.touchingSliceAt),
                    [
                      ["M", x.x, x.y],
                      ["L", P.x, P.y],
                    ]
                  );
                },
                crookedLine: function (x, P, h) {
                  const { breakAt: s, touchingSliceAt: l } = P;
                  ({ series: P } = this);
                  const [p, g, T] = P.center,
                    D = T / 2,
                    A = P.chart.plotWidth,
                    m = P.chart.plotLeft;
                  P = x.alignment === "left";
                  const { x: f, y: b } = x;
                  return (
                    h.crookDistance
                      ? ((x = z(h.crookDistance, 1)),
                        (x = P
                          ? p + D + (A + m - p - D) * (1 - x)
                          : m + (p - D) * x))
                      : (x =
                          p +
                          (g - b) * Math.tan((this.angle || 0) - Math.PI / 2)),
                    (h = [["M", f, b]]),
                    (P ? x <= f && x >= s.x : x >= f && x <= s.x) &&
                      h.push(["L", x, b]),
                    h.push(["L", s.x, s.y], ["L", l.x, l.y]),
                    h
                  );
                },
              },
            }),
            S
          );
        }
      ),
      n(i, "Series/Pie/PieSeriesDefaults.js", [], function () {
        return {
          borderRadius: 3,
          center: [null, null],
          clip: !1,
          colorByPoint: !0,
          dataLabels: {
            allowOverlap: !0,
            connectorPadding: 5,
            connectorShape: "crookedLine",
            crookDistance: void 0,
            distance: 30,
            enabled: !0,
            formatter: function () {
              return this.point.isNull ? void 0 : this.point.name;
            },
            softConnector: !0,
            x: 0,
          },
          fillColor: void 0,
          ignoreHiddenPoint: !0,
          inactiveOtherPoints: !0,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: !1,
          slicedOffset: 10,
          stickyTracking: !1,
          tooltip: { followPointer: !0 },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } },
        };
      }),
      n(
        i,
        "Series/Pie/PieSeries.js",
        [
          i["Series/CenteredUtilities.js"],
          i["Series/Column/ColumnSeries.js"],
          i["Core/Globals.js"],
          i["Series/Pie/PiePoint.js"],
          i["Series/Pie/PieSeriesDefaults.js"],
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Renderer/SVG/Symbols.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G, Y, L, E) {
          const { getStartAndEndRadians: z } = a;
          ({ noop: M } = M);
          const {
            clamp: S,
            extend: x,
            fireEvent: P,
            merge: h,
            pick: s,
            relativeLength: l,
          } = E;
          class p extends G {
            constructor() {
              super(...arguments),
                (this.points =
                  this.options =
                  this.maxLabelDistance =
                  this.data =
                  this.center =
                    void 0);
            }
            animate(T) {
              const D = this,
                A = D.points,
                m = D.startAngleRad;
              T ||
                A.forEach(function (f) {
                  const b = f.graphic,
                    y = f.shapeArgs;
                  b &&
                    y &&
                    (b.attr({
                      r: s(f.startR, D.center && D.center[3] / 2),
                      start: m,
                      end: m,
                    }),
                    b.animate(
                      { r: y.r, start: y.start, end: y.end },
                      D.options.animation
                    ));
                });
            }
            drawEmpty() {
              const T = this.startAngleRad,
                D = this.endAngleRad,
                A = this.options;
              let m, f;
              this.total === 0 && this.center
                ? ((m = this.center[0]),
                  (f = this.center[1]),
                  this.graph ||
                    (this.graph = this.chart.renderer
                      .arc(m, f, this.center[1] / 2, 0, T, D)
                      .addClass("highcharts-empty-series")
                      .add(this.group)),
                  this.graph.attr({
                    d: L.arc(m, f, this.center[2] / 2, 0, {
                      start: T,
                      end: D,
                      innerR: this.center[3] / 2,
                    }),
                  }),
                  this.chart.styledMode ||
                    this.graph.attr({
                      "stroke-width": A.borderWidth,
                      fill: A.fillColor || "none",
                      stroke: A.color || "#cccccc",
                    }))
                : this.graph && (this.graph = this.graph.destroy());
            }
            drawPoints() {
              const T = this.chart.renderer;
              this.points.forEach(function (D) {
                D.graphic &&
                  D.hasNewShapeType() &&
                  (D.graphic = D.graphic.destroy()),
                  D.graphic ||
                    ((D.graphic = T[D.shapeType](D.shapeArgs).add(
                      D.series.group
                    )),
                    (D.delayedRendering = !0));
              });
            }
            generatePoints() {
              super.generatePoints(), this.updateTotals();
            }
            getX(T, D, A) {
              const m = this.center,
                f = this.radii ? this.radii[A.index] || 0 : m[2] / 2;
              return (
                (T = Math.asin(S((T - m[1]) / (f + A.labelDistance), -1, 1))),
                m[0] +
                  (D ? -1 : 1) * Math.cos(T) * (f + A.labelDistance) +
                  (0 < A.labelDistance
                    ? (D ? -1 : 1) * this.options.dataLabels.padding
                    : 0)
              );
            }
            hasData() {
              return !!this.processedXData.length;
            }
            redrawPoints() {
              const T = this,
                D = T.chart;
              let A, m, f, b;
              this.drawEmpty(),
                T.group && !D.styledMode && T.group.shadow(T.options.shadow),
                T.points.forEach(function (y) {
                  const C = {};
                  (m = y.graphic),
                    !y.isNull && m
                      ? ((b = y.shapeArgs),
                        (A = y.getTranslate()),
                        D.styledMode ||
                          (f = T.pointAttribs(y, y.selected && "select")),
                        y.delayedRendering
                          ? (m.setRadialReference(T.center).attr(b).attr(A),
                            D.styledMode ||
                              m.attr(f).attr({ "stroke-linejoin": "round" }),
                            (y.delayedRendering = !1))
                          : (m.setRadialReference(T.center),
                            D.styledMode || h(!0, C, f),
                            h(!0, C, b, A),
                            m.animate(C)),
                        m.attr({
                          visibility: y.visible ? "inherit" : "hidden",
                        }),
                        m.addClass(y.getClassName(), !0))
                      : m && (y.graphic = m.destroy());
                });
            }
            sortByAngle(T, D) {
              T.sort(function (A, m) {
                return typeof A.angle < "u" && (m.angle - A.angle) * D;
              });
            }
            translate(T) {
              P(this, "translate"), this.generatePoints();
              var D = this.options;
              const A = D.slicedOffset,
                m = A + (D.borderWidth || 0);
              var f = z(D.startAngle, D.endAngle);
              const b = (this.startAngleRad = f.start);
              f = (this.endAngleRad = f.end) - b;
              const y = this.points,
                C = D.dataLabels.distance;
              D = D.ignoreHiddenPoint;
              const o = y.length;
              let r,
                c,
                u,
                v = 0;
              for (
                T || (this.center = T = this.getCenter()), c = 0;
                c < o;
                c++
              ) {
                u = y[c];
                var N = b + v * f;
                !u.isValid() || (D && !u.visible) || (v += u.percentage / 100);
                var w = b + v * f,
                  R = {
                    x: T[0],
                    y: T[1],
                    r: T[2] / 2,
                    innerR: T[3] / 2,
                    start: Math.round(1e3 * N) / 1e3,
                    end: Math.round(1e3 * w) / 1e3,
                  };
                (u.shapeType = "arc"),
                  (u.shapeArgs = R),
                  (u.labelDistance = s(
                    u.options.dataLabels && u.options.dataLabels.distance,
                    C
                  )),
                  (u.labelDistance = l(u.labelDistance, R.r)),
                  (this.maxLabelDistance = Math.max(
                    this.maxLabelDistance || 0,
                    u.labelDistance
                  )),
                  (w = (w + N) / 2),
                  w > 1.5 * Math.PI
                    ? (w -= 2 * Math.PI)
                    : w < -Math.PI / 2 && (w += 2 * Math.PI),
                  (u.slicedTranslation = {
                    translateX: Math.round(Math.cos(w) * A),
                    translateY: Math.round(Math.sin(w) * A),
                  }),
                  (R = (Math.cos(w) * T[2]) / 2),
                  (r = (Math.sin(w) * T[2]) / 2),
                  (u.tooltipPos = [T[0] + 0.7 * R, T[1] + 0.7 * r]),
                  (u.half = w < -Math.PI / 2 || w > Math.PI / 2 ? 1 : 0),
                  (u.angle = w),
                  (N = Math.min(m, u.labelDistance / 5)),
                  (u.labelPosition = {
                    natural: {
                      x: T[0] + R + Math.cos(w) * u.labelDistance,
                      y: T[1] + r + Math.sin(w) * u.labelDistance,
                    },
                    computed: {},
                    alignment:
                      0 > u.labelDistance
                        ? "center"
                        : u.half
                        ? "right"
                        : "left",
                    connectorPosition: {
                      breakAt: {
                        x: T[0] + R + Math.cos(w) * N,
                        y: T[1] + r + Math.sin(w) * N,
                      },
                      touchingSliceAt: { x: T[0] + R, y: T[1] + r },
                    },
                  });
              }
              P(this, "afterTranslate");
            }
            updateTotals() {
              const T = this.points,
                D = T.length,
                A = this.options.ignoreHiddenPoint;
              let m,
                f,
                b = 0;
              for (m = 0; m < D; m++)
                (f = T[m]), !f.isValid() || (A && !f.visible) || (b += f.y);
              for (this.total = b, m = 0; m < D; m++)
                (f = T[m]),
                  (f.percentage =
                    0 < b && (f.visible || !A) ? (f.y / b) * 100 : 0),
                  (f.total = b);
            }
          }
          return (
            (p.defaultOptions = h(G.defaultOptions, B)),
            x(p.prototype, {
              axisTypes: [],
              directTouch: !0,
              drawGraph: void 0,
              drawTracker: d.prototype.drawTracker,
              getCenter: a.getCenter,
              getSymbol: M,
              isCartesian: !1,
              noSharedTooltip: !0,
              pointAttribs: d.prototype.pointAttribs,
              pointClass: O,
              requireSorting: !1,
              searchPoint: M,
              trackerGroups: ["group", "dataLabelsGroup"],
            }),
            Y.registerSeriesType("pie", p),
            p
          );
        }
      ),
      n(
        i,
        "Series/Pie/PieDataLabel.js",
        [
          i["Core/Series/DataLabel.js"],
          i["Core/Globals.js"],
          i["Core/Renderer/RendererUtilities.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B) {
          const { noop: G } = d,
            { distribute: Y } = M,
            { series: L } = O,
            {
              arrayMax: E,
              clamp: z,
              defined: S,
              merge: x,
              pick: P,
              relativeLength: h,
            } = B;
          var s;
          return (
            (function (l) {
              function p() {
                const m = this,
                  f = m.data,
                  b = m.chart,
                  y = m.options.dataLabels || {},
                  C = y.connectorPadding,
                  o = b.plotWidth,
                  r = b.plotHeight,
                  c = b.plotLeft,
                  u = Math.round(b.chartWidth / 3),
                  v = m.center,
                  N = v[2] / 2,
                  w = v[1],
                  R = [[], []],
                  X = [0, 0, 0, 0],
                  J = m.dataLabelPositioners;
                let K, H, k, U, _, W, tt, j, I, F, V, Q;
                m.visible &&
                  (y.enabled || m._hasPointLabels) &&
                  (f.forEach(function ($) {
                    $.dataLabel &&
                      $.visible &&
                      $.dataLabel.shortened &&
                      ($.dataLabel
                        .attr({ width: "auto" })
                        .css({ width: "auto", textOverflow: "clip" }),
                      ($.dataLabel.shortened = !1));
                  }),
                  L.prototype.drawDataLabels.apply(m),
                  f.forEach(function ($) {
                    $.dataLabel &&
                      ($.visible
                        ? (R[$.half].push($),
                          ($.dataLabel._pos = null),
                          !S(y.style.width) &&
                            !S(
                              $.options.dataLabels &&
                                $.options.dataLabels.style &&
                                $.options.dataLabels.style.width
                            ) &&
                            $.dataLabel.getBBox().width > u &&
                            ($.dataLabel.css({
                              width: Math.round(0.7 * u) + "px",
                            }),
                            ($.dataLabel.shortened = !0)))
                        : (($.dataLabel = $.dataLabel.destroy()),
                          $.dataLabels &&
                            $.dataLabels.length === 1 &&
                            delete $.dataLabels));
                  }),
                  R.forEach(($, et) => {
                    const st = $.length,
                      ot = [];
                    let at,
                      lt = 0;
                    if (st) {
                      if (
                        (m.sortByAngle($, et - 0.5), 0 < m.maxLabelDistance)
                      ) {
                        var Z = Math.max(0, w - N - m.maxLabelDistance);
                        (at = Math.min(
                          w + N + m.maxLabelDistance,
                          b.plotHeight
                        )),
                          $.forEach(function (q) {
                            0 < q.labelDistance &&
                              q.dataLabel &&
                              ((q.top = Math.max(0, w - N - q.labelDistance)),
                              (q.bottom = Math.min(
                                w + N + q.labelDistance,
                                b.plotHeight
                              )),
                              (lt = q.dataLabel.getBBox().height || 21),
                              (q.distributeBox = {
                                target:
                                  q.labelPosition.natural.y - q.top + lt / 2,
                                size: lt,
                                rank: q.y,
                              }),
                              ot.push(q.distributeBox));
                          }),
                          (Z = at + lt - Z),
                          Y(ot, Z, Z / 5);
                      }
                      for (V = 0; V < st; V++) {
                        if (
                          ((K = $[V]),
                          (W = K.labelPosition),
                          (U = K.dataLabel),
                          (F = K.visible === !1 ? "hidden" : "inherit"),
                          (I = Z = W.natural.y),
                          ot &&
                            S(K.distributeBox) &&
                            (typeof K.distributeBox.pos > "u"
                              ? (F = "hidden")
                              : ((tt = K.distributeBox.size),
                                (I = J.radialDistributionY(K)))),
                          delete K.positionIndex,
                          y.justify)
                        )
                          j = J.justify(K, N, v);
                        else
                          switch (y.alignTo) {
                            case "connectors":
                              j = J.alignToConnectors($, et, o, c);
                              break;
                            case "plotEdges":
                              j = J.alignToPlotEdges(U, et, o, c);
                              break;
                            default:
                              j = J.radialDistributionX(m, K, I, Z);
                          }
                        (U._attr = { visibility: F, align: W.alignment }),
                          (Q = K.options.dataLabels || {}),
                          (U._pos = {
                            x:
                              j +
                              P(Q.x, y.x) +
                              ({ left: C, right: -C }[W.alignment] || 0),
                            y: I + P(Q.y, y.y) - U.getBBox().height / 2,
                          }),
                          W && ((W.computed.x = j), (W.computed.y = I)),
                          P(y.crop, !0) &&
                            ((_ = U.getBBox().width),
                            (Z = null),
                            j - _ < C && et === 1
                              ? ((Z = Math.round(_ - j + C)),
                                (X[3] = Math.max(Z, X[3])))
                              : j + _ > o - C &&
                                et === 0 &&
                                ((Z = Math.round(j + _ - o + C)),
                                (X[1] = Math.max(Z, X[1]))),
                            0 > I - tt / 2
                              ? (X[0] = Math.max(Math.round(-I + tt / 2), X[0]))
                              : I + tt / 2 > r &&
                                (X[2] = Math.max(
                                  Math.round(I + tt / 2 - r),
                                  X[2]
                                )),
                            (U.sideOverflow = Z));
                      }
                    }
                  }),
                  E(X) === 0 || this.verifyDataLabelOverflow(X)) &&
                  (this.placeDataLabels(),
                  this.points.forEach(function ($) {
                    if (
                      ((Q = x(y, $.options.dataLabels)),
                      (H = P(Q.connectorWidth, 1)))
                    ) {
                      let et;
                      (k = $.connector),
                        (U = $.dataLabel) &&
                        U._pos &&
                        $.visible &&
                        0 < $.labelDistance
                          ? ((F = U._attr.visibility),
                            (et = !k) &&
                              (($.connector = k =
                                b.renderer
                                  .path()
                                  .addClass(
                                    "highcharts-data-label-connector  highcharts-color-" +
                                      $.colorIndex +
                                      ($.className ? " " + $.className : "")
                                  )
                                  .add(m.dataLabelsGroup)),
                              b.styledMode ||
                                k.attr({
                                  "stroke-width": H,
                                  stroke:
                                    Q.connectorColor || $.color || "#666666",
                                })),
                            k[et ? "attr" : "animate"]({
                              d: $.getConnectorPath(),
                            }),
                            k.attr("visibility", F))
                          : k && ($.connector = k.destroy());
                    }
                  }));
              }
              function g() {
                this.points.forEach(function (m) {
                  let f = m.dataLabel,
                    b;
                  f &&
                    m.visible &&
                    ((b = f._pos)
                      ? (f.sideOverflow &&
                          ((f._attr.width = Math.max(
                            f.getBBox().width - f.sideOverflow,
                            0
                          )),
                          f.css({
                            width: f._attr.width + "px",
                            textOverflow:
                              (this.options.dataLabels.style || {})
                                .textOverflow || "ellipsis",
                          }),
                          (f.shortened = !0)),
                        f.attr(f._attr),
                        f[f.moved ? "animate" : "attr"](b),
                        (f.moved = !0))
                      : f && f.attr({ y: -9999 })),
                    delete m.distributeBox;
                }, this);
              }
              function T(m) {
                let f = this.center,
                  b = this.options,
                  y = b.center,
                  C = b.minSize || 80,
                  o,
                  r = b.size !== null;
                return (
                  r ||
                    (y[0] !== null
                      ? (o = Math.max(f[2] - Math.max(m[1], m[3]), C))
                      : ((o = Math.max(f[2] - m[1] - m[3], C)),
                        (f[0] += (m[3] - m[1]) / 2)),
                    y[1] !== null
                      ? (o = z(o, C, f[2] - Math.max(m[0], m[2])))
                      : ((o = z(o, C, f[2] - m[0] - m[2])),
                        (f[1] += (m[0] - m[2]) / 2)),
                    o < f[2]
                      ? ((f[2] = o),
                        (f[3] = Math.min(
                          b.thickness
                            ? Math.max(0, o - 2 * b.thickness)
                            : Math.max(0, h(b.innerSize || 0, o)),
                          o
                        )),
                        this.translate(f),
                        this.drawDataLabels && this.drawDataLabels())
                      : (r = !0)),
                  r
                );
              }
              const D = [],
                A = {
                  radialDistributionY: function (m) {
                    return m.top + m.distributeBox.pos;
                  },
                  radialDistributionX: function (m, f, b, y) {
                    return m.getX(
                      b < f.top + 2 || b > f.bottom - 2 ? y : b,
                      f.half,
                      f
                    );
                  },
                  justify: function (m, f, b) {
                    return b[0] + (m.half ? -1 : 1) * (f + m.labelDistance);
                  },
                  alignToPlotEdges: function (m, f, b, y) {
                    return (m = m.getBBox().width), f ? m + y : b - m - y;
                  },
                  alignToConnectors: function (m, f, b, y) {
                    let C = 0,
                      o;
                    return (
                      m.forEach(function (r) {
                        (o = r.dataLabel.getBBox().width), o > C && (C = o);
                      }),
                      f ? C + y : b - C - y
                    );
                  },
                };
              l.compose = function (m) {
                a.compose(L),
                  B.pushUnique(D, m) &&
                    ((m = m.prototype),
                    (m.dataLabelPositioners = A),
                    (m.alignDataLabel = G),
                    (m.drawDataLabels = p),
                    (m.placeDataLabels = g),
                    (m.verifyDataLabelOverflow = T));
              };
            })(s || (s = {})),
            s
          );
        }
      ),
      n(
        i,
        "Extensions/OverlappingDataLabels.js",
        [i["Core/Chart/Chart.js"], i["Core/Utilities.js"]],
        function (a, d) {
          function M(z, S) {
            let x,
              P = !1;
            return (
              z &&
                ((x = z.newOpacity),
                z.oldOpacity !== x &&
                  (z.alignAttr && z.placed
                    ? (z[x ? "removeClass" : "addClass"](
                        "highcharts-data-label-hidden"
                      ),
                      (P = !0),
                      (z.alignAttr.opacity = x),
                      z[z.isOld ? "animate" : "attr"](
                        z.alignAttr,
                        null,
                        function () {
                          S.styledMode ||
                            z.css({ pointerEvents: x ? "auto" : "none" });
                        }
                      ),
                      B(S, "afterHideOverlappingLabel"))
                    : z.attr({ opacity: x })),
                (z.isOld = !0)),
              P
            );
          }
          const {
            addEvent: O,
            fireEvent: B,
            isArray: G,
            isNumber: Y,
            objectEach: L,
            pick: E,
          } = d;
          O(a, "render", function () {
            let z = this,
              S = [];
            (this.labelCollectors || []).forEach(function (x) {
              S = S.concat(x());
            }),
              (this.yAxis || []).forEach(function (x) {
                x.stacking &&
                  x.options.stackLabels &&
                  !x.options.stackLabels.allowOverlap &&
                  L(x.stacking.stacks, function (P) {
                    L(P, function (h) {
                      h.label && S.push(h.label);
                    });
                  });
              }),
              (this.series || []).forEach(function (x) {
                var P = x.options.dataLabels;
                x.visible &&
                  (P.enabled !== !1 || x._hasPointLabels) &&
                  ((P = (h) =>
                    h.forEach((s) => {
                      s.visible &&
                        (G(s.dataLabels)
                          ? s.dataLabels
                          : s.dataLabel
                          ? [s.dataLabel]
                          : []
                        ).forEach(function (l) {
                          const p = l.options;
                          (l.labelrank = E(
                            p.labelrank,
                            s.labelrank,
                            s.shapeArgs && s.shapeArgs.height
                          )),
                            p.allowOverlap
                              ? ((l.oldOpacity = l.opacity),
                                (l.newOpacity = 1),
                                M(l, z))
                              : S.push(l);
                        });
                    })),
                  P(x.nodes || []),
                  P(x.points));
              }),
              this.hideOverlappingLabels(S);
          }),
            (a.prototype.hideOverlappingLabels = function (z) {
              let S = this,
                x = z.length,
                P = S.renderer;
              var h;
              let s,
                l,
                p,
                g,
                T = !1;
              var D = function (A) {
                let m, f;
                var b;
                let y = A.box ? 0 : A.padding || 0,
                  C = (b = 0),
                  o,
                  r;
                if (A && (!A.alignAttr || A.placed))
                  return (
                    (m = A.alignAttr || { x: A.attr("x"), y: A.attr("y") }),
                    (f = A.parentGroup),
                    A.width ||
                      ((b = A.getBBox()),
                      (A.width = b.width),
                      (A.height = b.height),
                      (b = P.fontMetrics(A.element).h)),
                    (o = A.width - 2 * y),
                    (r = { left: "0", center: "0.5", right: "1" }[A.alignValue])
                      ? (C = +r * o)
                      : Y(A.x) &&
                        Math.round(A.x) !== A.translateX &&
                        (C = A.x - A.translateX),
                    {
                      x: m.x + (f.translateX || 0) + y - (C || 0),
                      y: m.y + (f.translateY || 0) + y - b,
                      width: A.width - 2 * y,
                      height: A.height - 2 * y,
                    }
                  );
              };
              for (s = 0; s < x; s++)
                (h = z[s]) &&
                  ((h.oldOpacity = h.opacity),
                  (h.newOpacity = 1),
                  (h.absoluteBox = D(h)));
              for (
                z.sort(function (A, m) {
                  return (m.labelrank || 0) - (A.labelrank || 0);
                }),
                  s = 0;
                s < x;
                s++
              )
                for (p = (D = z[s]) && D.absoluteBox, h = s + 1; h < x; ++h)
                  (g = (l = z[h]) && l.absoluteBox),
                    !p ||
                      !g ||
                      D === l ||
                      D.newOpacity === 0 ||
                      l.newOpacity === 0 ||
                      D.visibility === "hidden" ||
                      l.visibility === "hidden" ||
                      g.x >= p.x + p.width ||
                      g.x + g.width <= p.x ||
                      g.y >= p.y + p.height ||
                      g.y + g.height <= p.y ||
                      ((D.labelrank < l.labelrank ? D : l).newOpacity = 0);
              z.forEach(function (A) {
                M(A, S) && (T = !0);
              }),
                T && B(S, "afterHideAllOverlappingLabels");
            });
        }
      ),
      n(
        i,
        "Extensions/BorderRadius.js",
        [
          i["Core/Defaults.js"],
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Renderer/SVG/SVGRenderer.js"],
          i["Core/Utilities.js"],
        ],
        function (a, d, M, O, B, G) {
          const { defaultOptions: Y } = a;
          ({ seriesTypes: a } = M);
          const {
              addEvent: L,
              extend: E,
              isObject: z,
              merge: S,
              relativeLength: x,
            } = G,
            P = { radius: 0, scope: "stack", where: void 0 },
            h = (s, l) => (z(s) || (s = { radius: s || 0 }), S(P, l, s));
          if (O.symbolCustomAttribs.indexOf("borderRadius") === -1) {
            O.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
            const s = B.prototype.symbols.arc;
            B.prototype.symbols.arc = function (p, g, T, D, A = {}) {
              p = s(p, g, T, D, A);
              const { innerR: m = 0, r: f = T, start: b = 0, end: y = 0 } = A;
              if (A.open || !A.borderRadius) return p;
              for (
                T = y - b,
                  g = Math.sin(T / 2),
                  A = Math.max(
                    Math.min(
                      x(A.borderRadius || 0, f - m),
                      (f - m) / 2,
                      (f * g) / (1 + g)
                    ),
                    0
                  ),
                  T = Math.min(A, (T / Math.PI) * 2 * m),
                  g = p.length - 1;
                g--;

              ) {
                let N, w, R;
                D = p;
                var C = g,
                  o = 1 < g ? T : A,
                  r = D[C],
                  c = D[C + 1];
                if (
                  (c[0] === "Z" && (c = D[0]),
                  (r[0] !== "M" && r[0] !== "L") || c[0] !== "A"
                    ? r[0] !== "A" ||
                      (c[0] !== "M" && c[0] !== "L") ||
                      ((R = c), (w = r))
                    : ((R = r), (w = c), (N = !0)),
                  R && w && w.params)
                ) {
                  r = w[1];
                  var u = w[5];
                  c = w.params;
                  const { start: X, end: J, cx: K, cy: H } = c;
                  var v = u ? r - o : r + o;
                  const k = v ? Math.asin(o / v) : 0;
                  (u = u ? k : -k),
                    (v *= Math.cos(k)),
                    N
                      ? ((c.start = X + u),
                        (R[1] = K + v * Math.cos(X)),
                        (R[2] = H + v * Math.sin(X)),
                        D.splice(C + 1, 0, [
                          "A",
                          o,
                          o,
                          0,
                          0,
                          1,
                          K + r * Math.cos(c.start),
                          H + r * Math.sin(c.start),
                        ]))
                      : ((c.end = J - u),
                        (w[6] = K + r * Math.cos(c.end)),
                        (w[7] = H + r * Math.sin(c.end)),
                        D.splice(C + 1, 0, [
                          "A",
                          o,
                          o,
                          0,
                          0,
                          1,
                          K + v * Math.cos(J),
                          H + v * Math.sin(J),
                        ])),
                    (w[4] = Math.abs(c.end - c.start) < Math.PI ? 0 : 1);
                }
              }
              return p;
            };
            const l = B.prototype.symbols.roundedRect;
            (B.prototype.symbols.roundedRect = function (p, g, T, D, A = {}) {
              const m = l(p, g, T, D, A),
                { r: f = 0, brBoxHeight: b = D, brBoxY: y = g } = A;
              var C = g - y,
                o = y + b - (g + D);
              A = -0.1 < C - f ? 0 : f;
              const r = -0.1 < o - f ? 0 : f;
              var c = Math.max(A && C, 0);
              const u = Math.max(r && o, 0);
              (o = [p + A, g]), (C = [p + T - A, g]);
              const v = [p + T, g + A],
                N = [p + T, g + D - r],
                w = [p + T - r, g + D],
                R = [p + r, g + D],
                X = [p, g + D - r],
                J = [p, g + A];
              if (c) {
                const K = Math.sqrt(Math.pow(A, 2) - Math.pow(A - c, 2));
                (o[0] -= K), (C[0] += K), (v[1] = J[1] = g + A - c);
              }
              return (
                D < A - c &&
                  ((c = Math.sqrt(Math.pow(A, 2) - Math.pow(A - c - D, 2))),
                  (v[0] = N[0] = p + T - A + c),
                  (w[0] = Math.min(v[0], w[0])),
                  (R[0] = Math.max(N[0], R[0])),
                  (X[0] = J[0] = p + A - c),
                  (v[1] = J[1] = g + D)),
                u &&
                  ((c = Math.sqrt(Math.pow(r, 2) - Math.pow(r - u, 2))),
                  (w[0] += c),
                  (R[0] -= c),
                  (N[1] = X[1] = g + D - r + u)),
                D < r - u &&
                  ((D = Math.sqrt(Math.pow(r, 2) - Math.pow(r - u - D, 2))),
                  (v[0] = N[0] = p + T - r + D),
                  (C[0] = Math.min(v[0], C[0])),
                  (o[0] = Math.max(N[0], o[0])),
                  (X[0] = J[0] = p + r - D),
                  (N[1] = X[1] = g)),
                (m.length = 0),
                m.push(
                  ["M", ...o],
                  ["L", ...C],
                  ["A", A, A, 0, 0, 1, ...v],
                  ["L", ...N],
                  ["A", r, r, 0, 0, 1, ...w],
                  ["L", ...R],
                  ["A", r, r, 0, 0, 1, ...X],
                  ["L", ...J],
                  ["A", A, A, 0, 0, 1, ...o],
                  ["Z"]
                ),
                m
              );
            }),
              L(a.pie, "afterTranslate", function () {
                const p = h(this.options.borderRadius);
                for (const g of this.points) {
                  const T = g.shapeArgs;
                  T &&
                    (T.borderRadius = x(
                      p.radius,
                      (T.r || 0) - (T.innerR || 0)
                    ));
                }
              }),
              L(
                d,
                "afterColumnTranslate",
                function () {
                  var p, g;
                  if (
                    this.options.borderRadius &&
                    (!this.chart.is3d || !this.chart.is3d())
                  ) {
                    const { options: m, yAxis: f } = this,
                      b = m.stacking === "percent";
                    var T =
                      (g =
                        (p = Y.plotOptions) === null || p === void 0
                          ? void 0
                          : p[this.type]) === null || g === void 0
                        ? void 0
                        : g.borderRadius;
                    (p = h(m.borderRadius, z(T) ? T : {})),
                      (g = f.options.reversed);
                    for (const y of this.points)
                      if (
                        (({ shapeArgs: T } = y),
                        y.shapeType === "roundedRect" && T)
                      ) {
                        const { width: C = 0, height: o = 0, y: r = 0 } = T;
                        var D = r,
                          A = o;
                        p.scope === "stack" &&
                          y.stackTotal &&
                          ((D = f.translate(
                            b ? 100 : y.stackTotal,
                            !1,
                            !0,
                            !1,
                            !0
                          )),
                          (A = f.translate(m.threshold || 0, !1, !0, !1, !0)),
                          (A = this.crispCol(
                            0,
                            Math.min(D, A),
                            0,
                            Math.abs(D - A)
                          )),
                          (D = A.y),
                          (A = A.height));
                        const c = (y.negative ? -1 : 1) * (g ? -1 : 1) === -1;
                        let u = p.where;
                        !u &&
                          this.is("waterfall") &&
                          Math.abs(
                            (y.yBottom || 0) - (this.translatedThreshold || 0)
                          ) > this.borderWidth &&
                          (u = "all"),
                          u || (u = "end");
                        const v =
                          Math.min(
                            x(p.radius, C),
                            C / 2,
                            u === "all" ? o / 2 : 1 / 0
                          ) || 0;
                        u === "end" && (c && (D -= v), (A += v)),
                          E(T, { brBoxHeight: A, brBoxY: D, r: v });
                      }
                  }
                },
                { order: 9 }
              );
          }
          return (d = { optionsToObject: h }), d;
        }
      ),
      n(i, "Core/Responsive.js", [i["Core/Utilities.js"]], function (a) {
        const {
          diffObjects: d,
          extend: M,
          find: O,
          merge: B,
          pick: G,
          uniqueKey: Y,
        } = a;
        var L;
        return (
          (function (E) {
            function z(P, h) {
              const s = P.condition;
              (
                s.callback ||
                function () {
                  return (
                    this.chartWidth <= G(s.maxWidth, Number.MAX_VALUE) &&
                    this.chartHeight <= G(s.maxHeight, Number.MAX_VALUE) &&
                    this.chartWidth >= G(s.minWidth, 0) &&
                    this.chartHeight >= G(s.minHeight, 0)
                  );
                }
              ).call(this) && h.push(P._id);
            }
            function S(P, h) {
              const s = this.options.responsive;
              var l = this.currentResponsive;
              let p = [];
              !h &&
                s &&
                s.rules &&
                s.rules.forEach((g) => {
                  typeof g._id > "u" && (g._id = Y()),
                    this.matchResponsiveRule(g, p);
                }, this),
                (h = B(
                  ...p
                    .map((g) => O((s || {}).rules || [], (T) => T._id === g))
                    .map((g) => g && g.chartOptions)
                )),
                (h.isResponsiveOptions = !0),
                (p = p.toString() || void 0),
                p !== (l && l.ruleIds) &&
                  (l && this.update(l.undoOptions, P, !0),
                  p
                    ? ((l = d(h, this.options, !0, this.collectionsWithUpdate)),
                      (l.isResponsiveOptions = !0),
                      (this.currentResponsive = {
                        ruleIds: p,
                        mergedOptions: h,
                        undoOptions: l,
                      }),
                      this.update(h, P, !0))
                    : (this.currentResponsive = void 0));
            }
            const x = [];
            E.compose = function (P) {
              return (
                a.pushUnique(x, P) &&
                  M(P.prototype, { matchResponsiveRule: z, setResponsive: S }),
                P
              );
            };
          })(L || (L = {})),
          L
        );
      }),
      n(
        i,
        "masters/highcharts.src.js",
        [
          i["Core/Globals.js"],
          i["Core/Utilities.js"],
          i["Core/Defaults.js"],
          i["Core/Animation/Fx.js"],
          i["Core/Animation/AnimationUtilities.js"],
          i["Core/Renderer/HTML/AST.js"],
          i["Core/Templating.js"],
          i["Core/Renderer/RendererUtilities.js"],
          i["Core/Renderer/SVG/SVGElement.js"],
          i["Core/Renderer/SVG/SVGRenderer.js"],
          i["Core/Renderer/HTML/HTMLElement.js"],
          i["Core/Renderer/HTML/HTMLRenderer.js"],
          i["Core/Axis/Axis.js"],
          i["Core/Axis/DateTimeAxis.js"],
          i["Core/Axis/LogarithmicAxis.js"],
          i["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
          i["Core/Axis/Tick.js"],
          i["Core/Tooltip.js"],
          i["Core/Series/Point.js"],
          i["Core/Pointer.js"],
          i["Core/Legend/Legend.js"],
          i["Core/Chart/Chart.js"],
          i["Core/Axis/Stacking/StackingAxis.js"],
          i["Core/Axis/Stacking/StackItem.js"],
          i["Core/Series/Series.js"],
          i["Core/Series/SeriesRegistry.js"],
          i["Series/Column/ColumnSeries.js"],
          i["Series/Column/ColumnDataLabel.js"],
          i["Series/Pie/PieSeries.js"],
          i["Series/Pie/PieDataLabel.js"],
          i["Core/Series/DataLabel.js"],
          i["Core/Responsive.js"],
          i["Core/Color/Color.js"],
          i["Core/Time.js"],
        ],
        function (
          a,
          d,
          M,
          O,
          B,
          G,
          Y,
          L,
          E,
          z,
          S,
          x,
          P,
          h,
          s,
          l,
          p,
          g,
          T,
          D,
          A,
          m,
          f,
          b,
          y,
          C,
          o,
          r,
          c,
          u,
          v,
          N,
          w,
          R
        ) {
          return (
            (a.animate = B.animate),
            (a.animObject = B.animObject),
            (a.getDeferredAnimation = B.getDeferredAnimation),
            (a.setAnimation = B.setAnimation),
            (a.stop = B.stop),
            (a.timers = O.timers),
            (a.AST = G),
            (a.Axis = P),
            (a.Chart = m),
            (a.chart = m.chart),
            (a.Fx = O),
            (a.Legend = A),
            (a.PlotLineOrBand = l),
            (a.Point = T),
            (a.Pointer = D),
            (a.Series = y),
            (a.StackItem = b),
            (a.SVGElement = E),
            (a.SVGRenderer = z),
            (a.Templating = Y),
            (a.Tick = p),
            (a.Time = R),
            (a.Tooltip = g),
            (a.Color = w),
            (a.color = w.parse),
            x.compose(z),
            S.compose(E),
            D.compose(m),
            A.compose(m),
            (a.defaultOptions = M.defaultOptions),
            (a.getOptions = M.getOptions),
            (a.time = M.defaultTime),
            (a.setOptions = M.setOptions),
            (a.dateFormat = Y.dateFormat),
            (a.format = Y.format),
            (a.numberFormat = Y.numberFormat),
            (a.addEvent = d.addEvent),
            (a.arrayMax = d.arrayMax),
            (a.arrayMin = d.arrayMin),
            (a.attr = d.attr),
            (a.clearTimeout = d.clearTimeout),
            (a.correctFloat = d.correctFloat),
            (a.createElement = d.createElement),
            (a.css = d.css),
            (a.defined = d.defined),
            (a.destroyObjectProperties = d.destroyObjectProperties),
            (a.discardElement = d.discardElement),
            (a.distribute = L.distribute),
            (a.erase = d.erase),
            (a.error = d.error),
            (a.extend = d.extend),
            (a.extendClass = d.extendClass),
            (a.find = d.find),
            (a.fireEvent = d.fireEvent),
            (a.getMagnitude = d.getMagnitude),
            (a.getStyle = d.getStyle),
            (a.inArray = d.inArray),
            (a.isArray = d.isArray),
            (a.isClass = d.isClass),
            (a.isDOMElement = d.isDOMElement),
            (a.isFunction = d.isFunction),
            (a.isNumber = d.isNumber),
            (a.isObject = d.isObject),
            (a.isString = d.isString),
            (a.keys = d.keys),
            (a.merge = d.merge),
            (a.normalizeTickInterval = d.normalizeTickInterval),
            (a.objectEach = d.objectEach),
            (a.offset = d.offset),
            (a.pad = d.pad),
            (a.pick = d.pick),
            (a.pInt = d.pInt),
            (a.relativeLength = d.relativeLength),
            (a.removeEvent = d.removeEvent),
            (a.seriesType = C.seriesType),
            (a.splat = d.splat),
            (a.stableSort = d.stableSort),
            (a.syncTimeout = d.syncTimeout),
            (a.timeUnits = d.timeUnits),
            (a.uniqueKey = d.uniqueKey),
            (a.useSerialIds = d.useSerialIds),
            (a.wrap = d.wrap),
            r.compose(o),
            v.compose(y),
            h.compose(P),
            s.compose(P),
            u.compose(c),
            l.compose(P),
            N.compose(m),
            f.compose(P, m, y),
            g.compose(D),
            a
          );
        }
      ),
      (i["masters/highcharts.src.js"]._modules = i),
      i["masters/highcharts.src.js"]
    );
  });
})(td);
var Np = td.exports;
const _n = Ci(Np);
var ed = { exports: {} };
(function (t) {
  (function (e) {
    t.exports
      ? ((e.default = e), (t.exports = e))
      : e(typeof Highcharts < "u" ? Highcharts : void 0);
  })(function (e) {
    function n(i, a, d, M) {
      i.hasOwnProperty(a) ||
        ((i[a] = M.apply(null, d)),
        typeof CustomEvent == "function" &&
          window.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: a, module: i[a] },
            })
          ));
    }
    (e = e ? e._modules : {}),
      n(
        e,
        "Extensions/Pane.js",
        [
          e["Core/Chart/Chart.js"],
          e["Series/CenteredUtilities.js"],
          e["Core/Globals.js"],
          e["Core/Pointer.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          function B(h, s, l, p, g) {
            let T = !0;
            const D = l[0],
              A = l[1],
              m = Math.sqrt(Math.pow(h - D, 2) + Math.pow(s - A, 2));
            return (
              L(p) &&
                L(g) &&
                ((h = Math.atan2(Y(s - A, 8), Y(h - D, 8))),
                g !== p &&
                  (T =
                    p > g
                      ? (h >= p && h <= Math.PI) || (h <= g && h >= -Math.PI)
                      : h >= p && h <= Y(g, 8))),
              m <= Math.ceil(l[2] / 2) && T
            );
          }
          const {
            addEvent: G,
            correctFloat: Y,
            defined: L,
            extend: E,
            merge: z,
            pick: S,
            splat: x,
          } = O;
          i.prototype.collectionsWithUpdate.push("pane");
          class P {
            constructor(s, l) {
              (this.options =
                this.chart =
                this.center =
                this.background =
                  void 0),
                (this.coll = "pane"),
                (this.defaultOptions = {
                  center: ["50%", "50%"],
                  size: "85%",
                  innerSize: "0%",
                  startAngle: 0,
                }),
                (this.defaultBackgroundOptions = {
                  shape: "circle",
                  borderWidth: 1,
                  borderColor: "#cccccc",
                  backgroundColor: {
                    linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                    stops: [
                      [0, "#ffffff"],
                      [1, "#e6e6e6"],
                    ],
                  },
                  from: -Number.MAX_VALUE,
                  innerRadius: 0,
                  to: Number.MAX_VALUE,
                  outerRadius: "105%",
                }),
                this.init(s, l);
            }
            init(s, l) {
              (this.chart = l),
                (this.background = []),
                l.pane.push(this),
                this.setOptions(s);
            }
            setOptions(s) {
              this.options = z(
                this.defaultOptions,
                this.chart.angular ? { background: {} } : void 0,
                s
              );
            }
            render() {
              var s = this.options;
              let l = this.options.background;
              var p = this.chart.renderer;
              if (
                (this.group ||
                  (this.group = p
                    .g("pane-group")
                    .attr({ zIndex: s.zIndex || 0 })
                    .add()),
                this.updateCenter(),
                l)
              )
                for (
                  l = x(l),
                    s = Math.max(l.length, this.background.length || 0),
                    p = 0;
                  p < s;
                  p++
                )
                  l[p] && this.axis
                    ? this.renderBackground(
                        z(this.defaultBackgroundOptions, l[p]),
                        p
                      )
                    : this.background[p] &&
                      ((this.background[p] = this.background[p].destroy()),
                      this.background.splice(p, 1));
            }
            renderBackground(s, l) {
              let p = "animate",
                g = { class: "highcharts-pane " + (s.className || "") };
              this.chart.styledMode ||
                E(g, {
                  fill: s.backgroundColor,
                  stroke: s.borderColor,
                  "stroke-width": s.borderWidth,
                }),
                this.background[l] ||
                  ((this.background[l] = this.chart.renderer
                    .path()
                    .add(this.group)),
                  (p = "attr")),
                this.background[l][p]({
                  d: this.axis.getPlotBandPath(s.from, s.to, s),
                }).attr(g);
            }
            updateCenter(s) {
              this.center = (s || this.axis || {}).center =
                a.getCenter.call(this);
            }
            update(s, l) {
              z(!0, this.options, s),
                this.setOptions(this.options),
                this.render(),
                this.chart.axes.forEach(function (p) {
                  p.pane === this && ((p.pane = null), p.update({}, l));
                }, this);
            }
          }
          return (
            (i.prototype.getHoverPane = function (h) {
              const s = this;
              let l;
              return (
                h &&
                  s.pane.forEach((p) => {
                    B(h.chartX - s.plotLeft, h.chartY - s.plotTop, p.center) &&
                      (l = p);
                  }),
                l
              );
            }),
            G(i, "afterIsInsidePlot", function (h) {
              this.polar &&
                (h.options.inverted && ([h.x, h.y] = [h.y, h.x]),
                (h.isInsidePlot = this.pane.some((s) =>
                  B(
                    h.x,
                    h.y,
                    s.center,
                    s.axis && s.axis.normalizedStartAngleRad,
                    s.axis && s.axis.normalizedEndAngleRad
                  )
                )));
            }),
            G(M, "beforeGetHoverData", function (h) {
              const s = this.chart;
              s.polar
                ? ((s.hoverPane = s.getHoverPane(h)),
                  (h.filter = function (l) {
                    return (
                      l.visible &&
                      !(!h.shared && l.directTouch) &&
                      S(l.options.enableMouseTracking, !0) &&
                      (!s.hoverPane || l.xAxis.pane === s.hoverPane)
                    );
                  }))
                : (s.hoverPane = void 0);
            }),
            G(M, "afterGetHoverData", function (h) {
              const s = this.chart;
              h.hoverPoint &&
                h.hoverPoint.plotX &&
                h.hoverPoint.plotY &&
                s.hoverPane &&
                !B(
                  h.hoverPoint.plotX,
                  h.hoverPoint.plotY,
                  s.hoverPane.center
                ) &&
                (h.hoverPoint = void 0);
            }),
            (d.Pane = P),
            d.Pane
          );
        }
      ),
      n(
        e,
        "Series/AreaRange/AreaRangePoint.js",
        [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const {
              area: {
                prototype: {
                  pointClass: d,
                  pointClass: { prototype: M },
                },
              },
            } = i.seriesTypes,
            { defined: O, isNumber: B } = a;
          class G extends d {
            constructor() {
              super(...arguments),
                (this.series =
                  this.plotX =
                  this.options =
                  this.low =
                  this.high =
                    void 0);
            }
            setState() {
              const L = this.state,
                E = this.series,
                z = E.chart.polar;
              O(this.plotHigh) ||
                (this.plotHigh = E.yAxis.toPixels(this.high, !0)),
                O(this.plotLow) ||
                  (this.plotLow = this.plotY = E.yAxis.toPixels(this.low, !0)),
                E.stateMarkerGraphic &&
                  ((E.lowerStateMarkerGraphic = E.stateMarkerGraphic),
                  (E.stateMarkerGraphic = E.upperStateMarkerGraphic)),
                (this.graphic = this.graphics && this.graphics[1]),
                (this.plotY = this.plotHigh),
                z && B(this.plotHighX) && (this.plotX = this.plotHighX),
                M.setState.apply(this, arguments),
                (this.state = L),
                (this.plotY = this.plotLow),
                (this.graphic = this.graphics && this.graphics[0]),
                z && B(this.plotLowX) && (this.plotX = this.plotLowX),
                E.stateMarkerGraphic &&
                  ((E.upperStateMarkerGraphic = E.stateMarkerGraphic),
                  (E.stateMarkerGraphic = E.lowerStateMarkerGraphic),
                  (E.lowerStateMarkerGraphic = void 0)),
                M.setState.apply(this, arguments);
            }
            haloPath() {
              const L = this.series.chart.polar;
              let E = [];
              return (
                (this.plotY = this.plotLow),
                L && B(this.plotLowX) && (this.plotX = this.plotLowX),
                this.isInside && (E = M.haloPath.apply(this, arguments)),
                (this.plotY = this.plotHigh),
                L && B(this.plotHighX) && (this.plotX = this.plotHighX),
                this.isTopInside &&
                  (E = E.concat(M.haloPath.apply(this, arguments))),
                E
              );
            }
            isValid() {
              return B(this.low) && B(this.high);
            }
          }
          return G;
        }
      ),
      n(
        e,
        "Series/AreaRange/AreaRangeSeries.js",
        [
          e["Series/AreaRange/AreaRangePoint.js"],
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          ({ noop: a } = a);
          const {
              area: O,
              area: { prototype: B },
              column: { prototype: G },
            } = d.seriesTypes,
            {
              addEvent: Y,
              defined: L,
              extend: E,
              isArray: z,
              isNumber: S,
              pick: x,
              merge: P,
            } = M;
          class h extends O {
            constructor() {
              super(...arguments),
                (this.xAxis =
                  this.lowerStateMarkerGraphic =
                  this.points =
                  this.options =
                  this.data =
                    void 0);
            }
            toYData(l) {
              return [l.low, l.high];
            }
            highToXY(l) {
              const p = this.chart,
                g = this.xAxis.postTranslate(
                  l.rectPlotX || 0,
                  this.yAxis.len - (l.plotHigh || 0)
                );
              (l.plotHighX = g.x - p.plotLeft),
                (l.plotHigh = g.y - p.plotTop),
                (l.plotLowX = l.plotX);
            }
            getGraphPath(l) {
              var p = [],
                g = [];
              const T = B.getGraphPath;
              var D = this.options;
              const A = this.chart.polar,
                m = A && D.connectEnds !== !1,
                f = D.connectNulls;
              let b,
                y,
                C,
                o = D.step;
              for (l = l || this.points, b = l.length; b--; ) {
                y = l[b];
                const r = A
                  ? { plotX: y.rectPlotX, plotY: y.yBottom, doCurve: !1 }
                  : { plotX: y.plotX, plotY: y.plotY, doCurve: !1 };
                y.isNull ||
                  m ||
                  f ||
                  (l[b + 1] && !l[b + 1].isNull) ||
                  g.push(r),
                  (C = {
                    polarPlotY: y.polarPlotY,
                    rectPlotX: y.rectPlotX,
                    yBottom: y.yBottom,
                    plotX: x(y.plotHighX, y.plotX),
                    plotY: y.plotHigh,
                    isNull: y.isNull,
                  }),
                  g.push(C),
                  p.push(C),
                  y.isNull ||
                    m ||
                    f ||
                    (l[b - 1] && !l[b - 1].isNull) ||
                    g.push(r);
              }
              return (
                (l = T.call(this, l)),
                o &&
                  (o === !0 && (o = "left"),
                  (D.step = { left: "right", center: "center", right: "left" }[
                    o
                  ])),
                (p = T.call(this, p)),
                (g = T.call(this, g)),
                (D.step = o),
                (D = [].concat(l, p)),
                !this.chart.polar &&
                  g[0] &&
                  g[0][0] === "M" &&
                  (g[0] = ["L", g[0][1], g[0][2]]),
                (this.graphPath = D),
                (this.areaPath = l.concat(g)),
                (D.isArea = !0),
                (D.xMap = l.xMap),
                (this.areaPath.xMap = l.xMap),
                D
              );
            }
            drawDataLabels() {
              const l = this.points,
                p = l.length,
                g = [],
                T = this.options.dataLabels,
                D = this.chart.inverted;
              let A, m, f, b, y;
              if (T) {
                if (
                  (z(T)
                    ? ((b = T[0] || { enabled: !1 }),
                      (y = T[1] || { enabled: !1 }))
                    : ((b = E({}, T)),
                      (b.x = T.xHigh),
                      (b.y = T.yHigh),
                      (y = E({}, T)),
                      (y.x = T.xLow),
                      (y.y = T.yLow)),
                  b.enabled || this._hasPointLabels)
                ) {
                  for (A = p; A--; )
                    if ((m = l[A])) {
                      const { plotHigh: C = 0, plotLow: o = 0 } = m;
                      (f = b.inside ? C < o : C > o),
                        (m.y = m.high),
                        (m._plotY = m.plotY),
                        (m.plotY = C),
                        (g[A] = m.dataLabel),
                        (m.dataLabel = m.dataLabelUpper),
                        (m.below = f),
                        D
                          ? b.align || (b.align = f ? "right" : "left")
                          : b.verticalAlign ||
                            (b.verticalAlign = f ? "top" : "bottom");
                    }
                  for (
                    this.options.dataLabels = b,
                      B.drawDataLabels &&
                        B.drawDataLabels.apply(this, arguments),
                      A = p;
                    A--;

                  )
                    (m = l[A]) &&
                      ((m.dataLabelUpper = m.dataLabel),
                      (m.dataLabel = g[A]),
                      delete m.dataLabels,
                      (m.y = m.low),
                      (m.plotY = m._plotY));
                }
                if (y.enabled || this._hasPointLabels) {
                  for (A = p; A--; )
                    if ((m = l[A])) {
                      const { plotHigh: C = 0, plotLow: o = 0 } = m;
                      (f = y.inside ? C < o : C > o),
                        (m.below = !f),
                        D
                          ? y.align || (y.align = f ? "left" : "right")
                          : y.verticalAlign ||
                            (y.verticalAlign = f ? "bottom" : "top");
                    }
                  (this.options.dataLabels = y),
                    B.drawDataLabels && B.drawDataLabels.apply(this, arguments);
                }
                if (b.enabled)
                  for (A = p; A--; )
                    (m = l[A]) &&
                      (m.dataLabels = [m.dataLabelUpper, m.dataLabel].filter(
                        function (C) {
                          return !!C;
                        }
                      ));
                this.options.dataLabels = T;
              }
            }
            alignDataLabel() {
              G.alignDataLabel.apply(this, arguments);
            }
            drawPoints() {
              const l = this.points.length;
              let p, g;
              for (B.drawPoints.apply(this, arguments), p = 0; p < l; )
                (g = this.points[p]),
                  (g.graphics = g.graphics || []),
                  (g.origProps = {
                    plotY: g.plotY,
                    plotX: g.plotX,
                    isInside: g.isInside,
                    negative: g.negative,
                    zone: g.zone,
                    y: g.y,
                  }),
                  (g.graphic || g.graphics[0]) && (g.graphics[0] = g.graphic),
                  (g.graphic = g.graphics[1]),
                  (g.plotY = g.plotHigh),
                  L(g.plotHighX) && (g.plotX = g.plotHighX),
                  (g.y = x(g.high, g.origProps.y)),
                  (g.negative = g.y < (this.options.threshold || 0)),
                  this.zones.length && (g.zone = g.getZone()),
                  this.chart.polar ||
                    (g.isInside = g.isTopInside =
                      typeof g.plotY < "u" &&
                      0 <= g.plotY &&
                      g.plotY <= this.yAxis.len &&
                      0 <= g.plotX &&
                      g.plotX <= this.xAxis.len),
                  p++;
              for (B.drawPoints.apply(this, arguments), p = 0; p < l; )
                (g = this.points[p]),
                  (g.graphics = g.graphics || []),
                  (g.graphic || g.graphics[1]) && (g.graphics[1] = g.graphic),
                  (g.graphic = g.graphics[0]),
                  g.origProps && (E(g, g.origProps), delete g.origProps),
                  p++;
            }
          }
          return (
            (h.defaultOptions = P(O.defaultOptions, {
              lineWidth: 1,
              threshold: null,
              tooltip: {
                pointFormat:
                  '<span style="color:{series.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>',
              },
              trackByArea: !0,
              dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                xLow: 0,
                xHigh: 0,
                yLow: 0,
                yHigh: 0,
              },
            })),
            Y(
              h,
              "afterTranslate",
              function () {
                this.pointArrayMap.join(",") === "low,high" &&
                  this.points.forEach((s) => {
                    const l = s.high,
                      p = s.plotY;
                    s.isNull
                      ? (s.plotY = void 0)
                      : ((s.plotLow = p),
                        (s.plotHigh = S(l)
                          ? this.yAxis.translate(
                              this.dataModify
                                ? this.dataModify.modifyValue(l)
                                : l,
                              !1,
                              !0,
                              void 0,
                              !0
                            )
                          : void 0),
                        this.dataModify && (s.yBottom = s.plotHigh));
                  });
              },
              { order: 0 }
            ),
            Y(
              h,
              "afterTranslate",
              function () {
                this.points.forEach((s) => {
                  if (this.chart.polar)
                    this.highToXY(s),
                      (s.plotLow = s.plotY),
                      (s.tooltipPos = [
                        ((s.plotHighX || 0) + (s.plotLowX || 0)) / 2,
                        ((s.plotHigh || 0) + (s.plotLow || 0)) / 2,
                      ]);
                  else {
                    const l = s.pos(!1, s.plotLow),
                      p = s.pos(!1, s.plotHigh);
                    l &&
                      p &&
                      ((l[0] = (l[0] + p[0]) / 2), (l[1] = (l[1] + p[1]) / 2)),
                      (s.tooltipPos = l);
                  }
                });
              },
              { order: 3 }
            ),
            E(h.prototype, {
              deferTranslatePolar: !0,
              pointArrayMap: ["low", "high"],
              pointClass: i,
              pointValKey: "low",
              setStackedPoints: a,
            }),
            d.registerSeriesType("arearange", h),
            h
          );
        }
      ),
      n(
        e,
        "Series/AreaSplineRange/AreaSplineRangeSeries.js",
        [
          e["Series/AreaRange/AreaRangeSeries.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          const {
              spline: { prototype: M },
            } = a.seriesTypes,
            { merge: O, extend: B } = d;
          class G extends i {
            constructor() {
              super(...arguments),
                (this.points = this.data = this.options = void 0);
            }
          }
          return (
            (G.defaultOptions = O(i.defaultOptions)),
            B(G.prototype, { getPointSpline: M.getPointSpline }),
            a.registerSeriesType("areasplinerange", G),
            G
          );
        }
      ),
      n(
        e,
        "Series/BoxPlot/BoxPlotSeries.js",
        [
          e["Series/Column/ColumnSeries.js"],
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          ({ noop: a } = a);
          const { extend: O, merge: B, pick: G } = M;
          class Y extends i {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            pointAttribs() {
              return {};
            }
            translate() {
              const E = this.yAxis,
                z = this.pointArrayMap;
              super.translate.apply(this),
                this.points.forEach(function (S) {
                  z.forEach(function (x) {
                    S[x] !== null &&
                      (S[x + "Plot"] = E.translate(S[x], 0, 1, 0, 1));
                  }),
                    (S.plotHigh = S.highPlot);
                });
            }
            drawPoints() {
              let E = this,
                z = E.options,
                S = E.chart,
                x = S.renderer,
                P,
                h,
                s,
                l,
                p,
                g,
                T = 0,
                D,
                A,
                m,
                f,
                b = E.doQuartiles !== !1,
                y,
                C = E.options.whiskerLength;
              E.points.forEach(function (o) {
                var r = o.graphic;
                let c = r ? "animate" : "attr",
                  u = o.shapeArgs,
                  v = {},
                  N = {},
                  w = {},
                  R = {},
                  X = o.color || E.color;
                typeof o.plotY < "u" &&
                  ((D = Math.round(u.width)),
                  (A = Math.floor(u.x)),
                  (m = A + D),
                  (f = Math.round(D / 2)),
                  (P = Math.floor(b ? o.q1Plot : o.lowPlot)),
                  (h = Math.floor(b ? o.q3Plot : o.lowPlot)),
                  (s = Math.floor(o.highPlot)),
                  (l = Math.floor(o.lowPlot)),
                  r ||
                    ((o.graphic = r = x.g("point").add(E.group)),
                    (o.stem = x
                      .path()
                      .addClass("highcharts-boxplot-stem")
                      .add(r)),
                    C &&
                      (o.whiskers = x
                        .path()
                        .addClass("highcharts-boxplot-whisker")
                        .add(r)),
                    b &&
                      (o.box = x
                        .path(void 0)
                        .addClass("highcharts-boxplot-box")
                        .add(r)),
                    (o.medianShape = x
                      .path(void 0)
                      .addClass("highcharts-boxplot-median")
                      .add(r))),
                  S.styledMode ||
                    ((N.stroke = o.stemColor || z.stemColor || X),
                    (N["stroke-width"] = G(
                      o.stemWidth,
                      z.stemWidth,
                      z.lineWidth
                    )),
                    (N.dashstyle =
                      o.stemDashStyle || z.stemDashStyle || z.dashStyle),
                    o.stem.attr(N),
                    C &&
                      ((w.stroke = o.whiskerColor || z.whiskerColor || X),
                      (w["stroke-width"] = G(
                        o.whiskerWidth,
                        z.whiskerWidth,
                        z.lineWidth
                      )),
                      (w.dashstyle =
                        o.whiskerDashStyle ||
                        z.whiskerDashStyle ||
                        z.dashStyle),
                      o.whiskers.attr(w)),
                    b &&
                      ((v.fill = o.fillColor || z.fillColor || X),
                      (v.stroke = z.lineColor || X),
                      (v["stroke-width"] = z.lineWidth || 0),
                      (v.dashstyle =
                        o.boxDashStyle || z.boxDashStyle || z.dashStyle),
                      o.box.attr(v)),
                    (R.stroke = o.medianColor || z.medianColor || X),
                    (R["stroke-width"] = G(
                      o.medianWidth,
                      z.medianWidth,
                      z.lineWidth
                    )),
                    (R.dashstyle =
                      o.medianDashStyle || z.medianDashStyle || z.dashStyle),
                    o.medianShape.attr(R)),
                  (g = (o.stem.strokeWidth() % 2) / 2),
                  (T = A + f + g),
                  (r = [
                    ["M", T, h],
                    ["L", T, s],
                    ["M", T, P],
                    ["L", T, l],
                  ]),
                  o.stem[c]({ d: r }),
                  b &&
                    ((g = (o.box.strokeWidth() % 2) / 2),
                    (P = Math.floor(P) + g),
                    (h = Math.floor(h) + g),
                    (A += g),
                    (m += g),
                    (r = [
                      ["M", A, h],
                      ["L", A, P],
                      ["L", m, P],
                      ["L", m, h],
                      ["L", A, h],
                      ["Z"],
                    ]),
                    o.box[c]({ d: r })),
                  C &&
                    ((g = (o.whiskers.strokeWidth() % 2) / 2),
                    (s += g),
                    (l += g),
                    (y = /%$/.test(C) ? (f * parseFloat(C)) / 100 : C / 2),
                    (r = [
                      ["M", T - y, s],
                      ["L", T + y, s],
                      ["M", T - y, l],
                      ["L", T + y, l],
                    ]),
                    o.whiskers[c]({ d: r })),
                  (p = Math.round(o.medianPlot)),
                  (g = (o.medianShape.strokeWidth() % 2) / 2),
                  (p += g),
                  (r = [
                    ["M", A, p],
                    ["L", m, p],
                  ]),
                  o.medianShape[c]({ d: r }));
              });
            }
            toYData(E) {
              return [E.low, E.q1, E.median, E.q3, E.high];
            }
          }
          return (
            (Y.defaultOptions = B(i.defaultOptions, {
              threshold: null,
              tooltip: {
                pointFormat:
                  '<span style="color:{point.color}"></span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>',
              },
              whiskerLength: "50%",
              fillColor: "#ffffff",
              lineWidth: 1,
              medianWidth: 2,
              whiskerWidth: 2,
            })),
            O(Y.prototype, {
              pointArrayMap: ["low", "q1", "median", "q3", "high"],
              pointValKey: "high",
              drawDataLabels: a,
              setStackedPoints: a,
            }),
            d.registerSeriesType("boxplot", Y),
            Y
          );
        }
      ),
      n(e, "Series/Bubble/BubbleLegendDefaults.js", [], function () {
        return {
          borderColor: void 0,
          borderWidth: 2,
          className: void 0,
          color: void 0,
          connectorClassName: void 0,
          connectorColor: void 0,
          connectorDistance: 60,
          connectorWidth: 1,
          enabled: !1,
          labels: {
            className: void 0,
            allowOverlap: !1,
            format: "",
            formatter: void 0,
            align: "right",
            style: { fontSize: "0.9em", color: "#000000" },
            x: 0,
            y: 0,
          },
          maxSize: 60,
          minSize: 10,
          legendIndex: 0,
          ranges: {
            value: void 0,
            borderColor: void 0,
            color: void 0,
            connectorColor: void 0,
          },
          sizeBy: "area",
          sizeByAbsoluteValue: !1,
          zIndex: 1,
          zThreshold: 0,
        };
      }),
      n(
        e,
        "Series/Bubble/BubbleLegendItem.js",
        [
          e["Core/Color/Color.js"],
          e["Core/Templating.js"],
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          const { parse: O } = i,
            { noop: B } = d,
            {
              arrayMax: G,
              arrayMin: Y,
              isNumber: L,
              merge: E,
              pick: z,
              stableSort: S,
            } = M;
          class x {
            constructor(h, s) {
              (this.options =
                this.symbols =
                this.visible =
                this.selected =
                this.ranges =
                this.movementX =
                this.maxLabel =
                this.legend =
                this.chart =
                  void 0),
                (this.setState = B),
                this.init(h, s);
            }
            init(h, s) {
              (this.options = h),
                (this.visible = !0),
                (this.chart = s.chart),
                (this.legend = s);
            }
            addToLegend(h) {
              h.splice(this.options.legendIndex, 0, this);
            }
            drawLegendSymbol(h) {
              const s = z(h.options.itemDistance, 20),
                l = this.legendItem || {},
                p = this.options;
              var g = p.ranges,
                T = p.connectorDistance;
              if (g && g.length && L(g[0].value)) {
                S(g, function (A, m) {
                  return m.value - A.value;
                }),
                  (this.ranges = g),
                  this.setOptions(),
                  this.render(),
                  (h = this.getMaxLabelSize());
                var D = this.ranges[0].radius;
                (g = 2 * D),
                  (T = T - D + h.width),
                  (T = 0 < T ? T : 0),
                  (this.maxLabel = h),
                  (this.movementX = p.labels.align === "left" ? T : 0),
                  (l.labelWidth = g + T + s),
                  (l.labelHeight = g + h.height / 2);
              } else h.options.bubbleLegend.autoRanges = !0;
            }
            setOptions() {
              const h = this.ranges,
                s = this.options,
                l = this.chart.series[s.seriesIndex],
                p = this.legend.baseline,
                g = { zIndex: s.zIndex, "stroke-width": s.borderWidth },
                T = { zIndex: s.zIndex, "stroke-width": s.connectorWidth },
                D = {
                  align:
                    this.legend.options.rtl || s.labels.align === "left"
                      ? "right"
                      : "left",
                  zIndex: s.zIndex,
                },
                A = l.options.marker.fillOpacity,
                m = this.chart.styledMode;
              h.forEach(function (f, b) {
                m ||
                  ((g.stroke = z(f.borderColor, s.borderColor, l.color)),
                  (g.fill = z(
                    f.color,
                    s.color,
                    A !== 1 ? O(l.color).setOpacity(A).get("rgba") : l.color
                  )),
                  (T.stroke = z(f.connectorColor, s.connectorColor, l.color))),
                  (h[b].radius = this.getRangeRadius(f.value)),
                  (h[b] = E(h[b], { center: h[0].radius - h[b].radius + p })),
                  m ||
                    E(!0, h[b], {
                      bubbleAttribs: E(g),
                      connectorAttribs: E(T),
                      labelAttribs: D,
                    });
              }, this);
            }
            getRangeRadius(h) {
              const s = this.options;
              return this.chart.series[this.options.seriesIndex].getRadius.call(
                this,
                s.ranges[s.ranges.length - 1].value,
                s.ranges[0].value,
                s.minSize,
                s.maxSize,
                h
              );
            }
            render() {
              const h = this.legendItem || {},
                s = this.chart.renderer,
                l = this.options.zThreshold;
              this.symbols ||
                (this.symbols = {
                  connectors: [],
                  bubbleItems: [],
                  labels: [],
                }),
                (h.symbol = s.g("bubble-legend")),
                (h.label = s
                  .g("bubble-legend-item")
                  .css(this.legend.itemStyle || {})),
                (h.symbol.translateX = 0),
                (h.symbol.translateY = 0),
                h.symbol.add(h.label),
                h.label.add(h.group);
              for (const p of this.ranges) p.value >= l && this.renderRange(p);
              this.hideOverlappingLabels();
            }
            renderRange(h) {
              var s = this.options;
              const l = s.labels;
              var p = this.chart;
              const g = p.series[s.seriesIndex],
                T = p.renderer,
                D = this.symbols;
              p = D.labels;
              const A = h.center,
                m = Math.abs(h.radius);
              var f = s.connectorDistance || 0;
              const b = l.align,
                y = s.connectorWidth,
                C = this.ranges[0].radius || 0,
                o = A - m - s.borderWidth / 2 + y / 2,
                r = T.styledMode;
              (f = this.legend.options.rtl || b === "left" ? -f : f),
                b === "center" &&
                  ((f = 0),
                  (s.connectorDistance = 0),
                  (h.labelAttribs.align = "center")),
                D.bubbleItems.push(
                  T.circle(C, A + ((o % 1 ? 1 : 0.5) - (y % 2 ? 0 : 0.5)), m)
                    .attr(r ? {} : h.bubbleAttribs)
                    .addClass(
                      (r ? "highcharts-color-" + g.colorIndex + " " : "") +
                        "highcharts-bubble-legend-symbol " +
                        (s.className || "")
                    )
                    .add(this.legendItem.symbol)
                ),
                D.connectors.push(
                  T.path(
                    T.crispLine(
                      [
                        ["M", C, o],
                        ["L", C + f, o],
                      ],
                      s.connectorWidth
                    )
                  )
                    .attr(r ? {} : h.connectorAttribs)
                    .addClass(
                      (r
                        ? "highcharts-color-" + this.options.seriesIndex + " "
                        : "") +
                        "highcharts-bubble-legend-connectors " +
                        (s.connectorClassName || "")
                    )
                    .add(this.legendItem.symbol)
                ),
                (h = T.text(this.formatLabel(h))
                  .attr(r ? {} : h.labelAttribs)
                  .css(r ? {} : l.style)
                  .addClass(
                    "highcharts-bubble-legend-labels " +
                      (s.labels.className || "")
                  )
                  .add(this.legendItem.symbol)),
                (s = {
                  x: C + f + s.labels.x,
                  y: o + s.labels.y + 0.4 * h.getBBox().height,
                }),
                h.attr(s),
                p.push(h),
                (h.placed = !0),
                (h.alignAttr = s);
            }
            getMaxLabelSize() {
              let h, s;
              return (
                this.symbols.labels.forEach(function (l) {
                  (s = l.getBBox(!0)),
                    (h = h ? (s.width > h.width ? s : h) : s);
                }),
                h || {}
              );
            }
            formatLabel(h) {
              var s = this.options;
              const l = s.labels.formatter;
              s = s.labels.format;
              const { numberFormatter: p } = this.chart;
              return s ? a.format(s, h) : l ? l.call(h) : p(h.value, 1);
            }
            hideOverlappingLabels() {
              const h = this.chart,
                s = this.symbols;
              !this.options.labels.allowOverlap &&
                s &&
                (h.hideOverlappingLabels(s.labels),
                s.labels.forEach(function (l, p) {
                  l.newOpacity
                    ? l.newOpacity !== l.oldOpacity && s.connectors[p].show()
                    : s.connectors[p].hide();
                }));
            }
            getRanges() {
              const h = this.legend.bubbleLegend,
                s = h.options.ranges;
              let l,
                p,
                g = Number.MAX_VALUE,
                T = -Number.MAX_VALUE;
              return (
                h.chart.series.forEach(function (D) {
                  D.isBubble &&
                    !D.ignoreSeries &&
                    ((p = D.zData.filter(L)),
                    p.length &&
                      ((g = z(
                        D.options.zMin,
                        Math.min(
                          g,
                          Math.max(
                            Y(p),
                            D.options.displayNegative === !1
                              ? D.options.zThreshold
                              : -Number.MAX_VALUE
                          )
                        )
                      )),
                      (T = z(D.options.zMax, Math.max(T, G(p))))));
                }),
                (l =
                  g === T
                    ? [{ value: T }]
                    : [
                        { value: g },
                        { value: (g + T) / 2 },
                        { value: T, autoRanges: !0 },
                      ]),
                s.length && s[0].radius && l.reverse(),
                l.forEach(function (D, A) {
                  s && s[A] && (l[A] = E(s[A], D));
                }),
                l
              );
            }
            predictBubbleSizes() {
              var h = this.chart,
                s = h.legend.options,
                l = s.floating;
              const p = (s = s.layout === "horizontal")
                  ? h.legend.lastLineHeight
                  : 0,
                g = h.plotSizeX,
                T = h.plotSizeY;
              var D = h.series[this.options.seriesIndex],
                A = D.getPxExtremes();
              (h = Math.ceil(A.minPxSize)), (A = Math.ceil(A.maxPxSize));
              const m = Math.min(T, g);
              return (
                (D = D.options.maxSize),
                l || !/%$/.test(D)
                  ? (l = A)
                  : ((D = parseFloat(D)),
                    (l = ((m + p) * D) / 100 / (D / 100 + 1)),
                    ((s && T - l >= g) || (!s && g - l >= T)) && (l = A)),
                [h, Math.ceil(l)]
              );
            }
            updateRanges(h, s) {
              const l = this.legend.options.bubbleLegend;
              (l.minSize = h), (l.maxSize = s), (l.ranges = this.getRanges());
            }
            correctSizes() {
              const h = this.legend,
                s = this.chart.series[this.options.seriesIndex].getPxExtremes();
              1 < Math.abs(Math.ceil(s.maxPxSize) - this.options.maxSize) &&
                (this.updateRanges(this.options.minSize, s.maxPxSize),
                h.render());
            }
          }
          return x;
        }
      ),
      n(
        e,
        "Series/Bubble/BubbleLegendComposition.js",
        [
          e["Series/Bubble/BubbleLegendDefaults.js"],
          e["Series/Bubble/BubbleLegendItem.js"],
          e["Core/Defaults.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          function O(s, l, p) {
            const g = this.legend;
            var T = 0 <= B(this);
            let D, A;
            g &&
            g.options.enabled &&
            g.bubbleLegend &&
            g.options.bubbleLegend.autoRanges &&
            T
              ? ((D = g.bubbleLegend.options),
                (T = g.bubbleLegend.predictBubbleSizes()),
                g.bubbleLegend.updateRanges(T[0], T[1]),
                D.placed ||
                  ((g.group.placed = !1),
                  g.allItems.forEach((m) => {
                    (A = m.legendItem || {}),
                      A.group && (A.group.translateY = null);
                  })),
                g.render(),
                this.getMargins(),
                this.axes.forEach(function (m) {
                  m.visible && m.render(),
                    D.placed ||
                      (m.setScale(),
                      m.updateNames(),
                      x(m.ticks, function (f) {
                        (f.isNew = !0), (f.isNewLabel = !0);
                      }));
                }),
                (D.placed = !0),
                this.getMargins(),
                s.call(this, l, p),
                g.bubbleLegend.correctSizes(),
                E(g, G(g)))
              : (s.call(this, l, p),
                g &&
                  g.options.enabled &&
                  g.bubbleLegend &&
                  (g.render(), E(g, G(g))));
          }
          function B(s) {
            s = s.series;
            let l = 0;
            for (; l < s.length; ) {
              if (s[l] && s[l].isBubble && s[l].visible && s[l].zData.length)
                return l;
              l++;
            }
            return -1;
          }
          function G(s) {
            s = s.allItems;
            const l = [],
              p = s.length;
            let g,
              T,
              D = 0;
            for (T = 0; T < p; T++) {
              var A = s[T].legendItem || {};
              if (
                ((g = (s[T + 1] || {}).legendItem || {}),
                A.labelHeight && (s[T].itemHeight = A.labelHeight),
                s[T] === s[p - 1] || A.y !== g.y)
              ) {
                for (l.push({ height: 0 }), A = l[l.length - 1], D; D <= T; D++)
                  s[D].itemHeight > A.height && (A.height = s[D].itemHeight);
                A.step = T;
              }
            }
            return l;
          }
          function Y(s) {
            const l = this.bubbleLegend,
              p = this.options,
              g = p.bubbleLegend,
              T = B(this.chart);
            l &&
              l.ranges &&
              l.ranges.length &&
              (g.ranges.length && (g.autoRanges = !!g.ranges[0].autoRanges),
              this.destroyItem(l)),
              0 <= T &&
                p.enabled &&
                g.enabled &&
                ((g.seriesIndex = T),
                (this.bubbleLegend = new a(g, this)),
                this.bubbleLegend.addToLegend(s.allItems));
          }
          function L(s) {
            if (s.defaultPrevented) return !1;
            var l = this.chart;
            s = this.visible;
            const p = this.chart.legend;
            p &&
              p.bubbleLegend &&
              ((this.visible = !s),
              (this.ignoreSeries = s),
              (l = 0 <= B(l)),
              p.bubbleLegend.visible !== l &&
                (p.update({ bubbleLegend: { enabled: l } }),
                (p.bubbleLegend.visible = l)),
              (this.visible = s));
          }
          function E(s, l) {
            const p = s.options.rtl;
            let g,
              T,
              D,
              A,
              m = 0;
            s.allItems.forEach((f, b) => {
              (A = f.legendItem || {}),
                A.group &&
                  ((g = A.group.translateX || 0),
                  (T = A.y || 0),
                  ((D = f.movementX) || (p && f.ranges)) &&
                    ((D = p ? g - f.options.maxSize / 2 : g + D),
                    A.group.attr({ translateX: D })),
                  b > l[m].step && m++,
                  A.group.attr({ translateY: Math.round(T + l[m].height / 2) }),
                  (A.y = T + l[m].height / 2));
            });
          }
          const { setOptions: z } = d,
            { addEvent: S, objectEach: x, wrap: P } = M,
            h = [];
          return {
            compose: function (s, l, p) {
              M.pushUnique(h, s) &&
                (z({ legend: { bubbleLegend: i } }),
                P(s.prototype, "drawChartBox", O)),
                M.pushUnique(h, l) && S(l, "afterGetAllItems", Y),
                M.pushUnique(h, p) && S(p, "legendItemClick", L);
            },
          };
        }
      ),
      n(
        e,
        "Series/Bubble/BubblePoint.js",
        [
          e["Core/Series/Point.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          ({
            seriesTypes: {
              scatter: {
                prototype: { pointClass: a },
              },
            },
          } = a),
            ({ extend: d } = d);
          class M extends a {
            constructor() {
              super(...arguments), (this.series = this.options = void 0);
            }
            haloPath(B) {
              return i.prototype.haloPath.call(
                this,
                B === 0 ? 0 : ((this.marker && this.marker.radius) || 0) + B
              );
            }
          }
          return d(M.prototype, { ttBelow: !1 }), M;
        }
      ),
      n(
        e,
        "Series/Bubble/BubbleSeries.js",
        [
          e["Series/Bubble/BubbleLegendComposition.js"],
          e["Series/Bubble/BubblePoint.js"],
          e["Core/Color/Color.js"],
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B) {
          function G() {
            const A = this.len,
              m = this.chart,
              f = this.isXAxis,
              b = f ? "xData" : "yData",
              y = this.min,
              C = this.max - y;
            let o = 0,
              r = A,
              c = A / C,
              u;
            this.series.forEach((v) => {
              if (
                v.bubblePadding &&
                (v.visible || !m.options.chart.ignoreHiddenSeries)
              ) {
                u = this.allowZoomOutside = !0;
                const N = v[b];
                if (
                  (f &&
                    ((v.onPoint || v).getRadii(0, 0, v),
                    v.onPoint && (v.radii = v.onPoint.radii)),
                  0 < C)
                ) {
                  let w = N.length;
                  for (; w--; )
                    if (l(N[w]) && this.dataMin <= N[w] && N[w] <= this.max) {
                      const R = (v.radii && v.radii[w]) || 0;
                      (o = Math.min((N[w] - y) * c - R, o)),
                        (r = Math.max((N[w] - y) * c + R, r));
                    }
                }
              }
            }),
              u &&
                0 < C &&
                !this.logarithmic &&
                ((r -= A),
                (c *= (A + Math.max(0, o) - Math.min(r, A)) / A),
                [
                  ["min", "userMin", o],
                  ["max", "userMax", r],
                ].forEach((v) => {
                  typeof g(this.options[v[0]], this[v[1]]) > "u" &&
                    (this[v[0]] += v[2] / c);
                }));
          }
          const { parse: Y } = d;
          ({ noop: d } = M);
          const {
              series: L,
              seriesTypes: {
                column: { prototype: E },
                scatter: z,
              },
            } = O,
            {
              addEvent: S,
              arrayMax: x,
              arrayMin: P,
              clamp: h,
              extend: s,
              isNumber: l,
              merge: p,
              pick: g,
            } = B,
            T = [];
          class D extends z {
            constructor() {
              super(...arguments),
                (this.zData =
                  this.yData =
                  this.radii =
                  this.points =
                  this.options =
                  this.minPxSize =
                  this.maxPxSize =
                  this.data =
                    void 0);
            }
            static compose(m, f, b, y) {
              i.compose(f, b, y),
                B.pushUnique(T, m) && (m.prototype.beforePadding = G);
            }
            animate(m) {
              !m &&
                this.points.length < this.options.animationLimit &&
                this.points.forEach(function (f) {
                  const { graphic: b } = f;
                  b &&
                    b.width &&
                    (this.hasRendered ||
                      b.attr({ x: f.plotX, y: f.plotY, width: 1, height: 1 }),
                    b.animate(this.markerAttribs(f), this.options.animation));
                }, this);
            }
            getRadii() {
              const m = this.zData,
                f = this.yData,
                b = [];
              let y,
                C,
                o,
                r = this.chart.bubbleZExtremes;
              const { minPxSize: c, maxPxSize: u } = this.getPxExtremes();
              if (!r) {
                let v = Number.MAX_VALUE,
                  N = -Number.MAX_VALUE,
                  w;
                this.chart.series.forEach((R) => {
                  R.bubblePadding &&
                    (R.visible ||
                      !this.chart.options.chart.ignoreHiddenSeries) &&
                    (R = (R.onPoint || R).getZExtremes()) &&
                    ((v = Math.min(g(v, R.zMin), R.zMin)),
                    (N = Math.max(g(N, R.zMax), R.zMax)),
                    (w = !0));
                }),
                  w
                    ? ((r = { zMin: v, zMax: N }),
                      (this.chart.bubbleZExtremes = r))
                    : (r = { zMin: 0, zMax: 0 });
              }
              for (C = 0, y = m.length; C < y; C++)
                (o = m[C]),
                  b.push(this.getRadius(r.zMin, r.zMax, c, u, o, f && f[C]));
              this.radii = b;
            }
            getRadius(m, f, b, y, C, o) {
              const r = this.options,
                c = r.sizeBy !== "width",
                u = r.zThreshold;
              let v = f - m,
                N = 0.5;
              if (o === null || C === null) return null;
              if (l(C)) {
                if (
                  (r.sizeByAbsoluteValue &&
                    ((C = Math.abs(C - u)),
                    (v = Math.max(f - u, Math.abs(m - u))),
                    (m = 0)),
                  C < m)
                )
                  return b / 2 - 1;
                0 < v && (N = (C - m) / v);
              }
              return (
                c && 0 <= N && (N = Math.sqrt(N)),
                Math.ceil(b + N * (y - b)) / 2
              );
            }
            hasData() {
              return !!this.processedXData.length;
            }
            pointAttribs(m, f) {
              const b = this.options.marker.fillOpacity;
              return (
                (m = L.prototype.pointAttribs.call(this, m, f)),
                b !== 1 && (m.fill = Y(m.fill).setOpacity(b).get("rgba")),
                m
              );
            }
            translate() {
              super.translate.call(this),
                this.getRadii(),
                this.translateBubble();
            }
            translateBubble() {
              const { data: m, options: f, radii: b } = this,
                { minPxSize: y } = this.getPxExtremes();
              let C = m.length;
              for (; C--; ) {
                const o = m[C],
                  r = b ? b[C] : 0;
                this.zoneAxis === "z" &&
                  (o.negative = (o.z || 0) < (f.zThreshold || 0)),
                  l(r) && r >= y / 2
                    ? ((o.marker = s(o.marker, {
                        radius: r,
                        width: 2 * r,
                        height: 2 * r,
                      })),
                      (o.dlBox = {
                        x: o.plotX - r,
                        y: o.plotY - r,
                        width: 2 * r,
                        height: 2 * r,
                      }))
                    : ((o.shapeArgs = o.plotY = o.dlBox = void 0),
                      (o.isInside = !1));
              }
            }
            getPxExtremes() {
              const m = Math.min(this.chart.plotWidth, this.chart.plotHeight);
              var f = (y) => {
                let C;
                return (
                  typeof y == "string" &&
                    ((C = /%$/.test(y)), (y = parseInt(y, 10))),
                  C ? (m * y) / 100 : y
                );
              };
              const b = f(g(this.options.minSize, 8));
              return (
                (f = Math.max(f(g(this.options.maxSize, "20%")), b)),
                { minPxSize: b, maxPxSize: f }
              );
            }
            getZExtremes() {
              var m = this.options;
              const f = (this.zData || []).filter(l);
              if (f.length) {
                const b = g(
                  m.zMin,
                  h(
                    P(f),
                    m.displayNegative === !1
                      ? m.zThreshold || 0
                      : -Number.MAX_VALUE,
                    Number.MAX_VALUE
                  )
                );
                if (((m = g(m.zMax, x(f))), l(b) && l(m)))
                  return { zMin: b, zMax: m };
              }
            }
          }
          return (
            (D.defaultOptions = p(z.defaultOptions, {
              dataLabels: {
                formatter: function () {
                  const { numberFormatter: A } = this.series.chart,
                    { z: m } = this.point;
                  return l(m) ? A(m, -1) : "";
                },
                inside: !0,
                verticalAlign: "middle",
              },
              animationLimit: 250,
              marker: {
                lineColor: null,
                lineWidth: 1,
                fillOpacity: 0.5,
                radius: null,
                states: { hover: { radiusPlus: 0 } },
                symbol: "circle",
              },
              minSize: 8,
              maxSize: "20%",
              softThreshold: !1,
              states: { hover: { halo: { size: 5 } } },
              tooltip: {
                pointFormat: "({point.x}, {point.y}), Size: {point.z}",
              },
              turboThreshold: 0,
              zThreshold: 0,
              zoneAxis: "z",
            })),
            s(D.prototype, {
              alignDataLabel: E.alignDataLabel,
              applyZones: d,
              bubblePadding: !0,
              buildKDTree: d,
              directTouch: !0,
              isBubble: !0,
              pointArrayMap: ["y", "z"],
              pointClass: a,
              parallelArrays: ["x", "y", "z"],
              trackerGroups: ["group", "dataLabelsGroup"],
              specialGroup: "group",
              zoneAxis: "z",
            }),
            S(D, "updatedData", (A) => {
              delete A.target.chart.bubbleZExtremes;
            }),
            S(D, "remove", (A) => {
              delete A.target.chart.bubbleZExtremes;
            }),
            O.registerSeriesType("bubble", D),
            D
          );
        }
      ),
      n(
        e,
        "Series/ColumnRange/ColumnRangePoint.js",
        [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const {
              seriesTypes: {
                column: {
                  prototype: {
                    pointClass: { prototype: d },
                  },
                },
                arearange: {
                  prototype: { pointClass: M },
                },
              },
            } = i,
            { extend: O, isNumber: B } = a;
          class G extends M {
            constructor() {
              super(...arguments), (this.series = this.options = void 0);
            }
            isValid() {
              return B(this.low);
            }
          }
          return O(G.prototype, { setState: d.setState }), G;
        }
      ),
      n(
        e,
        "Series/ColumnRange/ColumnRangeSeries.js",
        [
          e["Series/ColumnRange/ColumnRangePoint.js"],
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          ({ noop: a } = a);
          const {
              seriesTypes: {
                arearange: O,
                column: B,
                column: { prototype: G },
              },
            } = d,
            {
              addEvent: Y,
              clamp: L,
              extend: E,
              isNumber: z,
              merge: S,
              pick: x,
            } = M;
          class P extends O {
            setOptions() {
              return (
                S(!0, arguments[0], { stacking: void 0 }),
                O.prototype.setOptions.apply(this, arguments)
              );
            }
            translate() {
              return G.translate.apply(this);
            }
            pointAttribs() {
              return G.pointAttribs.apply(this, arguments);
            }
            translate3dPoints() {
              return G.translate3dPoints.apply(this, arguments);
            }
            translate3dShapes() {
              return G.translate3dShapes.apply(this, arguments);
            }
            afterColumnTranslate() {
              const s = this.yAxis,
                l = this.xAxis,
                p = l.startAngleRad,
                g = this.chart,
                T = this.xAxis.isRadial,
                D = Math.max(g.chartWidth, g.chartHeight) + 999;
              let A, m, f, b;
              this.points.forEach((y) => {
                const C = y.shapeArgs || {},
                  o = this.options.minPointLength,
                  r = y.plotY,
                  c = s.translate(y.high, 0, 1, 0, 1);
                if (z(c) && z(r))
                  if (
                    ((y.plotHigh = L(c, -D, D)),
                    (y.plotLow = L(r, -D, D)),
                    (b = y.plotHigh),
                    (A = x(y.rectPlotY, y.plotY) - y.plotHigh),
                    Math.abs(A) < o
                      ? ((m = o - A), (A += m), (b -= m / 2))
                      : 0 > A && ((A *= -1), (b -= A)),
                    T && this.polar)
                  )
                    (f = y.barX + p),
                      (y.shapeType = "arc"),
                      (y.shapeArgs = this.polar.arc(
                        b + A,
                        b,
                        f,
                        f + y.pointWidth
                      ));
                  else {
                    (C.height = A), (C.y = b);
                    const { x: u = 0, width: v = 0 } = C;
                    (y.shapeArgs = S(y.shapeArgs, this.crispCol(u, b, v, A))),
                      (y.tooltipPos = g.inverted
                        ? [
                            s.len + s.pos - g.plotLeft - b - A / 2,
                            l.len + l.pos - g.plotTop - u - v / 2,
                            A,
                          ]
                        : [
                            l.left - g.plotLeft + u + v / 2,
                            s.pos - g.plotTop + b + A / 2,
                            A,
                          ]);
                  }
              });
            }
          }
          return (
            (P.defaultOptions = S(B.defaultOptions, O.defaultOptions, {
              borderRadius: { where: "all" },
              pointRange: null,
              marker: null,
              states: { hover: { halo: !1 } },
            })),
            Y(
              P,
              "afterColumnTranslate",
              function () {
                P.prototype.afterColumnTranslate.apply(this);
              },
              { order: 5 }
            ),
            E(P.prototype, {
              directTouch: !0,
              pointClass: i,
              trackerGroups: ["group", "dataLabelsGroup"],
              adjustForMissingColumns: G.adjustForMissingColumns,
              animate: G.animate,
              crispCol: G.crispCol,
              drawGraph: a,
              drawPoints: G.drawPoints,
              getSymbol: a,
              drawTracker: G.drawTracker,
              getColumnMetrics: G.getColumnMetrics,
            }),
            d.registerSeriesType("columnrange", P),
            P
          );
        }
      ),
      n(
        e,
        "Series/ColumnPyramid/ColumnPyramidSeries.js",
        [
          e["Series/Column/ColumnSeries.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          const { prototype: M } = i,
            { clamp: O, merge: B, pick: G } = d;
          class Y extends i {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            translate() {
              let E = this,
                z = E.chart,
                S = E.options;
              var x = (E.dense = 2 > E.closestPointRange * E.xAxis.transA);
              x = E.borderWidth = G(S.borderWidth, x ? 0 : 1);
              let P = E.yAxis,
                h = S.threshold,
                s = (E.translatedThreshold = P.getThreshold(h)),
                l = G(S.minPointLength, 5),
                p = E.getColumnMetrics(),
                g = p.width,
                T = (E.barW = Math.max(g, 1 + 2 * x)),
                D = (E.pointXOffset = p.offset);
              z.inverted && (s -= 0.5),
                S.pointPadding && (T = Math.ceil(T)),
                M.translate.apply(E),
                E.points.forEach(function (A) {
                  var m = G(A.yBottom, s),
                    f = 999 + Math.abs(m),
                    b = O(A.plotY, -f, P.len + f);
                  f = A.plotX + D;
                  let y = T / 2,
                    C = Math.min(b, m);
                  m = Math.max(b, m) - C;
                  var o;
                  let r, c;
                  (A.barX = f),
                    (A.pointWidth = g),
                    (A.tooltipPos = z.inverted
                      ? [P.len + P.pos - z.plotLeft - b, E.xAxis.len - f - y, m]
                      : [f + y, b + P.pos - z.plotTop, m]),
                    (b = h + (A.total || A.y)),
                    S.stacking === "percent" &&
                      (b = h + (0 > A.y) ? -100 : 100),
                    (b = P.toPixels(b, !0));
                  var u = (o = z.plotHeight - b - (z.plotHeight - s))
                      ? (y * (C - b)) / o
                      : 0,
                    v = o ? (y * (C + m - b)) / o : 0;
                  (o = f - u + y), (u = f + u + y);
                  var N = f + v + y;
                  (v = f - v + y),
                    (r = C - l),
                    (c = C + m),
                    0 > A.y && ((r = C), (c = C + m + l)),
                    z.inverted &&
                      ((N = P.width - C),
                      (o = b - (P.width - s)),
                      (u = (y * (b - N)) / o),
                      (v = (y * (b - (N - m))) / o),
                      (o = f + y + u),
                      (u = o - 2 * u),
                      (N = f - v + y),
                      (v = f + v + y),
                      (r = C),
                      (c = C + m - l),
                      0 > A.y && (c = C + m + l)),
                    (A.shapeType = "path"),
                    (A.shapeArgs = {
                      x: o,
                      y: r,
                      width: u - o,
                      height: m,
                      d: [
                        ["M", o, r],
                        ["L", u, r],
                        ["L", N, c],
                        ["L", v, c],
                        ["Z"],
                      ],
                    });
                });
            }
          }
          return (
            (Y.defaultOptions = B(i.defaultOptions, {})),
            a.registerSeriesType("columnpyramid", Y),
            Y
          );
        }
      ),
      n(e, "Series/ErrorBar/ErrorBarSeriesDefaults.js", [], function () {
        return {
          color: "#000000",
          grouping: !1,
          linkedTo: ":previous",
          tooltip: {
            pointFormat:
              '<span style="color:{point.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>',
          },
          whiskerWidth: null,
        };
      }),
      n(
        e,
        "Series/ErrorBar/ErrorBarSeries.js",
        [
          e["Series/BoxPlot/BoxPlotSeries.js"],
          e["Series/Column/ColumnSeries.js"],
          e["Series/ErrorBar/ErrorBarSeriesDefaults.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          const { arearange: B } = M.seriesTypes,
            { addEvent: G, merge: Y, extend: L } = O;
          class E extends i {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            getColumnMetrics() {
              return (
                (this.linkedParent && this.linkedParent.columnMetrics) ||
                a.prototype.getColumnMetrics.call(this)
              );
            }
            drawDataLabels() {
              const S = this.pointValKey;
              B &&
                (B.prototype.drawDataLabels.call(this),
                this.data.forEach(function (x) {
                  x.y = x[S];
                }));
            }
            toYData(S) {
              return [S.low, S.high];
            }
          }
          return (
            (E.defaultOptions = Y(i.defaultOptions, d)),
            G(
              E,
              "afterTranslate",
              function () {
                this.points.forEach((z) => {
                  z.plotLow = z.plotY;
                });
              },
              { order: 0 }
            ),
            L(E.prototype, {
              pointArrayMap: ["low", "high"],
              pointValKey: "high",
              doQuartiles: !1,
            }),
            M.registerSeriesType("errorbar", E),
            E
          );
        }
      ),
      n(
        e,
        "Series/Gauge/GaugePoint.js",
        [e["Core/Series/SeriesRegistry.js"]],
        function (i) {
          ({
            series: {
              prototype: { pointClass: i },
            },
          } = i);
          class a extends i {
            constructor() {
              super(...arguments),
                (this.shapeArgs = this.series = this.options = void 0);
            }
            setState(M) {
              this.state = M;
            }
          }
          return a;
        }
      ),
      n(
        e,
        "Series/Gauge/GaugeSeries.js",
        [
          e["Series/Gauge/GaugePoint.js"],
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          ({ noop: a } = a);
          const {
              series: O,
              seriesTypes: { column: B },
            } = d,
            {
              clamp: G,
              isNumber: Y,
              extend: L,
              merge: E,
              pick: z,
              pInt: S,
              defined: x,
            } = M;
          class P extends O {
            constructor() {
              super(...arguments),
                (this.yAxis = this.options = this.points = this.data = void 0);
            }
            translate() {
              const s = this.yAxis,
                l = this.options,
                p = s.center;
              this.generatePoints(),
                this.points.forEach((g) => {
                  const T = E(l.dial, g.dial),
                    D = (S(T.radius) * p[2]) / 200,
                    A = (S(T.baseLength) * D) / 100,
                    m = (S(T.rearLength) * D) / 100,
                    f = T.baseWidth,
                    b = T.topWidth;
                  let y = l.overshoot,
                    C =
                      s.startAngleRad +
                      s.translate(g.y, void 0, void 0, void 0, !0);
                  (Y(y) || l.wrap === !1) &&
                    ((y = Y(y) ? (y / 180) * Math.PI : 0),
                    (C = G(C, s.startAngleRad - y, s.endAngleRad + y))),
                    (C = (180 * C) / Math.PI),
                    (g.shapeType = "path"),
                    (g.shapeArgs = {
                      d: T.path || [
                        ["M", -m, -f / 2],
                        ["L", A, -f / 2],
                        ["L", D, -b / 2],
                        ["L", D, b / 2],
                        ["L", A, f / 2],
                        ["L", -m, f / 2],
                        ["Z"],
                      ],
                      translateX: p[0],
                      translateY: p[1],
                      rotation: C,
                    }),
                    (g.plotX = p[0]),
                    (g.plotY = p[1]),
                    x(g.y) &&
                      s.max - s.min &&
                      (g.percentage = ((g.y - s.min) / (s.max - s.min)) * 100);
                });
            }
            drawPoints() {
              const s = this,
                l = s.chart,
                p = s.yAxis.center,
                g = s.pivot,
                T = s.options,
                D = T.pivot,
                A = l.renderer;
              s.points.forEach((m) => {
                const f = m.graphic,
                  b = m.shapeArgs,
                  y = b.d,
                  C = E(T.dial, m.dial);
                f
                  ? (f.animate(b), (b.d = y))
                  : (m.graphic = A[m.shapeType](b)
                      .addClass("highcharts-dial")
                      .add(s.group)),
                  l.styledMode ||
                    m.graphic[f ? "animate" : "attr"]({
                      stroke: C.borderColor,
                      "stroke-width": C.borderWidth,
                      fill: C.backgroundColor,
                    });
              }),
                g
                  ? g.animate({ translateX: p[0], translateY: p[1] })
                  : D &&
                    ((s.pivot = A.circle(0, 0, D.radius)
                      .attr({ zIndex: 2 })
                      .addClass("highcharts-pivot")
                      .translate(p[0], p[1])
                      .add(s.group)),
                    l.styledMode ||
                      s.pivot.attr({
                        fill: D.backgroundColor,
                        stroke: D.borderColor,
                        "stroke-width": D.borderWidth,
                      }));
            }
            animate(s) {
              const l = this;
              s ||
                l.points.forEach((p) => {
                  const g = p.graphic;
                  g &&
                    (g.attr({
                      rotation: (180 * l.yAxis.startAngleRad) / Math.PI,
                    }),
                    g.animate(
                      { rotation: p.shapeArgs.rotation },
                      l.options.animation
                    ));
                });
            }
            render() {
              (this.group = this.plotGroup(
                "group",
                "series",
                this.visible ? "inherit" : "hidden",
                this.options.zIndex,
                this.chart.seriesGroup
              )),
                O.prototype.render.call(this),
                this.group.clip(this.chart.clipRect);
            }
            setData(s, l) {
              O.prototype.setData.call(this, s, !1),
                this.processData(),
                this.generatePoints(),
                z(l, !0) && this.chart.redraw();
            }
            hasData() {
              return !!this.points.length;
            }
          }
          return (
            (P.defaultOptions = E(O.defaultOptions, {
              dataLabels: {
                borderColor: "#cccccc",
                borderRadius: 3,
                borderWidth: 1,
                crop: !1,
                defer: !1,
                enabled: !0,
                verticalAlign: "top",
                y: 15,
                zIndex: 2,
              },
              dial: {
                backgroundColor: "#000000",
                baseLength: "70%",
                baseWidth: 3,
                borderColor: "#cccccc",
                borderWidth: 0,
                radius: "80%",
                rearLength: "10%",
                topWidth: 1,
              },
              pivot: {
                radius: 5,
                borderWidth: 0,
                borderColor: "#cccccc",
                backgroundColor: "#000000",
              },
              tooltip: { headerFormat: "" },
              showInLegend: !1,
            })),
            L(P.prototype, {
              angular: !0,
              directTouch: !0,
              drawGraph: a,
              drawTracker: B.prototype.drawTracker,
              fixedBox: !0,
              forceDL: !0,
              noSharedTooltip: !0,
              pointClass: i,
              trackerGroups: ["group", "dataLabelsGroup"],
            }),
            d.registerSeriesType("gauge", P),
            P
          );
        }
      ),
      n(
        e,
        "Series/DragNodesComposition.js",
        [e["Core/Utilities.js"]],
        function (i) {
          function a() {
            const O = this;
            let B, G, Y;
            O.container &&
              (B = d(O.container, "mousedown", (L) => {
                const E = O.hoverPoint;
                E &&
                  E.series &&
                  E.series.hasDraggableNodes &&
                  E.series.options.draggable &&
                  (E.series.onMouseDown(E, L),
                  (G = d(
                    O.container,
                    "mousemove",
                    (z) => E && E.series && E.series.onMouseMove(E, z)
                  )),
                  (Y = d(
                    O.container.ownerDocument,
                    "mouseup",
                    (z) => (G(), Y(), E && E.series && E.series.onMouseUp(E, z))
                  )));
              })),
              d(O, "destroy", function () {
                B();
              });
          }
          const { addEvent: d } = i,
            M = [];
          return {
            compose: function (O) {
              i.pushUnique(M, O) && d(O, "load", a);
            },
            onMouseDown: function (O, B) {
              (B = this.chart.pointer.normalize(B)),
                (O.fixedPosition = {
                  chartX: B.chartX,
                  chartY: B.chartY,
                  plotX: O.plotX,
                  plotY: O.plotY,
                }),
                (O.inDragMode = !0);
            },
            onMouseMove: function (O, B) {
              if (O.fixedPosition && O.inDragMode) {
                const L = this.chart;
                B = L.pointer.normalize(B);
                var G = O.fixedPosition.chartX - B.chartX,
                  Y = O.fixedPosition.chartY - B.chartY;
                (B = L.graphLayoutsLookup),
                  (5 < Math.abs(G) || 5 < Math.abs(Y)) &&
                    ((G = O.fixedPosition.plotX - G),
                    (Y = O.fixedPosition.plotY - Y),
                    L.isInsidePlot(G, Y) &&
                      ((O.plotX = G),
                      (O.plotY = Y),
                      (O.hasDragged = !0),
                      this.redrawHalo(O),
                      B.forEach((E) => {
                        E.restartSimulation();
                      })));
              }
            },
            onMouseUp: function (O, B) {
              O.fixedPosition &&
                (O.hasDragged &&
                  (this.layout.enableSimulation
                    ? this.layout.start()
                    : this.chart.redraw()),
                (O.inDragMode = O.hasDragged = !1),
                this.options.fixedDraggable || delete O.fixedPosition);
            },
            redrawHalo: function (O) {
              O &&
                this.halo &&
                this.halo.attr({
                  d: O.haloPath(this.options.states.hover.halo.size),
                });
            },
          };
        }
      ),
      n(
        e,
        "Series/GraphLayoutComposition.js",
        [e["Core/Animation/AnimationUtilities.js"], e["Core/Utilities.js"]],
        function (i, a) {
          function d() {
            this.graphLayoutsLookup &&
              (this.graphLayoutsLookup.forEach((E) => {
                E.updateSimulation();
              }),
              this.redraw());
          }
          function M() {
            this.graphLayoutsLookup &&
              (this.graphLayoutsLookup.forEach((E) => {
                E.updateSimulation(!1);
              }),
              this.redraw());
          }
          function O() {
            this.graphLayoutsLookup &&
              this.graphLayoutsLookup.forEach((E) => {
                E.stop();
              });
          }
          function B() {
            let E,
              z = !1;
            const S = (x) => {
              x.maxIterations-- &&
                isFinite(x.temperature) &&
                !x.isStable() &&
                !x.enableSimulation &&
                (x.beforeStep && x.beforeStep(), x.step(), (E = !1), (z = !0));
            };
            if (this.graphLayoutsLookup) {
              for (
                G(!1, this), this.graphLayoutsLookup.forEach((x) => x.start());
                !E;

              )
                (E = !0), this.graphLayoutsLookup.forEach(S);
              z &&
                this.series.forEach((x) => {
                  x && x.layout && x.render();
                });
            }
          }
          const { setAnimation: G } = i,
            { addEvent: Y } = a,
            L = [];
          return {
            compose: function (E) {
              a.pushUnique(L, E) &&
                (Y(E, "afterPrint", d),
                Y(E, "beforePrint", M),
                Y(E, "predraw", O),
                Y(E, "render", B));
            },
            integrations: {},
            layouts: {},
          };
        }
      ),
      n(
        e,
        "Series/PackedBubble/PackedBubblePoint.js",
        [
          e["Core/Chart/Chart.js"],
          e["Core/Series/Point.js"],
          e["Core/Series/SeriesRegistry.js"],
        ],
        function (i, a, d) {
          ({
            seriesTypes: {
              bubble: {
                prototype: { pointClass: d },
              },
            },
          } = d);
          class M extends d {
            constructor() {
              super(...arguments),
                (this.radius = this.mass = this.degree = NaN),
                (this.series = this.options = void 0),
                (this.value = null);
            }
            destroy() {
              return (
                this.series.layout &&
                  this.series.layout.removeElementFromCollection(
                    this,
                    this.series.layout.nodes
                  ),
                a.prototype.destroy.apply(this, arguments)
              );
            }
            firePointEvent() {
              const B = this.series.options;
              if (this.isParentNode && B.parentNode) {
                const G = B.allowPointSelect;
                (B.allowPointSelect = B.parentNode.allowPointSelect),
                  a.prototype.firePointEvent.apply(this, arguments),
                  (B.allowPointSelect = G);
              } else a.prototype.firePointEvent.apply(this, arguments);
            }
            select() {
              const B = this.series.chart;
              this.isParentNode
                ? ((B.getSelectedPoints = B.getSelectedParentNodes),
                  a.prototype.select.apply(this, arguments),
                  (B.getSelectedPoints = i.prototype.getSelectedPoints))
                : a.prototype.select.apply(this, arguments);
            }
          }
          return M;
        }
      ),
      n(
        e,
        "Series/PackedBubble/PackedBubbleSeriesDefaults.js",
        [e["Core/Utilities.js"]],
        function (i) {
          const { isNumber: a } = i;
          return {
            minSize: "10%",
            maxSize: "50%",
            sizeBy: "area",
            zoneAxis: "y",
            crisp: !1,
            tooltip: { pointFormat: "Value: {point.value}" },
            draggable: !0,
            useSimulation: !0,
            parentNode: { allowPointSelect: !1 },
            dataLabels: {
              formatter: function () {
                const { numberFormatter: d } = this.series.chart,
                  { value: M } = this.point;
                return a(M) ? d(M, -1) : "";
              },
              parentNodeFormatter: function () {
                return this.name;
              },
              parentNodeTextPath: { enabled: !0 },
              padding: 0,
              style: { transition: "opacity 2000ms" },
            },
            layoutAlgorithm: {
              initialPositions: "circle",
              initialPositionRadius: 20,
              bubblePadding: 5,
              parentNodeLimit: !1,
              seriesInteraction: !0,
              dragBetweenSeries: !1,
              parentNodeOptions: {
                maxIterations: 400,
                gravitationalConstant: 0.03,
                maxSpeed: 50,
                initialPositionRadius: 100,
                seriesInteraction: !0,
                marker: {
                  fillColor: null,
                  fillOpacity: 1,
                  lineWidth: null,
                  lineColor: null,
                  symbol: "circle",
                },
              },
              enableSimulation: !0,
              type: "packedbubble",
              integration: "packedbubble",
              maxIterations: 1e3,
              splitSeries: !1,
              maxSpeed: 5,
              gravitationalConstant: 0.01,
              friction: -0.981,
            },
          };
        }
      ),
      n(e, "Series/Networkgraph/VerletIntegration.js", [], function () {
        return {
          attractive: function (i, a, d) {
            const M = i.getMass(),
              O = -d.x * a * this.diffTemperature;
            (a = -d.y * a * this.diffTemperature),
              i.fromNode.fixedPosition ||
                ((i.fromNode.plotX -= (O * M.fromNode) / i.fromNode.degree),
                (i.fromNode.plotY -= (a * M.fromNode) / i.fromNode.degree)),
              i.toNode.fixedPosition ||
                ((i.toNode.plotX += (O * M.toNode) / i.toNode.degree),
                (i.toNode.plotY += (a * M.toNode) / i.toNode.degree));
          },
          attractiveForceFunction: function (i, a) {
            return (a - i) / i;
          },
          barycenter: function () {
            let i = this.options.gravitationalConstant,
              a = this.barycenter.xFactor,
              d = this.barycenter.yFactor;
            (a = (a - (this.box.left + this.box.width) / 2) * i),
              (d = (d - (this.box.top + this.box.height) / 2) * i),
              this.nodes.forEach(function (M) {
                M.fixedPosition ||
                  ((M.plotX -= a / M.mass / M.degree),
                  (M.plotY -= d / M.mass / M.degree));
              });
          },
          getK: function (i) {
            return Math.pow((i.box.width * i.box.height) / i.nodes.length, 0.5);
          },
          integrate: function (i, a) {
            var d = -i.options.friction;
            let M = i.options.maxSpeed,
              O = (a.plotX + a.dispX - a.prevX) * d;
            d *= a.plotY + a.dispY - a.prevY;
            var B = Math.abs;
            let G = B(O) / (O || 1);
            (B = B(d) / (d || 1)),
              (O = G * Math.min(M, Math.abs(O))),
              (d = B * Math.min(M, Math.abs(d))),
              (a.prevX = a.plotX + a.dispX),
              (a.prevY = a.plotY + a.dispY),
              (a.plotX += O),
              (a.plotY += d),
              (a.temperature = i.vectorLength({ x: O, y: d }));
          },
          repulsive: function (i, a, d) {
            (a = (a * this.diffTemperature) / i.mass / i.degree),
              i.fixedPosition || ((i.plotX += d.x * a), (i.plotY += d.y * a));
          },
          repulsiveForceFunction: function (i, a) {
            return ((a - i) / i) * (a > i ? 1 : 0);
          },
        };
      }),
      n(
        e,
        "Series/PackedBubble/PackedBubbleIntegration.js",
        [e["Core/Globals.js"], e["Series/Networkgraph/VerletIntegration.js"]],
        function (i, a) {
          return (
            ({ noop: i } = i),
            {
              barycenter: function () {
                const d = this.options.gravitationalConstant,
                  M = this.box,
                  O = this.nodes;
                let B, G;
                for (const Y of O)
                  this.options.splitSeries && !Y.isParentNode
                    ? ((B = Y.series.parentNode.plotX),
                      (G = Y.series.parentNode.plotY))
                    : ((B = M.width / 2), (G = M.height / 2)),
                    Y.fixedPosition ||
                      ((Y.plotX -=
                        ((Y.plotX - B) * d) / (Y.mass * Math.sqrt(O.length))),
                      (Y.plotY -=
                        ((Y.plotY - G) * d) / (Y.mass * Math.sqrt(O.length))));
              },
              getK: i,
              integrate: a.integrate,
              repulsive: function (d, M, O, B) {
                const G = (M * this.diffTemperature) / d.mass / d.degree;
                (M = O.x * G),
                  (O = O.y * G),
                  d.fixedPosition || ((d.plotX += M), (d.plotY += O)),
                  B.fixedPosition || ((B.plotX -= M), (B.plotY -= O));
              },
              repulsiveForceFunction: function (d, M, O, B) {
                return Math.min(d, (O.marker.radius + B.marker.radius) / 2);
              },
            }
          );
        }
      ),
      n(e, "Series/Networkgraph/EulerIntegration.js", [], function () {
        return {
          attractive: function (i, a, d, M) {
            const O = i.getMass(),
              B = (d.x / M) * a;
            (a *= d.y / M),
              i.fromNode.fixedPosition ||
                ((i.fromNode.dispX -= (B * O.fromNode) / i.fromNode.degree),
                (i.fromNode.dispY -= (a * O.fromNode) / i.fromNode.degree)),
              i.toNode.fixedPosition ||
                ((i.toNode.dispX += (B * O.toNode) / i.toNode.degree),
                (i.toNode.dispY += (a * O.toNode) / i.toNode.degree));
          },
          attractiveForceFunction: function (i, a) {
            return (i * i) / a;
          },
          barycenter: function () {
            const i = this.options.gravitationalConstant,
              a = this.barycenter.xFactor,
              d = this.barycenter.yFactor;
            this.nodes.forEach(function (M) {
              if (!M.fixedPosition) {
                var O = M.getDegree();
                (O *= 1 + O / 2),
                  (M.dispX += ((a - M.plotX) * i * O) / M.degree),
                  (M.dispY += ((d - M.plotY) * i * O) / M.degree);
              }
            });
          },
          getK: function (i) {
            return Math.pow((i.box.width * i.box.height) / i.nodes.length, 0.3);
          },
          integrate: function (i, a) {
            let d;
            (a.dispX += a.dispX * i.options.friction),
              (a.dispY += a.dispY * i.options.friction),
              (d = a.temperature = i.vectorLength({ x: a.dispX, y: a.dispY })),
              d !== 0 &&
                ((a.plotX +=
                  (a.dispX / d) * Math.min(Math.abs(a.dispX), i.temperature)),
                (a.plotY +=
                  (a.dispY / d) * Math.min(Math.abs(a.dispY), i.temperature)));
          },
          repulsive: function (i, a, d, M) {
            (i.dispX += ((d.x / M) * a) / i.degree),
              (i.dispY += ((d.y / M) * a) / i.degree);
          },
          repulsiveForceFunction: function (i, a) {
            return (a * a) / i;
          },
        };
      }),
      n(e, "Series/Networkgraph/QuadTreeNode.js", [], function () {
        class i {
          constructor(d) {
            (this.isInternal = this.isEmpty = this.body = !1),
              (this.nodes = []),
              (this.box = d),
              (this.boxSize = Math.min(d.width, d.height));
          }
          divideBox() {
            const d = this.box.width / 2,
              M = this.box.height / 2;
            (this.nodes[0] = new i({
              left: this.box.left,
              top: this.box.top,
              width: d,
              height: M,
            })),
              (this.nodes[1] = new i({
                left: this.box.left + d,
                top: this.box.top,
                width: d,
                height: M,
              })),
              (this.nodes[2] = new i({
                left: this.box.left + d,
                top: this.box.top + M,
                width: d,
                height: M,
              })),
              (this.nodes[3] = new i({
                left: this.box.left,
                top: this.box.top + M,
                width: d,
                height: M,
              }));
          }
          getBoxPosition(d) {
            const M = d.plotY < this.box.top + this.box.height / 2;
            return d.plotX < this.box.left + this.box.width / 2
              ? M
                ? 0
                : 3
              : M
              ? 1
              : 2;
          }
          insert(d, M) {
            this.isInternal
              ? this.nodes[this.getBoxPosition(d)].insert(d, M - 1)
              : ((this.isEmpty = !1),
                this.body
                  ? M
                    ? ((this.isInternal = !0),
                      this.divideBox(),
                      this.body !== !0 &&
                        (this.nodes[this.getBoxPosition(this.body)].insert(
                          this.body,
                          M - 1
                        ),
                        (this.body = !0)),
                      this.nodes[this.getBoxPosition(d)].insert(d, M - 1))
                    : ((M = new i({
                        top: d.plotX || NaN,
                        left: d.plotY || NaN,
                        width: 0.1,
                        height: 0.1,
                      })),
                      (M.body = d),
                      (M.isInternal = !1),
                      this.nodes.push(M))
                  : ((this.isInternal = !1), (this.body = d)));
          }
          updateMassAndCenter() {
            let d = 0,
              M = 0,
              O = 0;
            if (this.isInternal) {
              for (const B of this.nodes)
                B.isEmpty ||
                  ((d += B.mass),
                  (M += B.plotX * B.mass),
                  (O += B.plotY * B.mass));
              (M /= d), (O /= d);
            } else this.body && ((d = this.body.mass), (M = this.body.plotX), (O = this.body.plotY));
            (this.mass = d), (this.plotX = M), (this.plotY = O);
          }
        }
        return i;
      }),
      n(
        e,
        "Series/Networkgraph/QuadTree.js",
        [e["Series/Networkgraph/QuadTreeNode.js"]],
        function (i) {
          class a {
            constructor(M, O, B, G) {
              (this.box = { left: M, top: O, width: B, height: G }),
                (this.maxDepth = 25),
                (this.root = new i(this.box)),
                (this.root.isInternal = !0),
                (this.root.isRoot = !0),
                this.root.divideBox();
            }
            calculateMassAndCenter() {
              this.visitNodeRecursive(null, null, function (M) {
                M.updateMassAndCenter();
              });
            }
            insertNodes(M) {
              for (const O of M) this.root.insert(O, this.maxDepth);
            }
            visitNodeRecursive(M, O, B) {
              let G;
              if (
                (M || (M = this.root),
                M === this.root && O && (G = O(M)),
                G !== !1)
              ) {
                for (const Y of M.nodes) {
                  if (Y.isInternal) {
                    if ((O && (G = O(Y)), G === !1)) continue;
                    this.visitNodeRecursive(Y, O, B);
                  } else Y.body && O && O(Y.body);
                  B && B(Y);
                }
                M === this.root && B && B(M);
              }
            }
          }
          return a;
        }
      ),
      n(
        e,
        "Series/Networkgraph/ReingoldFruchtermanLayout.js",
        [
          e["Series/Networkgraph/EulerIntegration.js"],
          e["Core/Globals.js"],
          e["Series/GraphLayoutComposition.js"],
          e["Series/Networkgraph/QuadTree.js"],
          e["Core/Utilities.js"],
          e["Series/Networkgraph/VerletIntegration.js"],
        ],
        function (i, a, d, M, O, B) {
          const { win: G } = a,
            { clamp: Y, defined: L, isFunction: E, fireEvent: z, pick: S } = O;
          class x {
            constructor() {
              (this.attractiveForce = void 0),
                (this.box = {}),
                (this.currentStep = 0),
                (this.initialRendering = !0),
                (this.integration = void 0),
                (this.links = []),
                (this.nodes = []),
                (this.repulsiveForce = this.quadTree = this.options = void 0),
                (this.series = []),
                (this.simulation = !1);
            }
            static compose(h) {
              d.compose(h),
                (d.integrations.euler = i),
                (d.integrations.verlet = B),
                (d.layouts["reingold-fruchterman"] = x);
            }
            init(h) {
              (this.options = h),
                (this.nodes = []),
                (this.links = []),
                (this.series = []),
                (this.box = { x: 0, y: 0, width: 0, height: 0 }),
                this.setInitialRendering(!0),
                (this.integration = d.integrations[h.integration]),
                (this.enableSimulation = h.enableSimulation),
                (this.attractiveForce = S(
                  h.attractiveForce,
                  this.integration.attractiveForceFunction
                )),
                (this.repulsiveForce = S(
                  h.repulsiveForce,
                  this.integration.repulsiveForceFunction
                )),
                (this.approximation = h.approximation);
            }
            updateSimulation(h) {
              this.enableSimulation = S(h, this.options.enableSimulation);
            }
            start() {
              const h = this.series,
                s = this.options;
              (this.currentStep = 0),
                (this.forces = (h[0] && h[0].forces) || []),
                (this.chart = h[0] && h[0].chart),
                this.initialRendering &&
                  (this.initPositions(),
                  h.forEach(function (l) {
                    (l.finishedAnimating = !0), l.render();
                  })),
                this.setK(),
                this.resetSimulation(s),
                this.enableSimulation && this.step();
            }
            step() {
              const h = this.series;
              this.currentStep++,
                this.approximation === "barnes-hut" &&
                  (this.createQuadTree(),
                  this.quadTree.calculateMassAndCenter());
              for (const s of this.forces || [])
                this[s + "Forces"](this.temperature);
              if (
                (this.applyLimits(),
                (this.temperature = this.coolDown(
                  this.startTemperature,
                  this.diffTemperature,
                  this.currentStep
                )),
                (this.prevSystemTemperature = this.systemTemperature),
                (this.systemTemperature = this.getSystemTemperature()),
                this.enableSimulation)
              ) {
                for (const s of h) s.chart && s.render();
                this.maxIterations-- &&
                isFinite(this.temperature) &&
                !this.isStable()
                  ? (this.simulation && G.cancelAnimationFrame(this.simulation),
                    (this.simulation = G.requestAnimationFrame(() =>
                      this.step()
                    )))
                  : ((this.simulation = !1),
                    this.series.forEach((s) => {
                      z(s, "afterSimulation");
                    }));
              }
            }
            stop() {
              this.simulation && G.cancelAnimationFrame(this.simulation);
            }
            setArea(h, s, l, p) {
              this.box = { left: h, top: s, width: l, height: p };
            }
            setK() {
              this.k = this.options.linkLength || this.integration.getK(this);
            }
            addElementsToCollection(h, s) {
              for (const l of h) s.indexOf(l) === -1 && s.push(l);
            }
            removeElementFromCollection(h, s) {
              (h = s.indexOf(h)), h !== -1 && s.splice(h, 1);
            }
            clear() {
              (this.nodes.length = 0),
                (this.links.length = 0),
                (this.series.length = 0),
                this.resetSimulation();
            }
            resetSimulation() {
              (this.forcedStop = !1),
                (this.systemTemperature = 0),
                this.setMaxIterations(),
                this.setTemperature(),
                this.setDiffTemperature();
            }
            restartSimulation() {
              this.simulation
                ? this.resetSimulation()
                : (this.setInitialRendering(!1),
                  this.enableSimulation
                    ? this.start()
                    : this.setMaxIterations(1),
                  this.chart && this.chart.redraw(),
                  this.setInitialRendering(!0));
            }
            setMaxIterations(h) {
              this.maxIterations = S(h, this.options.maxIterations);
            }
            setTemperature() {
              this.temperature = this.startTemperature = Math.sqrt(
                this.nodes.length
              );
            }
            setDiffTemperature() {
              this.diffTemperature =
                this.startTemperature / (this.options.maxIterations + 1);
            }
            setInitialRendering(h) {
              this.initialRendering = h;
            }
            createQuadTree() {
              (this.quadTree = new M(
                this.box.left,
                this.box.top,
                this.box.width,
                this.box.height
              )),
                this.quadTree.insertNodes(this.nodes);
            }
            initPositions() {
              const h = this.options.initialPositions;
              if (E(h)) {
                h.call(this);
                for (const s of this.nodes)
                  L(s.prevX) || (s.prevX = s.plotX),
                    L(s.prevY) || (s.prevY = s.plotY),
                    (s.dispX = 0),
                    (s.dispY = 0);
              } else
                h === "circle"
                  ? this.setCircularPositions()
                  : this.setRandomPositions();
            }
            setCircularPositions() {
              const h = this.box;
              var s = this.nodes;
              const l = (2 * Math.PI) / (s.length + 1),
                p = s.filter(function (m) {
                  return m.linksTo.length === 0;
                }),
                g = {},
                T = this.options.initialPositionRadius,
                D = (m) => {
                  for (const f of m.linksFrom || [])
                    g[f.toNode.id] ||
                      ((g[f.toNode.id] = !0), A.push(f.toNode), D(f.toNode));
                };
              let A = [];
              for (const m of p) A.push(m), D(m);
              if (A.length) for (const m of s) A.indexOf(m) === -1 && A.push(m);
              else A = s;
              for (let m = 0, f = A.length; m < f; ++m)
                (s = A[m]),
                  (s.plotX = s.prevX =
                    S(s.plotX, h.width / 2 + T * Math.cos(m * l))),
                  (s.plotY = s.prevY =
                    S(s.plotY, h.height / 2 + T * Math.sin(m * l))),
                  (s.dispX = 0),
                  (s.dispY = 0);
            }
            setRandomPositions() {
              const h = this.box,
                s = this.nodes,
                l = s.length + 1,
                p = (T) => ((T = (T * T) / Math.PI), (T -= Math.floor(T)));
              let g;
              for (let T = 0, D = s.length; T < D; ++T)
                (g = s[T]),
                  (g.plotX = g.prevX = S(g.plotX, h.width * p(T))),
                  (g.plotY = g.prevY = S(g.plotY, h.height * p(l + T))),
                  (g.dispX = 0),
                  (g.dispY = 0);
            }
            force(h, ...s) {
              this.integration[h].apply(this, s);
            }
            barycenterForces() {
              this.getBarycenter(), this.force("barycenter");
            }
            getBarycenter() {
              let h = 0,
                s = 0,
                l = 0;
              for (const p of this.nodes)
                (s += p.plotX * p.mass), (l += p.plotY * p.mass), (h += p.mass);
              return (this.barycenter = {
                x: s,
                y: l,
                xFactor: s / h,
                yFactor: l / h,
              });
            }
            barnesHutApproximation(h, s) {
              const l = this.getDistXY(h, s),
                p = this.vectorLength(l);
              let g, T;
              return (
                h !== s &&
                  p !== 0 &&
                  (s.isInternal
                    ? s.boxSize / p < this.options.theta && p !== 0
                      ? ((T = this.repulsiveForce(p, this.k)),
                        this.force("repulsive", h, T * s.mass, l, p),
                        (g = !1))
                      : (g = !0)
                    : ((T = this.repulsiveForce(p, this.k)),
                      this.force("repulsive", h, T * s.mass, l, p))),
                g
              );
            }
            repulsiveForces() {
              if (this.approximation === "barnes-hut")
                for (const h of this.nodes)
                  this.quadTree.visitNodeRecursive(null, (s) =>
                    this.barnesHutApproximation(h, s)
                  );
              else {
                let h, s, l;
                for (const p of this.nodes)
                  for (const g of this.nodes)
                    p === g ||
                      p.fixedPosition ||
                      ((l = this.getDistXY(p, g)),
                      (s = this.vectorLength(l)),
                      s !== 0 &&
                        ((h = this.repulsiveForce(s, this.k)),
                        this.force("repulsive", p, h * g.mass, l, s)));
              }
            }
            attractiveForces() {
              let h, s, l;
              for (const p of this.links)
                p.fromNode &&
                  p.toNode &&
                  ((h = this.getDistXY(p.fromNode, p.toNode)),
                  (s = this.vectorLength(h)),
                  s !== 0 &&
                    ((l = this.attractiveForce(s, this.k)),
                    this.force("attractive", p, l, h, s)));
            }
            applyLimits() {
              const h = this.nodes;
              for (const s of h) {
                if (s.fixedPosition) break;
                this.integration.integrate(this, s),
                  this.applyLimitBox(s, this.box),
                  (s.dispX = 0),
                  (s.dispY = 0);
              }
            }
            applyLimitBox(h, s) {
              const l = h.radius;
              (h.plotX = Y(h.plotX, s.left + l, s.width - l)),
                (h.plotY = Y(h.plotY, s.top + l, s.height - l));
            }
            coolDown(h, s, l) {
              return h - s * l;
            }
            isStable() {
              return (
                1e-5 >
                  Math.abs(
                    this.systemTemperature - this.prevSystemTemperature
                  ) || 0 >= this.temperature
              );
            }
            getSystemTemperature() {
              let h = 0;
              for (const s of this.nodes) h += s.temperature;
              return h;
            }
            vectorLength(h) {
              return Math.sqrt(h.x * h.x + h.y * h.y);
            }
            getDistR(h, s) {
              return (h = this.getDistXY(h, s)), this.vectorLength(h);
            }
            getDistXY(h, s) {
              const l = h.plotX - s.plotX;
              return (
                (h = h.plotY - s.plotY),
                { x: l, y: h, absX: Math.abs(l), absY: Math.abs(h) }
              );
            }
          }
          return x;
        }
      ),
      n(
        e,
        "Series/PackedBubble/PackedBubbleLayout.js",
        [
          e["Series/GraphLayoutComposition.js"],
          e["Series/PackedBubble/PackedBubbleIntegration.js"],
          e["Series/Networkgraph/ReingoldFruchtermanLayout.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          function O() {
            const z = [];
            return (
              this.series.forEach((S) => {
                S.parentNode && S.parentNode.selected && z.push(S.parentNode);
              }),
              z
            );
          }
          function B() {
            this.allDataPoints && delete this.allDataPoints;
          }
          const { addEvent: G, pick: Y } = M,
            L = [];
          class E extends d {
            constructor() {
              super(...arguments),
                (this.index = NaN),
                (this.nodes = []),
                (this.options = void 0),
                (this.series = []);
            }
            static compose(S) {
              d.compose(S),
                (i.integrations.packedbubble = a),
                (i.layouts.packedbubble = E),
                M.pushUnique(L, S) &&
                  (G(S, "beforeRedraw", B),
                  (S.prototype.getSelectedParentNodes = O));
            }
            beforeStep() {
              this.options.marker &&
                this.series.forEach((S) => {
                  S && S.calculateParentRadius();
                });
            }
            isStable() {
              const S = Math.abs(
                this.prevSystemTemperature - this.systemTemperature
              );
              return (
                (1 >
                  Math.abs(
                    (10 * this.systemTemperature) / Math.sqrt(this.nodes.length)
                  ) &&
                  1e-5 > S) ||
                0 >= this.temperature
              );
            }
            setCircularPositions() {
              const S = this.box;
              var x = this.nodes;
              const P = (2 * Math.PI) / (x.length + 1),
                h = this.options.initialPositionRadius;
              let s,
                l = 0;
              for (const p of x)
                this.options.splitSeries && !p.isParentNode
                  ? ((x = p.series.parentNode.plotX),
                    (s = p.series.parentNode.plotY))
                  : ((x = S.width / 2), (s = S.height / 2)),
                  (p.plotX = p.prevX =
                    Y(p.plotX, x + h * Math.cos(p.index || l * P))),
                  (p.plotY = p.prevY =
                    Y(p.plotY, s + h * Math.sin(p.index || l * P))),
                  (p.dispX = 0),
                  (p.dispY = 0),
                  l++;
            }
            repulsiveForces() {
              const S = this,
                x = S.options.bubblePadding;
              let P, h, s;
              S.nodes.forEach((l) => {
                (l.degree = l.mass),
                  (l.neighbours = 0),
                  S.nodes.forEach((p) => {
                    (P = 0),
                      l === p ||
                        l.fixedPosition ||
                        (!S.options.seriesInteraction &&
                          l.series !== p.series) ||
                        ((s = S.getDistXY(l, p)),
                        (h =
                          S.vectorLength(s) -
                          (l.marker.radius + p.marker.radius + x)),
                        0 > h &&
                          ((l.degree += 0.01),
                          l.neighbours++,
                          (P = S.repulsiveForce(
                            -h / Math.sqrt(l.neighbours),
                            S.k,
                            l,
                            p
                          ))),
                        S.force("repulsive", l, P * p.mass, s, p, h));
                  });
              });
            }
            applyLimitBox(S, x) {
              let P, h;
              this.options.splitSeries &&
                !S.isParentNode &&
                this.options.parentNodeLimit &&
                ((P = this.getDistXY(S, S.series.parentNode)),
                (h =
                  S.series.parentNodeRadius -
                  S.marker.radius -
                  this.vectorLength(P)),
                0 > h &&
                  h > -2 * S.marker.radius &&
                  ((S.plotX -= 0.01 * P.x), (S.plotY -= 0.01 * P.y))),
                super.applyLimitBox(S, x);
            }
          }
          return (i.layouts.packedbubble = E);
        }
      ),
      n(
        e,
        "Series/SimulationSeriesUtilities.js",
        [e["Core/Utilities.js"], e["Core/Animation/AnimationUtilities.js"]],
        function (i, a) {
          const { syncTimeout: d } = i,
            { animObject: M } = a;
          return {
            initDataLabels: function () {
              const O = this.options.dataLabels;
              if (!this.dataLabelsGroup) {
                const B = this.initDataLabelsGroup();
                return (
                  !this.chart.styledMode &&
                    O != null &&
                    O.style &&
                    B.css(O.style),
                  B.attr({ opacity: 0 }),
                  this.visible && B.show(),
                  B
                );
              }
              return (
                this.dataLabelsGroup.attr({ opacity: 1 }), this.dataLabelsGroup
              );
            },
            initDataLabelsDefer: function () {
              var O;
              const B = this.options.dataLabels;
              B != null &&
              B.defer &&
              !((O = this.options.layoutAlgorithm) === null || O === void 0) &&
              O.enableSimulation
                ? d(
                    () => {
                      this.deferDataLabels = !1;
                    },
                    B ? M(B.animation).defer : 0
                  )
                : (this.deferDataLabels = !1);
            },
          };
        }
      ),
      n(
        e,
        "Series/PackedBubble/PackedBubbleSeries.js",
        [
          e["Core/Color/Color.js"],
          e["Series/DragNodesComposition.js"],
          e["Series/GraphLayoutComposition.js"],
          e["Core/Globals.js"],
          e["Series/PackedBubble/PackedBubblePoint.js"],
          e["Series/PackedBubble/PackedBubbleSeriesDefaults.js"],
          e["Series/PackedBubble/PackedBubbleLayout.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Series/SimulationSeriesUtilities.js"],
          e["Core/Utilities.js"],
          e["Core/Animation/AnimationUtilities.js"],
        ],
        function (i, a, d, M, O, B, G, Y, L, E, z) {
          const { parse: S } = i;
          ({ noop: i } = M);
          const {
              series: { prototype: x },
              seriesTypes: { bubble: P },
            } = Y,
            { initDataLabels: h, initDataLabelsDefer: s } = L,
            {
              addEvent: l,
              clamp: p,
              defined: g,
              extend: T,
              fireEvent: D,
              isArray: A,
              isNumber: m,
              merge: f,
              pick: b,
            } = E;
          class y extends P {
            constructor() {
              super(...arguments),
                (this.options = this.layout = this.data = this.chart = void 0),
                (this.parentNodeMass = 0),
                (this.xData = this.points = void 0),
                (this.deferDataLabels = !0);
            }
            static compose(o, r, c, u) {
              P.compose(o, r, c, u), a.compose(r), G.compose(r);
            }
            accumulateAllPoints() {
              const o = this.chart,
                r = [];
              let c;
              for (const u of o.series)
                if (
                  (u.is("packedbubble") && u.visible) ||
                  !o.options.chart.ignoreHiddenSeries
                ) {
                  c = u.yData || [];
                  for (let v = 0; v < c.length; v++)
                    r.push([
                      null,
                      null,
                      c[v],
                      u.index,
                      v,
                      { id: v, marker: { radius: 0 } },
                    ]);
                }
              return r;
            }
            addLayout() {
              const o = (this.options.layoutAlgorithm =
                  this.options.layoutAlgorithm || {}),
                r = o.type || "packedbubble",
                c = this.chart.options.chart;
              let u = this.chart.graphLayoutsStorage,
                v = this.chart.graphLayoutsLookup,
                N;
              u ||
                ((this.chart.graphLayoutsStorage = u = {}),
                (this.chart.graphLayoutsLookup = v = [])),
                (N = u[r]),
                N ||
                  ((o.enableSimulation = g(c.forExport)
                    ? !c.forExport
                    : o.enableSimulation),
                  (u[r] = N = new d.layouts[r]()),
                  N.init(o),
                  v.splice(N.index, 0, N)),
                (this.layout = N),
                this.points.forEach((w) => {
                  (w.mass = 2), (w.degree = 1), (w.collisionNmb = 1);
                }),
                N.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight),
                N.addElementsToCollection([this], N.series),
                N.addElementsToCollection(this.points, N.nodes);
            }
            addSeriesLayout() {
              var o = (this.options.layoutAlgorithm =
                this.options.layoutAlgorithm || {});
              const r = o.type || "packedbubble",
                c = this.chart.graphLayoutsStorage,
                u = this.chart.graphLayoutsLookup;
              o = f(o, o.parentNodeOptions, {
                enableSimulation: this.layout.options.enableSimulation,
              });
              let v = c[r + "-series"];
              v ||
                ((c[r + "-series"] = v = new d.layouts[r]()),
                v.init(o),
                u.splice(v.index, 0, v)),
                (this.parentNodeLayout = v),
                this.createParentNodes();
            }
            calculateParentRadius() {
              const o = this.seriesBox();
              (this.parentNodeRadius = p(
                Math.sqrt((2 * this.parentNodeMass) / Math.PI) + 20,
                20,
                o
                  ? Math.max(
                      Math.sqrt(Math.pow(o.width, 2) + Math.pow(o.height, 2)) /
                        2 +
                        20,
                      20
                    )
                  : Math.sqrt((2 * this.parentNodeMass) / Math.PI) + 20
              )),
                this.parentNode &&
                  (this.parentNode.marker.radius = this.parentNode.radius =
                    this.parentNodeRadius);
            }
            calculateZExtremes() {
              let o = this.options.zMin,
                r = this.options.zMax,
                c = 1 / 0,
                u = -1 / 0;
              return o && r
                ? [o, r]
                : (this.chart.series.forEach((v) => {
                    v.yData.forEach((N) => {
                      g(N) && (N > u && (u = N), N < c && (c = N));
                    });
                  }),
                  (o = b(o, c)),
                  (r = b(r, u)),
                  [o, r]);
            }
            checkOverlap(o, r) {
              const c = o[0] - r[0],
                u = o[1] - r[1];
              return -0.001 > Math.sqrt(c * c + u * u) - Math.abs(o[2] + r[2]);
            }
            createParentNodes() {
              const o = this.pointClass,
                r = this.chart,
                c = this.parentNodeLayout,
                u = this.layout.options;
              let v,
                N = this.parentNode,
                w = {
                  radius: this.parentNodeRadius,
                  lineColor: this.color,
                  fillColor: S(this.color).brighten(0.4).get(),
                };
              u.parentNodeOptions &&
                (w = f(u.parentNodeOptions.marker || {}, w)),
                (this.parentNodeMass = 0),
                this.points.forEach((R) => {
                  this.parentNodeMass += Math.PI * Math.pow(R.marker.radius, 2);
                }),
                this.calculateParentRadius(),
                c.nodes.forEach((R) => {
                  R.seriesIndex === this.index && (v = !0);
                }),
                c.setArea(0, 0, r.plotWidth, r.plotHeight),
                v ||
                  (N ||
                    (N = new o().init(this, {
                      mass: this.parentNodeRadius / 2,
                      marker: w,
                      dataLabels: { inside: !1 },
                      states: { normal: { marker: w }, hover: { marker: w } },
                      dataLabelOnNull: !0,
                      degree: this.parentNodeRadius,
                      isParentNode: !0,
                      seriesIndex: this.index,
                    })),
                  this.parentNode &&
                    ((N.plotX = this.parentNode.plotX),
                    (N.plotY = this.parentNode.plotY)),
                  (this.parentNode = N),
                  c.addElementsToCollection([this], c.series),
                  c.addElementsToCollection([N], c.nodes));
            }
            deferLayout() {
              const o = this.options.layoutAlgorithm;
              this.visible &&
                (this.addLayout(), o.splitSeries && this.addSeriesLayout());
            }
            destroy() {
              this.chart.graphLayoutsLookup &&
                this.chart.graphLayoutsLookup.forEach((o) => {
                  o.removeElementFromCollection(this, o.series);
                }, this),
                this.parentNode &&
                  this.parentNodeLayout &&
                  (this.parentNodeLayout.removeElementFromCollection(
                    this.parentNode,
                    this.parentNodeLayout.nodes
                  ),
                  this.parentNode.dataLabel &&
                    (this.parentNode.dataLabel =
                      this.parentNode.dataLabel.destroy())),
                x.destroy.apply(this, arguments);
            }
            drawDataLabels() {
              this.deferDataLabels ||
                (x.drawDataLabels.call(this, this.points),
                this.parentNode &&
                  ((this.parentNode.formatPrefix = "parentNode"),
                  x.drawDataLabels.call(this, [this.parentNode])));
            }
            drawGraph() {
              var o;
              if (this.layout && this.layout.options.splitSeries) {
                var r = this.chart,
                  c = this.layout.options.parentNodeOptions.marker;
                (c = {
                  fill: c.fillColor || S(this.color).brighten(0.4).get(),
                  opacity: c.fillOpacity,
                  stroke: c.lineColor || this.color,
                  "stroke-width": b(c.lineWidth, this.options.lineWidth),
                }),
                  (this.parentNodesGroup = this.plotGroup(
                    "parentNodesGroup",
                    "parentNode",
                    this.visible ? "inherit" : "hidden",
                    0.1,
                    r.seriesGroup
                  )),
                  (o = this.group) === null ||
                    o === void 0 ||
                    o.attr({ zIndex: 2 }),
                  this.calculateParentRadius(),
                  this.parentNode &&
                    g(this.parentNode.plotX) &&
                    g(this.parentNode.plotY) &&
                    g(this.parentNodeRadius) &&
                    ((o = f(
                      {
                        x: this.parentNode.plotX - this.parentNodeRadius,
                        y: this.parentNode.plotY - this.parentNodeRadius,
                        width: 2 * this.parentNodeRadius,
                        height: 2 * this.parentNodeRadius,
                      },
                      c
                    )),
                    this.parentNode.graphic ||
                      (this.graph = this.parentNode.graphic =
                        r.renderer.symbol(c.symbol).add(this.parentNodesGroup)),
                    this.parentNode.graphic.attr(o));
              }
            }
            drawTracker() {
              const o = this.parentNode;
              let r;
              super.drawTracker(),
                o &&
                  ((r = A(o.dataLabels)
                    ? o.dataLabels
                    : o.dataLabel
                    ? [o.dataLabel]
                    : []),
                  o.graphic && (o.graphic.element.point = o),
                  r.forEach((c) => {
                    c.div ? (c.div.point = o) : (c.element.point = o);
                  }));
            }
            getPointRadius() {
              const o = this.chart,
                r = this.options,
                c = r.useSimulation,
                u = Math.min(o.plotWidth, o.plotHeight),
                v = {},
                N = [],
                w = o.allDataPoints || [],
                R = w.length;
              let X, J, K, H;
              ["minSize", "maxSize"].forEach((U) => {
                const _ = parseInt(r[U], 10),
                  W = /%$/.test(r[U]);
                v[U] = W ? (u * _) / 100 : _ * Math.sqrt(R);
              }),
                (o.minRadius = X = v.minSize / Math.sqrt(R)),
                (o.maxRadius = J = v.maxSize / Math.sqrt(R));
              const k = c ? this.calculateZExtremes() : [X, J];
              w.forEach((U, _) => {
                (K = c ? p(U[2], k[0], k[1]) : U[2]),
                  (H = this.getRadius(k[0], k[1], X, J, K)),
                  H === 0 && (H = null),
                  (w[_][2] = H),
                  N.push(H);
              }),
                (this.radii = N);
            }
            init() {
              return (
                x.init.apply(this, arguments),
                s.call(this),
                this.eventsToUnbind.push(
                  l(this, "updatedData", function () {
                    this.chart.series.forEach((o) => {
                      o.type === this.type && (o.isDirty = !0);
                    }, this);
                  })
                ),
                this
              );
            }
            onMouseUp(o) {
              const r = o;
              if (r.fixedPosition && !r.removed) {
                const c = this.layout,
                  u = this.parentNodeLayout;
                let v, N;
                u &&
                  c.options.dragBetweenSeries &&
                  u.nodes.forEach((w) => {
                    r &&
                      r.marker &&
                      w !== r.series.parentNode &&
                      ((v = c.getDistXY(r, w)),
                      (N =
                        c.vectorLength(v) - w.marker.radius - r.marker.radius),
                      0 > N &&
                        (w.series.addPoint(
                          f(r.options, { plotX: r.plotX, plotY: r.plotY }),
                          !1
                        ),
                        c.removeElementFromCollection(r, c.nodes),
                        r.remove()));
                  }),
                  a.onMouseUp.apply(this, arguments);
              }
            }
            placeBubbles(o) {
              const r = this.checkOverlap,
                c = this.positionBubble,
                u = [];
              let v = 1,
                N = 0,
                w = 0;
              var R = [];
              let X;
              if (((o = o.sort((J, K) => K[2] - J[2])), o.length)) {
                if ((u.push([[0, 0, o[0][2], o[0][3], o[0][4]]]), 1 < o.length))
                  for (
                    u.push([
                      [0, 0 - o[1][2] - o[0][2], o[1][2], o[1][3], o[1][4]],
                    ]),
                      X = 2;
                    X < o.length;
                    X++
                  )
                    (o[X][2] = o[X][2] || 1),
                      (R = c(u[v][N], u[v - 1][w], o[X])),
                      r(R, u[v][0])
                        ? (u.push([]),
                          (w = 0),
                          u[v + 1].push(c(u[v][N], u[v][0], o[X])),
                          v++,
                          (N = 0))
                        : 1 < v && u[v - 1][w + 1] && r(R, u[v - 1][w + 1])
                        ? (w++, u[v].push(c(u[v][N], u[v - 1][w], o[X])), N++)
                        : (N++, u[v].push(R));
                (this.chart.stages = u),
                  (this.chart.rawPositions = [].concat.apply([], u)),
                  this.resizeRadius(),
                  (R = this.chart.rawPositions);
              }
              return R;
            }
            pointAttribs(o, r) {
              var c = this.options;
              let u = c.marker;
              return (
                o &&
                  o.isParentNode &&
                  c.layoutAlgorithm &&
                  c.layoutAlgorithm.parentNodeOptions &&
                  (u = c.layoutAlgorithm.parentNodeOptions.marker),
                (c = u.fillOpacity),
                (o = x.pointAttribs.call(this, o, r)),
                c !== 1 && (o["fill-opacity"] = c),
                o
              );
            }
            positionBubble(o, r, c) {
              var u = Math.sqrt,
                v = Math.asin,
                N = Math.acos;
              const w = Math.pow,
                R = Math.abs;
              return (
                (u = u(w(o[0] - r[0], 2) + w(o[1] - r[1], 2))),
                (N = N(
                  (w(u, 2) + w(c[2] + r[2], 2) - w(c[2] + o[2], 2)) /
                    (2 * (c[2] + r[2]) * u)
                )),
                (v = v(R(o[0] - r[0]) / u)),
                (o =
                  (0 > o[1] - r[1] ? 0 : Math.PI) +
                  N +
                  v * (0 > (o[0] - r[0]) * (o[1] - r[1]) ? 1 : -1)),
                [
                  r[0] + (r[2] + c[2]) * Math.sin(o),
                  r[1] - (r[2] + c[2]) * Math.cos(o),
                  c[2],
                  c[3],
                  c[4],
                ]
              );
            }
            render() {
              const o = [];
              x.render.apply(this, arguments),
                this.options.dataLabels.allowOverlap ||
                  (this.data.forEach((r) => {
                    A(r.dataLabels) &&
                      r.dataLabels.forEach((c) => {
                        o.push(c);
                      });
                  }),
                  this.options.useSimulation &&
                    this.chart.hideOverlappingLabels(o));
            }
            resizeRadius() {
              const o = this.chart,
                r = o.rawPositions;
              var c = Math.min,
                u = Math.max;
              const v = o.plotLeft,
                N = o.plotTop,
                w = o.plotHeight,
                R = o.plotWidth;
              let X, J, K, H, k;
              (X = K = Number.POSITIVE_INFINITY),
                (J = H = Number.NEGATIVE_INFINITY);
              for (const U of r)
                (k = U[2]),
                  (X = c(X, U[0] - k)),
                  (J = u(J, U[0] + k)),
                  (K = c(K, U[1] - k)),
                  (H = u(H, U[1] + k));
              if (
                ((u = [J - X, H - K]),
                (c = c.apply([], [(R - v) / u[0], (w - N) / u[1]])),
                1e-10 < Math.abs(c - 1))
              ) {
                for (const U of r) U[2] *= c;
                this.placeBubbles(r);
              } else
                (o.diffY = w / 2 + N - K - (H - K) / 2),
                  (o.diffX = R / 2 + v - X - (J - X) / 2);
            }
            seriesBox() {
              const o = this.chart,
                r = Math.max,
                c = Math.min,
                u = [
                  o.plotLeft,
                  o.plotLeft + o.plotWidth,
                  o.plotTop,
                  o.plotTop + o.plotHeight,
                ];
              let v;
              return (
                this.data.forEach((N) => {
                  g(N.plotX) &&
                    g(N.plotY) &&
                    N.marker.radius &&
                    ((v = N.marker.radius),
                    (u[0] = c(u[0], N.plotX - v)),
                    (u[1] = r(u[1], N.plotX + v)),
                    (u[2] = c(u[2], N.plotY - v)),
                    (u[3] = r(u[3], N.plotY + v)));
                }),
                m(u.width / u.height) ? u : null
              );
            }
            setVisible() {
              const o = this;
              x.setVisible.apply(o, arguments),
                o.parentNodeLayout && o.graph
                  ? o.visible
                    ? (o.graph.show(),
                      o.parentNode.dataLabel && o.parentNode.dataLabel.show())
                    : (o.graph.hide(),
                      o.parentNodeLayout.removeElementFromCollection(
                        o.parentNode,
                        o.parentNodeLayout.nodes
                      ),
                      o.parentNode.dataLabel && o.parentNode.dataLabel.hide())
                  : o.layout &&
                    (o.visible
                      ? o.layout.addElementsToCollection(
                          o.points,
                          o.layout.nodes
                        )
                      : o.points.forEach((r) => {
                          o.layout.removeElementFromCollection(
                            r,
                            o.layout.nodes
                          );
                        }));
            }
            translate() {
              const o = this.chart,
                r = this.data,
                c = this.index,
                u = this.options.useSimulation;
              let v;
              if (
                ((this.processedXData = this.xData),
                this.generatePoints(),
                g(o.allDataPoints) ||
                  ((o.allDataPoints = this.accumulateAllPoints()),
                  this.getPointRadius()),
                u)
              )
                var N = o.allDataPoints;
              else
                (N = this.placeBubbles(o.allDataPoints)),
                  (this.options.draggable = !1);
              for (const w of N)
                w[3] === c &&
                  ((N = r[w[4]]),
                  (v = b(w[2], void 0)),
                  u ||
                    ((N.plotX = w[0] - o.plotLeft + o.diffX),
                    (N.plotY = w[1] - o.plotTop + o.diffY)),
                  m(v) &&
                    ((N.marker = T(N.marker, {
                      radius: v,
                      width: 2 * v,
                      height: 2 * v,
                    })),
                    (N.radius = v)));
              u && this.deferLayout(), D(this, "afterTranslate");
            }
          }
          return (
            (y.defaultOptions = f(P.defaultOptions, B)),
            T(y.prototype, {
              pointClass: O,
              axisTypes: [],
              directTouch: !0,
              forces: ["barycenter", "repulsive"],
              hasDraggableNodes: !0,
              isCartesian: !1,
              noSharedTooltip: !0,
              pointArrayMap: ["value"],
              pointValKey: "value",
              requireSorting: !1,
              trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
              initDataLabels: h,
              alignDataLabel: x.alignDataLabel,
              indexateNodes: i,
              onMouseDown: a.onMouseDown,
              onMouseMove: a.onMouseMove,
              redrawHalo: a.redrawHalo,
              searchPoint: i,
            }),
            Y.registerSeriesType("packedbubble", y),
            y
          );
        }
      ),
      n(
        e,
        "Series/Polygon/PolygonSeries.js",
        [
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          ({ noop: i } = i);
          const {
              series: M,
              seriesTypes: { area: O, line: B, scatter: G },
            } = a,
            { extend: Y, merge: L } = d;
          class E extends G {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            getGraphPath() {
              let S = B.prototype.getGraphPath.call(this),
                x = S.length + 1;
              for (; x--; )
                (x === S.length || S[x][0] === "M") &&
                  0 < x &&
                  S.splice(x, 0, ["Z"]);
              return (this.areaPath = S);
            }
            drawGraph() {
              (this.options.fillColor = this.color),
                O.prototype.drawGraph.call(this);
            }
          }
          return (
            (E.defaultOptions = L(G.defaultOptions, {
              marker: { enabled: !1, states: { hover: { enabled: !1 } } },
              stickyTracking: !1,
              tooltip: { followPointer: !0, pointFormat: "" },
              trackByArea: !0,
              legendSymbol: "rectangle",
            })),
            Y(E.prototype, {
              type: "polygon",
              drawTracker: M.prototype.drawTracker,
              setStackedPoints: i,
            }),
            a.registerSeriesType("polygon", E),
            E
          );
        }
      ),
      n(
        e,
        "Core/Axis/WaterfallAxis.js",
        [e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const { addEvent: d, objectEach: M } = a;
          var O;
          return (
            (function (B) {
              function G() {
                const S = this.waterfall.stacks;
                S && ((S.changed = !1), delete S.alreadyChanged);
              }
              function Y() {
                const S = this.options.stackLabels;
                S &&
                  S.enabled &&
                  this.waterfall.stacks &&
                  this.waterfall.renderStackTotals();
              }
              function L() {
                let S = this.axes,
                  x = this.series,
                  P = x.length;
                for (; P--; )
                  x[P].options.stacking &&
                    (S.forEach(function (h) {
                      h.isXAxis || (h.waterfall.stacks.changed = !0);
                    }),
                    (P = 0));
              }
              function E() {
                this.waterfall || (this.waterfall = new z(this));
              }
              class z {
                constructor(x) {
                  (this.axis = x), (this.stacks = { changed: !1 });
                }
                renderStackTotals() {
                  const x = this.axis,
                    P = x.waterfall.stacks,
                    h = x.stacking && x.stacking.stackTotalGroup,
                    s = new i(x, x.options.stackLabels || {}, !1, 0, void 0);
                  (this.dummyStackItem = s),
                    h &&
                      M(P, function (l) {
                        M(l, function (p, g) {
                          (s.total = p.stackTotal),
                            (s.x = +g),
                            p.label && (s.label = p.label),
                            i.prototype.render.call(s, h),
                            (p.label = s.label),
                            delete s.label;
                        });
                      }),
                    (s.total = null);
                }
              }
              (B.Composition = z),
                (B.compose = function (S, x) {
                  d(S, "init", E),
                    d(S, "afterBuildStacks", G),
                    d(S, "afterRender", Y),
                    d(x, "beforeRedraw", L);
                });
            })(O || (O = {})),
            O
          );
        }
      ),
      n(
        e,
        "Series/Waterfall/WaterfallPoint.js",
        [
          e["Series/Column/ColumnSeries.js"],
          e["Core/Series/Point.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          const { isNumber: M } = d;
          class O extends i.prototype.pointClass {
            constructor() {
              super(...arguments), (this.series = this.options = void 0);
            }
            getClassName() {
              let G = a.prototype.getClassName.call(this);
              return (
                this.isSum
                  ? (G += " highcharts-sum")
                  : this.isIntermediateSum &&
                    (G += " highcharts-intermediate-sum"),
                G
              );
            }
            isValid() {
              return M(this.y) || this.isSum || !!this.isIntermediateSum;
            }
          }
          return O;
        }
      ),
      n(
        e,
        "Series/Waterfall/WaterfallSeries.js",
        [
          e["Core/Axis/Axis.js"],
          e["Core/Chart/Chart.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
          e["Core/Axis/WaterfallAxis.js"],
          e["Series/Waterfall/WaterfallPoint.js"],
        ],
        function (i, a, d, M, O, B) {
          const {
              seriesTypes: { column: G, line: Y },
            } = d,
            {
              addEvent: L,
              arrayMax: E,
              arrayMin: z,
              correctFloat: S,
              extend: x,
              isNumber: P,
              merge: h,
              objectEach: s,
              pick: l,
            } = M;
          class p extends G {
            constructor() {
              super(...arguments),
                (this.yData =
                  this.yAxis =
                  this.xData =
                  this.stackKey =
                  this.stackedYPos =
                  this.stackedYNeg =
                  this.points =
                  this.options =
                  this.data =
                  this.chart =
                    void 0);
            }
            generatePoints() {
              G.prototype.generatePoints.apply(this);
              for (let T = 0, D = this.points.length; T < D; T++) {
                const A = this.points[T],
                  m = this.processedYData[T];
                P(m) && (A.isIntermediateSum || A.isSum) && (A.y = S(m));
              }
            }
            processData(T) {
              let D = this.options,
                A = this.yData,
                m = D.data,
                f,
                b = A.length,
                y = D.threshold || 0,
                C,
                o,
                r,
                c,
                u,
                v;
              for (v = o = C = r = c = 0; v < b; v++)
                (u = A[v]),
                  (f = m && m[v] ? m[v] : {}),
                  u === "sum" || f.isSum
                    ? (A[v] = S(o))
                    : u === "intermediateSum" || f.isIntermediateSum
                    ? ((A[v] = S(C)), (C = 0))
                    : ((o += u), (C += u)),
                  (r = Math.min(o, r)),
                  (c = Math.max(o, c));
              super.processData.call(this, T),
                D.stacking || ((this.dataMin = r + y), (this.dataMax = c));
            }
            toYData(T) {
              return T.isSum
                ? "sum"
                : T.isIntermediateSum
                ? "intermediateSum"
                : T.y;
            }
            updateParallelArrays(T, D) {
              super.updateParallelArrays.call(this, T, D),
                (this.yData[0] === "sum" ||
                  this.yData[0] === "intermediateSum") &&
                  (this.yData[0] = null);
            }
            pointAttribs(T, D) {
              const A = this.options.upColor;
              return (
                A &&
                  !T.options.color &&
                  P(T.y) &&
                  (T.color = 0 < T.y ? A : void 0),
                (T = G.prototype.pointAttribs.call(this, T, D)),
                delete T.dashstyle,
                T
              );
            }
            getGraphPath() {
              return [["M", 0, 0]];
            }
            getCrispPath() {
              let T = this.data.filter((v) => P(v.y)),
                D = this.yAxis,
                A = T.length,
                m = (Math.round(this.graph.strokeWidth()) % 2) / 2,
                f = (Math.round(this.borderWidth) % 2) / 2,
                b = this.xAxis.reversed,
                y = this.yAxis.reversed,
                C = this.options.stacking,
                o = [];
              for (let v = 1; v < A; v++) {
                if (
                  !this.options.connectNulls &&
                  !P(this.data[T[v].index - 1].y)
                )
                  continue;
                var r = T[v].box,
                  c = T[v - 1];
                const N = c.y || 0,
                  w = T[v - 1].box;
                if (!r || !w) continue;
                var u = D.waterfall.stacks[this.stackKey];
                const R = 0 < N ? -w.height : 0;
                u &&
                  w &&
                  r &&
                  ((u = u[v - 1]),
                  (c = C
                    ? Math.round(
                        D.translate(u.connectorThreshold, !1, !0, !1, !0) +
                          (y ? R : 0)
                      ) - m
                    : w.y + c.minPointLengthOffset + f - m),
                  o.push(
                    ["M", (w.x || 0) + (b ? 0 : w.width || 0), c],
                    ["L", (r.x || 0) + ((b && r.width) || 0), c]
                  )),
                  w &&
                    o.length &&
                    ((!C && 0 > N && !y) || (0 < N && y)) &&
                    ((r = o[o.length - 2]) &&
                      typeof r[2] == "number" &&
                      (r[2] += w.height || 0),
                    (r = o[o.length - 1]) &&
                      typeof r[2] == "number" &&
                      (r[2] += w.height || 0));
              }
              return o;
            }
            drawGraph() {
              Y.prototype.drawGraph.call(this),
                this.graph && this.graph.attr({ d: this.getCrispPath() });
            }
            setStackedPoints() {
              function T(k, U, _, W) {
                if (r) {
                  if (N) for (_; _ < N; _++) r.stackState[_] += W;
                  else (r.stackState[0] = k), (N = r.stackState.length);
                  r.stackState.push(r.stackState[N - 1] + U);
                }
              }
              let D = this.options,
                A = this.yAxis.waterfall.stacks,
                m = D.threshold || 0,
                f = m,
                b = f,
                y = this.stackKey,
                C = this.xData,
                o = C.length,
                r,
                c,
                u,
                v,
                N,
                w,
                R,
                X;
              var J;
              let K;
              if (
                ((this.yAxis.stacking.usePercentage = !1),
                (c = u = v = f),
                this.visible || !this.chart.options.chart.ignoreHiddenSeries)
              ) {
                if (
                  ((K = A.changed),
                  (J = A.alreadyChanged) && 0 > J.indexOf(y) && (K = !0),
                  A[y] || (A[y] = {}),
                  (J = A[y]))
                )
                  for (let k = 0; k < o; k++) {
                    var H = C[k];
                    (!J[H] || K) &&
                      (J[H] = {
                        negTotal: 0,
                        posTotal: 0,
                        stackTotal: 0,
                        threshold: 0,
                        stateIndex: 0,
                        stackState: [],
                        label: K && J[H] ? J[H].label : void 0,
                      }),
                      (r = J[H]),
                      (X = this.yData[k]),
                      0 <= X ? (r.posTotal += X) : (r.negTotal += X),
                      (R = D.data[k]),
                      (H = r.absolutePos = r.posTotal),
                      (w = r.absoluteNeg = r.negTotal),
                      (r.stackTotal = H + w),
                      (N = r.stackState.length),
                      R && R.isIntermediateSum
                        ? (T(v, u, 0, v),
                          (v = u),
                          (u = m),
                          (f ^= b),
                          (b ^= f),
                          (f ^= b))
                        : R && R.isSum
                        ? (T(m, c, N, 0), (f = m))
                        : (T(f, X, 0, c), R && ((c += X), (u += X))),
                      r.stateIndex++,
                      (r.threshold = f),
                      (f += r.stackTotal);
                  }
                (A.changed = !1),
                  A.alreadyChanged || (A.alreadyChanged = []),
                  A.alreadyChanged.push(y);
              }
            }
            getExtremes() {
              let T = this.options.stacking,
                D,
                A;
              if (T) {
                var m = this.yAxis;
                return (
                  (m = m.waterfall.stacks),
                  (D = this.stackedYNeg = []),
                  (A = this.stackedYPos = []),
                  T === "overlap"
                    ? s(m[this.stackKey], function (f) {
                        D.push(z(f.stackState)), A.push(E(f.stackState));
                      })
                    : s(m[this.stackKey], function (f) {
                        D.push(f.negTotal + f.threshold),
                          A.push(f.posTotal + f.threshold);
                      }),
                  { dataMin: z(D), dataMax: E(A) }
                );
              }
              return { dataMin: this.dataMin, dataMax: this.dataMax };
            }
          }
          return (
            (p.defaultOptions = h(G.defaultOptions, {
              dataLabels: { inside: !0 },
              lineWidth: 1,
              lineColor: "#333333",
              dashStyle: "Dot",
              borderColor: "#333333",
              states: { hover: { lineWidthPlus: 0 } },
            })),
            L(
              p,
              "afterColumnTranslate",
              function () {
                const { options: g, points: T, yAxis: D } = this,
                  A = l(g.minPointLength, 5),
                  m = A / 2,
                  f = g.threshold || 0,
                  b = g.stacking,
                  y = D.waterfall.stacks[this.stackKey];
                let C = f,
                  o = f;
                for (let N = 0; N < T.length; N++) {
                  const w = T[N];
                  var r = this.processedYData[N];
                  const R = x(
                    { x: 0, y: 0, width: 0, height: 0 },
                    w.shapeArgs || {}
                  );
                  w.box = R;
                  var c = [0, r],
                    u = w.y || 0;
                  if (b) {
                    if (y) {
                      if (((c = y[N]), b === "overlap")) {
                        var v = c.stackState[c.stateIndex--];
                        (v = 0 <= u ? v : v - u),
                          Object.hasOwnProperty.call(c, "absolutePos") &&
                            delete c.absolutePos,
                          Object.hasOwnProperty.call(c, "absoluteNeg") &&
                            delete c.absoluteNeg;
                      } else
                        0 <= u
                          ? ((v = c.threshold + c.posTotal), (c.posTotal -= u))
                          : ((v = c.threshold + c.negTotal),
                            (c.negTotal -= u),
                            (v -= u)),
                          !c.posTotal &&
                            P(c.absolutePos) &&
                            Object.hasOwnProperty.call(c, "absolutePos") &&
                            ((c.posTotal = c.absolutePos),
                            delete c.absolutePos),
                          !c.negTotal &&
                            P(c.absoluteNeg) &&
                            Object.hasOwnProperty.call(c, "absoluteNeg") &&
                            ((c.negTotal = c.absoluteNeg),
                            delete c.absoluteNeg);
                      w.isSum ||
                        (c.connectorThreshold = c.threshold + c.stackTotal),
                        D.reversed
                          ? (r = 0 <= u ? v - u : v + u)
                          : ((r = v), (v -= u)),
                        (w.below = r <= f),
                        (R.y = D.translate(r, !1, !0, !1, !0)),
                        (R.height = Math.abs(
                          R.y - D.translate(v, !1, !0, !1, !0)
                        )),
                        (v = D.waterfall.dummyStackItem) &&
                          ((v.x = N),
                          (v.label = y[N].label),
                          v.setOffset(
                            this.pointXOffset || 0,
                            this.barW || 0,
                            this.stackedYNeg[N],
                            this.stackedYPos[N],
                            void 0,
                            this.xAxis
                          ));
                    }
                  } else
                    (v = Math.max(o, o + u) + c[0]),
                      (R.y = D.translate(v, !1, !0, !1, !0)),
                      w.isSum
                        ? ((R.y = D.translate(c[1], !1, !0, !1, !0)),
                          (R.height =
                            Math.min(D.translate(c[0], !1, !0, !1, !0), D.len) -
                            R.y),
                          (w.below = c[1] <= f))
                        : w.isIntermediateSum
                        ? (0 <= u
                            ? ((r = c[1] + C), (v = C))
                            : ((r = C), (v = c[1] + C)),
                          D.reversed && ((r ^= v), (v ^= r), (r ^= v)),
                          (R.y = D.translate(r, !1, !0, !1, !0)),
                          (R.height = Math.abs(
                            R.y -
                              Math.min(D.translate(v, !1, !0, !1, !0), D.len)
                          )),
                          (C += c[1]),
                          (w.below = r <= f))
                        : ((R.height =
                            0 < r
                              ? D.translate(o, !1, !0, !1, !0) - R.y
                              : D.translate(o, !1, !0, !1, !0) -
                                D.translate(o - r, !1, !0, !1, !0)),
                          (o += r),
                          (w.below = o < f)),
                      0 > R.height && ((R.y += R.height), (R.height *= -1));
                  (w.plotY = R.y =
                    Math.round(R.y || 0) - (this.borderWidth % 2) / 2),
                    (R.height = Math.max(Math.round(R.height || 0), 0.001)),
                    (w.yBottom = R.y + R.height),
                    R.height <= A && !w.isNull
                      ? ((R.height = A),
                        (R.y -= m),
                        (w.plotY = R.y),
                        (w.minPointLengthOffset = 0 > u ? -m : m))
                      : (w.isNull && (R.width = 0),
                        (w.minPointLengthOffset = 0)),
                    (u = w.plotY + (w.negative ? R.height : 0)),
                    w.below && (w.plotY += R.height),
                    w.tooltipPos &&
                      (this.chart.inverted
                        ? (w.tooltipPos[0] = D.len - u)
                        : (w.tooltipPos[1] = u)),
                    (w.isInside = this.isPointInside(w)),
                    h(!0, w.shapeArgs, R);
                }
              },
              { order: 2 }
            ),
            x(p.prototype, {
              getZonesGraphs: Y.prototype.getZonesGraphs,
              pointValKey: "y",
              showLine: !0,
              pointClass: B,
            }),
            d.registerSeriesType("waterfall", p),
            O.compose(i, a),
            p
          );
        }
      ),
      n(
        e,
        "Core/Axis/RadialAxis.js",
        [
          e["Core/Axis/AxisDefaults.js"],
          e["Core/Defaults.js"],
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M) {
          const { defaultOptions: O } = a,
            { noop: B } = d,
            {
              addEvent: G,
              correctFloat: Y,
              defined: L,
              extend: E,
              fireEvent: z,
              merge: S,
              pick: x,
              relativeLength: P,
              wrap: h,
            } = M;
          var s;
          return (
            (function (l) {
              function p() {
                (this.autoConnect =
                  this.isCircular &&
                  typeof x(this.userMax, this.options.max) > "u" &&
                  Y(this.endAngleRad - this.startAngleRad) === Y(2 * Math.PI)),
                  !this.isCircular && this.chart.inverted && this.max++,
                  this.autoConnect &&
                    (this.max +=
                      (this.categories && 1) ||
                      this.pointRange ||
                      this.closestPointRange ||
                      0);
              }
              function g() {
                return () => {
                  if (
                    this.isRadial &&
                    this.tickPositions &&
                    this.options.labels &&
                    this.options.labels.allowOverlap !== !0
                  )
                    return this.tickPositions
                      .map((I) => this.ticks[I] && this.ticks[I].label)
                      .filter((I) => !!I);
                };
              }
              function T() {
                return B;
              }
              function D(I, F, V) {
                const Q = this.pane.center;
                let $ = I.value,
                  et;
                if (this.isCircular) {
                  if (L($))
                    I.point &&
                      ((st = I.point.shapeArgs || {}),
                      st.start &&
                        ($ = this.chart.inverted
                          ? this.translate(I.point.rectPlotY, !0)
                          : I.point.x));
                  else {
                    var st = I.chartX || 0;
                    (et = I.chartY || 0),
                      ($ = this.translate(
                        Math.atan2(et - V, st - F) - this.startAngleRad,
                        !0
                      ));
                  }
                  (I = this.getPosition($)), (st = I.x), (et = I.y);
                } else
                  L($) || ((st = I.chartX), (et = I.chartY)),
                    L(st) &&
                      L(et) &&
                      ((V = Q[1] + this.chart.plotTop),
                      ($ = this.translate(
                        Math.min(
                          Math.sqrt(Math.pow(st - F, 2) + Math.pow(et - V, 2)),
                          Q[2] / 2
                        ) -
                          Q[3] / 2,
                        !0
                      )));
                return [$, st || 0, et || 0];
              }
              function A(I, F, V) {
                I = this.pane.center;
                const Q = this.chart,
                  $ = this.left || 0,
                  et = this.top || 0;
                let st = x(F, I[2] / 2 - this.offset);
                return (
                  typeof V > "u" &&
                    (V = this.horiz ? 0 : this.center && -this.center[3] / 2),
                  V && (st += V),
                  this.isCircular || typeof F < "u"
                    ? ((F = this.chart.renderer.symbols.arc(
                        $ + I[0],
                        et + I[1],
                        st,
                        st,
                        {
                          start: this.startAngleRad,
                          end: this.endAngleRad,
                          open: !0,
                          innerR: 0,
                        }
                      )),
                      (F.xBounds = [$ + I[0]]),
                      (F.yBounds = [et + I[1] - st]))
                    : ((F = this.postTranslate(this.angleRad, st)),
                      (F = [
                        [
                          "M",
                          this.center[0] + Q.plotLeft,
                          this.center[1] + Q.plotTop,
                        ],
                        ["L", F.x, F.y],
                      ])),
                  F
                );
              }
              function m() {
                this.constructor.prototype.getOffset.call(this),
                  (this.chart.axisOffset[this.side] = 0);
              }
              function f(I, F, V) {
                const Q = this.chart;
                var $ = (ct) => {
                  if (typeof ct == "string") {
                    let ft = parseInt(ct, 10);
                    return q.test(ct) && (ft = (ft * ot) / 100), ft;
                  }
                  return ct;
                };
                const et = this.center;
                var st = this.startAngleRad;
                const ot = et[2] / 2;
                var at = Math.min(this.offset, 0),
                  lt = this.left || 0;
                const Z = this.top || 0,
                  q = /%$/;
                var nt = this.isCircular;
                let it,
                  rt = x($(V.outerRadius), ot),
                  ht = $(V.innerRadius);
                return (
                  ($ = x($(V.thickness), 10)),
                  this.options.gridLineInterpolation === "polygon"
                    ? (at = this.getPlotLinePath({ value: I }).concat(
                        this.getPlotLinePath({ value: F, reverse: !0 })
                      ))
                    : ((I = Math.max(I, this.min)),
                      (F = Math.min(F, this.max)),
                      (I = this.translate(I)),
                      (F = this.translate(F)),
                      nt || ((rt = I || 0), (ht = F || 0)),
                      V.shape !== "circle" && nt
                        ? ((V = st + (I || 0)), (st += F || 0))
                        : ((V = -Math.PI / 2), (st = 1.5 * Math.PI), (it = !0)),
                      (rt -= at),
                      (at = Q.renderer.symbols.arc(
                        lt + et[0],
                        Z + et[1],
                        rt,
                        rt,
                        {
                          start: Math.min(V, st),
                          end: Math.max(V, st),
                          innerR: x(ht, rt - ($ - at)),
                          open: it,
                        }
                      )),
                      nt &&
                        ((nt = (st + V) / 2),
                        (lt = lt + et[0] + (et[2] / 2) * Math.cos(nt)),
                        (at.xBounds =
                          nt > -Math.PI / 2 && nt < Math.PI / 2
                            ? [lt, Q.plotWidth]
                            : [0, lt]),
                        (at.yBounds = [Z + et[1] + (et[2] / 2) * Math.sin(nt)]),
                        (at.yBounds[0] +=
                          (nt > -Math.PI && 0 > nt) || nt > Math.PI
                            ? -10
                            : 10))),
                  at
                );
              }
              function b(I) {
                var F = this.pane.center,
                  V = this.chart;
                const Q = V.inverted;
                var $ = I.reverse,
                  et = this.pane.options.background
                    ? this.pane.options.background[0] ||
                      this.pane.options.background
                    : {};
                const st = et.innerRadius || "0%",
                  ot = et.outerRadius || "100%";
                var at = F[0] + V.plotLeft,
                  lt = F[1] + V.plotTop;
                const Z = this.height,
                  q = I.isCrosshair;
                et = F[3] / 2;
                var nt = I.value;
                let it;
                var rt = this.getPosition(nt);
                let ht = rt.x;
                if (
                  ((rt = rt.y),
                  q &&
                    ((rt = this.getCrosshairPosition(I, at, lt)),
                    (nt = rt[0]),
                    (ht = rt[1]),
                    (rt = rt[2])),
                  this.isCircular)
                )
                  (nt = Math.sqrt(Math.pow(ht - at, 2) + Math.pow(rt - lt, 2))),
                    ($ = typeof st == "string" ? P(st, 1) : st / nt),
                    (V = typeof ot == "string" ? P(ot, 1) : ot / nt),
                    F &&
                      et &&
                      ((et /= nt), $ < et && ($ = et), V < et && (V = et)),
                    (F = [
                      ["M", at + $ * (ht - at), lt - $ * (lt - rt)],
                      ["L", ht - (1 - V) * (ht - at), rt + (1 - V) * (lt - rt)],
                    ]);
                else if (
                  ((nt = this.translate(nt)) && (0 > nt || nt > Z) && (nt = 0),
                  this.options.gridLineInterpolation === "circle")
                )
                  F = this.getLinePath(0, nt, et);
                else if (
                  ((F = []),
                  V[Q ? "yAxis" : "xAxis"].forEach((ct) => {
                    ct.pane === this.pane && (it = ct);
                  }),
                  it)
                )
                  for (
                    at = it.tickPositions,
                      it.autoConnect && (at = at.concat([at[0]])),
                      $ && (at = at.slice().reverse()),
                      nt && (nt += et),
                      lt = 0;
                    lt < at.length;
                    lt++
                  )
                    (et = it.getPosition(at[lt], nt)),
                      F.push(lt ? ["L", et.x, et.y] : ["M", et.x, et.y]);
                return F;
              }
              function y(I, F) {
                return (
                  (I = this.translate(I)),
                  this.postTranslate(
                    this.isCircular ? I : this.angleRad,
                    x(this.isCircular ? F : 0 > I ? 0 : I, this.center[2] / 2) -
                      this.offset
                  )
                );
              }
              function C() {
                const I = this.center,
                  F = this.chart,
                  V = this.options.title;
                return {
                  x: F.plotLeft + I[0] + (V.x || 0),
                  y:
                    F.plotTop +
                    I[1] -
                    { high: 0.5, middle: 0.25, low: 0 }[V.align] * I[2] +
                    (V.y || 0),
                };
              }
              function o(I) {
                (I.beforeSetTickPositions = p),
                  (I.createLabelCollector = g),
                  (I.getCrosshairPosition = D),
                  (I.getLinePath = A),
                  (I.getOffset = m),
                  (I.getPlotBandPath = f),
                  (I.getPlotLinePath = b),
                  (I.getPosition = y),
                  (I.getTitlePosition = C),
                  (I.postTranslate = X),
                  (I.setAxisSize = K),
                  (I.setAxisTranslation = H),
                  (I.setOptions = k);
              }
              function r() {
                var I = this.chart,
                  F = this.options,
                  V = this.pane,
                  Q = V && V.options;
                (I.angular && this.isXAxis) ||
                  !V ||
                  (!I.angular && !I.polar) ||
                  ((I = 2 * Math.PI),
                  (V = ((x(Q.startAngle, 0) - 90) * Math.PI) / 180),
                  (Q =
                    ((x(Q.endAngle, x(Q.startAngle, 0) + 360) - 90) * Math.PI) /
                    180),
                  (this.angleRad = ((F.angle || 0) * Math.PI) / 180),
                  (this.startAngleRad = V),
                  (this.endAngleRad = Q),
                  (this.offset = F.offset || 0),
                  (F = ((V % I) + I) % I),
                  (Q = ((Q % I) + I) % I),
                  F > Math.PI && (F -= I),
                  Q > Math.PI && (Q -= I),
                  (this.normalizedStartAngleRad = F),
                  (this.normalizedEndAngleRad = Q));
              }
              function c(I) {
                this.isRadial && ((I.align = void 0), I.preventDefault());
              }
              function u() {
                if (this.chart && this.chart.labelCollectors) {
                  const I = this.labelCollector
                    ? this.chart.labelCollectors.indexOf(this.labelCollector)
                    : -1;
                  0 <= I && this.chart.labelCollectors.splice(I, 1);
                }
              }
              function v(I) {
                const F = this.chart,
                  V = F.inverted,
                  Q = F.angular,
                  $ = F.polar,
                  et = this.isXAxis,
                  st = this.coll,
                  ot = Q && et;
                (I = I.userOptions.pane || 0),
                  (I = this.pane = F.pane && F.pane[I]);
                let at;
                st === "colorAxis"
                  ? (this.isRadial = !1)
                  : (Q
                      ? (ot
                          ? ((this.isHidden = !0),
                            (this.createLabelCollector = T),
                            (this.getOffset = B),
                            (this.render = this.redraw = J),
                            (this.setTitle =
                              this.setCategories =
                              this.setScale =
                                B))
                          : o(this),
                        (at = !et) && (this.defaultPolarOptions = tt))
                      : $ &&
                        (o(this),
                        (this.defaultPolarOptions = (at = this.horiz)
                          ? W
                          : S(
                              st === "xAxis"
                                ? i.defaultXAxisOptions
                                : i.defaultYAxisOptions,
                              j
                            )),
                        V &&
                          st === "yAxis" &&
                          ((this.defaultPolarOptions.stackLabels =
                            i.defaultYAxisOptions.stackLabels),
                          (this.defaultPolarOptions.reversedStacks = !0))),
                    Q || $
                      ? ((this.isRadial = !0),
                        this.labelCollector ||
                          (this.labelCollector = this.createLabelCollector()),
                        this.labelCollector &&
                          F.labelCollectors.push(this.labelCollector))
                      : (this.isRadial = !1),
                    I && at && (I.axis = this),
                    (this.isCircular = at));
              }
              function N() {
                this.isRadial && this.beforeSetTickPositions();
              }
              function w(I) {
                const F = this.label;
                if (F) {
                  var V = this.axis,
                    Q = F.getBBox(),
                    $ = V.options.labels,
                    et =
                      (((V.translate(this.pos) +
                        V.startAngleRad +
                        Math.PI / 2) /
                        Math.PI) *
                        180) %
                      360,
                    st = Math.round(et),
                    ot = L($.y) ? 0 : 0.3 * -Q.height,
                    at = $.y,
                    lt = 20,
                    Z = $.align,
                    q = "end",
                    nt = 0 > st ? st + 360 : st,
                    it = nt,
                    rt = 0,
                    ht = 0;
                  if (V.isRadial) {
                    var ct = V.getPosition(
                      this.pos,
                      V.center[2] / 2 +
                        P(x($.distance, -25), V.center[2] / 2, -V.center[2] / 2)
                    );
                    $.rotation === "auto"
                      ? F.attr({ rotation: et })
                      : L(at) ||
                        (at = V.chart.renderer.fontMetrics(F).b - Q.height / 2),
                      L(Z) ||
                        (V.isCircular
                          ? (Q.width >
                              (V.len * V.tickInterval) / (V.max - V.min) &&
                              (lt = 0),
                            (Z =
                              et > lt && et < 180 - lt
                                ? "left"
                                : et > 180 + lt && et < 360 - lt
                                ? "right"
                                : "center"))
                          : (Z = "center"),
                        F.attr({ align: Z })),
                      Z === "auto" &&
                        V.tickPositions.length === 2 &&
                        V.isCircular &&
                        (90 < nt && 180 > nt
                          ? (nt = 180 - nt)
                          : 270 < nt && 360 >= nt && (nt = 540 - nt),
                        180 < it && 360 >= it && (it = 360 - it),
                        (V.pane.options.startAngle === st ||
                          V.pane.options.startAngle === st + 360 ||
                          V.pane.options.startAngle === st - 360) &&
                          (q = "start"),
                        (Z =
                          (-90 <= st && 90 >= st) ||
                          (-360 <= st && -270 >= st) ||
                          (270 <= st && 360 >= st)
                            ? q === "start"
                              ? "right"
                              : "left"
                            : q === "start"
                            ? "left"
                            : "right"),
                        70 < it && 110 > it && (Z = "center"),
                        15 > nt || (180 <= nt && 195 > nt)
                          ? (rt = 0.3 * Q.height)
                          : 15 <= nt && 35 >= nt
                          ? (rt = q === "start" ? 0 : 0.75 * Q.height)
                          : 195 <= nt && 215 >= nt
                          ? (rt = q === "start" ? 0.75 * Q.height : 0)
                          : 35 < nt && 90 >= nt
                          ? (rt = q === "start" ? 0.25 * -Q.height : Q.height)
                          : 215 < nt &&
                            270 >= nt &&
                            (rt = q === "start" ? Q.height : 0.25 * -Q.height),
                        15 > it
                          ? (ht =
                              q === "start"
                                ? 0.15 * -Q.height
                                : 0.15 * Q.height)
                          : 165 < it &&
                            180 >= it &&
                            (ht =
                              q === "start"
                                ? 0.15 * Q.height
                                : 0.15 * -Q.height),
                        F.attr({ align: Z }),
                        F.translate(ht, rt + ot)),
                      (I.pos.x = ct.x + ($.x || 0)),
                      (I.pos.y = ct.y + (at || 0));
                  }
                }
              }
              function R(I) {
                this.axis.getPosition &&
                  E(I.pos, this.axis.getPosition(this.pos));
              }
              function X(I, F) {
                const V = this.chart,
                  Q = this.center;
                return (
                  (I = this.startAngleRad + I),
                  {
                    x: V.plotLeft + Q[0] + Math.cos(I) * F,
                    y: V.plotTop + Q[1] + Math.sin(I) * F,
                  }
                );
              }
              function J() {
                this.isDirty = !1;
              }
              function K() {
                let I, F;
                this.constructor.prototype.setAxisSize.call(this),
                  this.isRadial &&
                    (this.pane.updateCenter(this),
                    (I = this.center = this.pane.center.slice()),
                    this.isCircular
                      ? (this.sector = this.endAngleRad - this.startAngleRad)
                      : ((F = this.postTranslate(this.angleRad, I[3] / 2)),
                        (I[0] = F.x - this.chart.plotLeft),
                        (I[1] = F.y - this.chart.plotTop)),
                    (this.len =
                      this.width =
                      this.height =
                        ((I[2] - I[3]) * x(this.sector, 1)) / 2));
              }
              function H() {
                this.constructor.prototype.setAxisTranslation.call(this),
                  this.center &&
                    ((this.transA = this.isCircular
                      ? (this.endAngleRad - this.startAngleRad) /
                        (this.max - this.min || 1)
                      : (this.center[2] - this.center[3]) /
                        2 /
                        (this.max - this.min || 1)),
                    (this.minPixelPadding = this.isXAxis
                      ? this.transA * this.minPointOffset
                      : 0));
              }
              function k(I) {
                (I = this.options =
                  S(
                    this.constructor.defaultOptions,
                    this.defaultPolarOptions,
                    O[this.coll],
                    I
                  )),
                  I.plotBands || (I.plotBands = []),
                  z(this, "afterSetOptions");
              }
              function U(I, F, V, Q, $, et, st) {
                const ot = this.axis;
                return (
                  ot.isRadial
                    ? ((I = ot.getPosition(this.pos, ot.center[2] / 2 + Q)),
                      (F = ["M", F, V, "L", I.x, I.y]))
                    : (F = I.call(this, F, V, Q, $, et, st)),
                  F
                );
              }
              const _ = [],
                W = {
                  gridLineWidth: 1,
                  labels: {
                    align: void 0,
                    x: 0,
                    y: void 0,
                    style: { textOverflow: "none" },
                  },
                  maxPadding: 0,
                  minPadding: 0,
                  showLastLabel: !1,
                  tickLength: 0,
                },
                tt = {
                  labels: { align: "center", distance: -25, x: 0, y: void 0 },
                  minorGridLineWidth: 0,
                  minorTickInterval: "auto",
                  minorTickLength: 10,
                  minorTickPosition: "inside",
                  minorTickWidth: 1,
                  tickLength: 10,
                  tickPosition: "inside",
                  tickWidth: 2,
                  title: { rotation: 0 },
                  zIndex: 2,
                },
                j = {
                  gridLineInterpolation: "circle",
                  gridLineWidth: 1,
                  labels: { align: "right", x: -3, y: -2 },
                  showLastLabel: !1,
                  title: { x: 4, text: null, rotation: 90 },
                };
              l.compose = function (I, F) {
                return (
                  M.pushUnique(_, I) &&
                    (G(I, "afterInit", r),
                    G(I, "autoLabelAlign", c),
                    G(I, "destroy", u),
                    G(I, "init", v),
                    G(I, "initialAxisTranslation", N)),
                  M.pushUnique(_, F) &&
                    (G(F, "afterGetLabelPosition", w),
                    G(F, "afterGetPosition", R),
                    h(F.prototype, "getMarkPath", U)),
                  I
                );
              };
            })(s || (s = {})),
            s
          );
        }
      ),
      n(
        e,
        "Series/PolarComposition.js",
        [
          e["Core/Animation/AnimationUtilities.js"],
          e["Core/Globals.js"],
          e["Core/Series/Series.js"],
          e["Extensions/Pane.js"],
          e["Core/Axis/RadialAxis.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B) {
          function G(K, H, k, U) {
            var _ = U ? 1 : 0,
              W =
                0 <= H && H <= K.length - 1 ? H : 0 > H ? K.length - 1 + H : 0;
            H = 0 > W - 1 ? K.length - (1 + _) : W - 1;
            var tt = K[H];
            _ = K[W + 1 > K.length - 1 ? _ : W + 1];
            var j = tt.plotY,
              I = _.plotX,
              F = _.plotY;
            (_ = K[W].plotX),
              (W = K[W].plotY),
              (tt = (1.5 * _ + tt.plotX) / 2.5),
              (j = (1.5 * W + j) / 2.5),
              (I = (1.5 * _ + I) / 2.5);
            var V = (1.5 * W + F) / 2.5;
            F = Math.sqrt(Math.pow(tt - _, 2) + Math.pow(j - W, 2));
            const Q = Math.sqrt(Math.pow(I - _, 2) + Math.pow(V - W, 2));
            return (
              (tt = Math.atan2(j - W, tt - _)),
              (V = Math.PI / 2 + (tt + Math.atan2(V - W, I - _)) / 2),
              Math.abs(tt - V) > Math.PI / 2 && (V -= Math.PI),
              (tt = _ + Math.cos(V) * F),
              (j = W + Math.sin(V) * F),
              (I = _ + Math.cos(Math.PI + V) * Q),
              (V = W + Math.sin(Math.PI + V) * Q),
              (_ = {
                rightContX: I,
                rightContY: V,
                leftContX: tt,
                leftContY: j,
                plotX: _,
                plotY: W,
              }),
              k && (_.prevPointCont = G(K, H, !1, U)),
              _
            );
          }
          function Y() {
            (this.pane || []).forEach((K) => {
              K.render();
            });
          }
          function L(K) {
            const H = K.args[0].xAxis,
              k = K.args[0].yAxis;
            (K = K.args[0].chart),
              H &&
                k &&
                (k.gridLineInterpolation === "polygon"
                  ? ((H.startOnTick = !0), (H.endOnTick = !0))
                  : H.gridLineInterpolation === "polygon" &&
                    K.inverted &&
                    ((k.startOnTick = !0), (k.endOnTick = !0)));
          }
          function E() {
            this.pane || (this.pane = []),
              (this.options.pane = N(this.options.pane)),
              this.options.pane.forEach((K) => {
                new M(K, this);
              }, this);
          }
          function z(K) {
            var H = K.args.marker,
              k = this.chart.xAxis[0],
              U = this.chart.yAxis[0],
              _ = this.chart.inverted;
            const W = _ ? U : k;
            if (((k = _ ? k : U), this.chart.polar)) {
              K.preventDefault(),
                (U = (H.attr ? H.attr("start") : H.start) - W.startAngleRad),
                (_ = H.attr ? H.attr("r") : H.r);
              let tt = (H.attr ? H.attr("end") : H.end) - W.startAngleRad;
              (H = H.attr ? H.attr("innerR") : H.innerR),
                (K.result.x = U + W.pos),
                (K.result.width = tt - U),
                (K.result.y = k.len + k.pos - H),
                (K.result.height = H - _);
            }
          }
          function S(K) {
            var H = this.chart;
            if (H.polar && H.hoverPane && H.hoverPane.axis) {
              K.preventDefault();
              var k = H.hoverPane.center,
                U = this.mouseDownX || 0;
              const et = this.mouseDownY || 0;
              var _ = K.args.chartY;
              const st = K.args.chartX;
              var W = 2 * Math.PI,
                tt = H.hoverPane.axis.startAngleRad,
                j = H.hoverPane.axis.endAngleRad,
                I = H.inverted ? H.xAxis[0] : H.yAxis[0];
              const ot = {};
              var F = "arc";
              if (
                ((ot.x = k[0] + H.plotLeft),
                (ot.y = k[1] + H.plotTop),
                this.zoomHor)
              ) {
                var V = 0 < tt ? j - tt : Math.abs(tt) + Math.abs(j),
                  Q =
                    Math.atan2(et - H.plotTop - k[1], U - H.plotLeft - k[0]) -
                    tt,
                  $ =
                    Math.atan2(_ - H.plotTop - k[1], st - H.plotLeft - k[0]) -
                    tt;
                if (
                  ((ot.r = k[2] / 2),
                  (ot.innerR = k[3] / 2),
                  0 >= Q && (Q += W),
                  0 >= $ && ($ += W),
                  $ < Q && ($ = [Q, (Q = $)][0]),
                  V < W &&
                    tt + $ > j + (W - V) / 2 &&
                    (($ = Q), (Q = 0 >= tt ? tt : 0)),
                  (W = ot.start = Math.max(Q + tt, tt)),
                  (V = ot.end = Math.min($ + tt, j)),
                  I.options.gridLineInterpolation === "polygon")
                ) {
                  if (
                    ((F = H.hoverPane.axis),
                    ($ = W - F.startAngleRad + F.pos),
                    (Q = V - W),
                    (W = I.getPlotLinePath({ value: I.max })),
                    (V = F.toValue($)),
                    ($ = F.toValue($ + Q)),
                    V < F.getExtremes().min)
                  ) {
                    const { min: at, max: lt } = F.getExtremes();
                    V = lt - (at - V);
                  }
                  if ($ < F.getExtremes().min) {
                    const { min: at, max: lt } = F.getExtremes();
                    $ = lt - (at - $);
                  }
                  $ < V && ($ = [V, (V = $)][0]),
                    (W = s(W, V, $, F)),
                    W.push(["L", k[0] + H.plotLeft, H.plotTop + k[1]]),
                    (ot.d = W),
                    (F = "path");
                }
              }
              this.zoomVert &&
                (($ = H.inverted ? H.xAxis[0] : H.yAxis[0]),
                (U = Math.sqrt(
                  Math.pow(U - H.plotLeft - k[0], 2) +
                    Math.pow(et - H.plotTop - k[1], 2)
                )),
                (_ = Math.sqrt(
                  Math.pow(st - H.plotLeft - k[0], 2) +
                    Math.pow(_ - H.plotTop - k[1], 2)
                )),
                _ < U && (U = [_, (_ = U)][0]),
                _ > k[2] / 2 && (_ = k[2] / 2),
                U < k[3] / 2 && (U = k[3] / 2),
                this.zoomHor || ((ot.start = tt), (ot.end = j)),
                (ot.r = _),
                (ot.innerR = U),
                $.options.gridLineInterpolation === "polygon" &&
                  ((k = $.toValue($.len + $.pos - U)),
                  (tt = $.toValue($.len + $.pos - _)),
                  (k = $.getPlotLinePath({ value: tt }).concat(
                    $.getPlotLinePath({ value: k, reverse: !0 })
                  )),
                  (ot.d = k),
                  (F = "path"))),
                this.zoomHor &&
                  this.zoomVert &&
                  I.options.gridLineInterpolation === "polygon" &&
                  ((k = H.hoverPane.axis),
                  (I = ot.start || 0),
                  (tt = I - k.startAngleRad + k.pos),
                  (j = (ot.end || 0) - I),
                  (I = k.toValue(tt)),
                  (k = k.toValue(tt + j)),
                  ot.d instanceof Array &&
                    ((tt = ot.d.slice(0, ot.d.length / 2)),
                    (j = ot.d.slice(ot.d.length / 2, ot.d.length)),
                    (j = [...j].reverse()),
                    (H = H.hoverPane.axis),
                    (tt = s(tt, I, k, H)),
                    (j = s(j, I, k, H)) && (j[0][0] = "L"),
                    (j = [...j].reverse()),
                    (ot.d = tt.concat(j)),
                    (F = "path"))),
                (K.attrs = ot),
                (K.shapeType = F);
            }
          }
          function x() {
            const K = this.chart;
            K.polar &&
              ((this.polar = new J(this)),
              K.inverted &&
                ((this.isRadialSeries = !0),
                this.is("column") && (this.isRadialBar = !0)));
          }
          function P() {
            if (this.chart.polar && this.xAxis) {
              const { xAxis: K, yAxis: H } = this,
                k = this.chart;
              (this.kdByAngle = k.tooltip && k.tooltip.shared)
                ? (this.searchPoint = h)
                : (this.options.findNearestPointBy = "xy");
              const U = this.points;
              let _ = U.length;
              for (; _--; )
                this.is("column") ||
                  this.is("columnrange") ||
                  this.polar.toXY(U[_]),
                  k.hasParallelCoordinates ||
                    this.yAxis.reversed ||
                    (u(U[_].y, Number.MIN_VALUE) < H.min ||
                    U[_].x < K.min ||
                    U[_].x > K.max
                      ? ((U[_].isNull = !0), (U[_].plotY = NaN))
                      : (U[_].isNull = U[_].isValid && !U[_].isValid()));
              this.hasClipCircleSetter ||
                (this.hasClipCircleSetter = !!this.eventsToUnbind.push(
                  y(this, "afterRender", function () {
                    if (k.polar) {
                      var W = this.yAxis.pane.center;
                      if (this.clipCircle)
                        this.clipCircle.animate({
                          x: W[0],
                          y: W[1],
                          r: W[2] / 2,
                          innerR: W[3] / 2,
                        });
                      else {
                        {
                          var tt = k.renderer,
                            j = W[0],
                            I = W[1],
                            F = W[2] / 2,
                            V = W[3] / 2;
                          W = w();
                          const Q = tt
                            .createElement("clipPath")
                            .attr({ id: W })
                            .add(tt.defs);
                          (tt = V
                            ? tt.arc(j, I, F, V, 0, 2 * Math.PI).add(Q)
                            : tt.circle(j, I, F).add(Q)),
                            (tt.id = W),
                            (tt.clipPath = Q);
                        }
                        this.clipCircle = tt;
                      }
                      this.group.clip(this.clipCircle), (this.setClip = a.noop);
                    }
                  })
                ));
            }
          }
          function h(K) {
            const H = this.chart;
            var k = this.xAxis;
            return (
              (k = k.pane && k.pane.center),
              this.searchKDTree({
                clientX:
                  180 +
                  (-180 / Math.PI) *
                    Math.atan2(
                      K.chartX - ((k && k[0]) || 0) - H.plotLeft,
                      K.chartY - ((k && k[1]) || 0) - H.plotTop
                    ),
              })
            );
          }
          function s(K, H, k, U) {
            const _ = U.tickInterval;
            U = U.tickPositions;
            let W = o(U, (j) => j >= k),
              tt = o([...U].reverse(), (j) => j <= H);
            return (
              C(W) || (W = U[U.length - 1]),
              C(tt) ||
                ((tt = U[0]),
                (W += _),
                (K[0][0] = "L"),
                K.unshift(K[K.length - 3])),
              (K = K.slice(U.indexOf(tt), U.indexOf(W) + 1)),
              (K[0][0] = "M"),
              K
            );
          }
          function l(K, H) {
            return (
              o(this.pane || [], function (k) {
                return k.options.id === H;
              }) || K.call(this, H)
            );
          }
          function p(K, H, k, U, _, W) {
            const tt = this.chart;
            var j = u(U.inside, !!this.options.stacking);
            tt.polar
              ? ((K = (H.rectPlotX / Math.PI) * 180),
                tt.inverted
                  ? ((this.forceDL = tt.isInsidePlot(H.plotX, H.plotY)),
                    j && H.shapeArgs
                      ? ((j = H.shapeArgs),
                        (j = this.yAxis.postTranslate(
                          ((j.start || 0) + (j.end || 0)) / 2 -
                            this.xAxis.startAngleRad,
                          H.barX + H.pointWidth / 2
                        )),
                        (_ = c(_, {
                          x: j.x - tt.plotLeft,
                          y: j.y - tt.plotTop,
                        })))
                      : H.tooltipPos &&
                        (_ = c(_, { x: H.tooltipPos[0], y: H.tooltipPos[1] })),
                    (U.align = u(U.align, "center")),
                    (U.verticalAlign = u(U.verticalAlign, "middle")))
                  : (U.align === null &&
                      (U.align =
                        20 < K && 160 > K
                          ? "left"
                          : 200 < K && 340 > K
                          ? "right"
                          : "center"),
                    U.verticalAlign === null &&
                      (U.verticalAlign =
                        45 > K || 315 < K
                          ? "bottom"
                          : 135 < K && 225 > K
                          ? "top"
                          : "middle")),
                d.prototype.alignDataLabel.call(this, H, k, U, _, W),
                this.isRadialBar &&
                H.shapeArgs &&
                H.shapeArgs.start === H.shapeArgs.end
                  ? k.hide()
                  : k.show())
              : K.call(this, H, k, U, _, W);
          }
          function g() {
            const K = this.options,
              H = K.stacking,
              k = this.chart;
            var U = this.xAxis;
            const _ = this.yAxis,
              W = _.reversed,
              tt = _.center,
              j = U.startAngleRad,
              I = U.endAngleRad - j;
            let F = 0,
              V,
              Q,
              $,
              et = 0;
            var st = 0;
            if (U.isRadial) {
              (U = this.points),
                (V = U.length),
                (Q = _.translate(_.min)),
                ($ = _.translate(_.max));
              var ot = K.threshold || 0;
              for (
                k.inverted &&
                r(ot) &&
                ((F = _.translate(ot)),
                C(F) &&
                  (0 > F ? (F = 0) : F > I && (F = I),
                  (this.translatedThreshold = F + j)));
                V--;

              ) {
                ot = U[V];
                var at = ot.barX,
                  lt = ot.x,
                  Z = ot.y;
                if (((ot.shapeType = "arc"), k.inverted)) {
                  (ot.plotY = _.translate(Z)),
                    H && _.stacking
                      ? ((Z =
                          _.stacking.stacks[
                            (0 > Z ? "-" : "") + this.stackKey
                          ]),
                        this.visible &&
                          Z &&
                          Z[lt] &&
                          !ot.isNull &&
                          ((st =
                            Z[lt].points[
                              this.getStackIndicator(void 0, lt, this.index).key
                            ]),
                          (et = _.translate(st[0])),
                          (st = _.translate(st[1])),
                          C(et) && (et = B.clamp(et, 0, I))))
                      : ((et = F), (st = ot.plotY)),
                    et > st && (st = [et, (et = st)][0]),
                    W
                      ? st > Q
                        ? (st = Q)
                        : et < $
                        ? (et = $)
                        : (et > Q || st < $) && (et = st = I)
                      : et < Q
                      ? (et = Q)
                      : st > $
                      ? (st = $)
                      : (st < Q || et > $) && (et = st = 0),
                    _.min > _.max && (et = st = W ? I : 0),
                    (et += j),
                    (st += j),
                    tt && (ot.barX = at += tt[3] / 2),
                    (lt = Math.max(at, 0)),
                    (Z = Math.max(at + ot.pointWidth, 0));
                  var q = K.borderRadius;
                  (q = v((typeof q == "object" ? q.radius : q) || 0, Z - lt)),
                    (ot.shapeArgs = {
                      x: tt[0],
                      y: tt[1],
                      r: Z,
                      innerR: lt,
                      start: et,
                      end: st,
                      borderRadius: q,
                    }),
                    (ot.opacity = et === st ? 0 : void 0),
                    (ot.plotY =
                      (C(this.translatedThreshold) &&
                        (et < this.translatedThreshold ? et : st)) - j);
                } else
                  (et = at + j),
                    (ot.shapeArgs = this.polar.arc(
                      ot.yBottom,
                      ot.plotY,
                      et,
                      et + ot.pointWidth
                    )),
                    (ot.shapeArgs.borderRadius = 0);
                this.polar.toXY(ot),
                  k.inverted
                    ? ((at = _.postTranslate(
                        ot.rectPlotY,
                        at + ot.pointWidth / 2
                      )),
                      (ot.tooltipPos = [at.x - k.plotLeft, at.y - k.plotTop]))
                    : (ot.tooltipPos = [ot.plotX, ot.plotY]),
                  tt && (ot.ttBelow = ot.plotY > tt[1]);
              }
            }
          }
          function T(K, H) {
            const k = this;
            let U;
            if (this.chart.polar) {
              H = H || this.points;
              for (let W = 0; W < H.length; W++)
                if (!H[W].isNull) {
                  var _ = W;
                  break;
                }
              this.options.connectEnds !== !1 &&
                typeof _ < "u" &&
                ((this.connectEnds = !0),
                H.splice(H.length, 0, H[_]),
                (U = !0)),
                H.forEach((W) => {
                  typeof W.polarPlotY > "u" && k.polar.toXY(W);
                });
            }
            return (
              (_ = K.apply(this, [].slice.call(arguments, 1))), U && H.pop(), _
            );
          }
          function D(K, H) {
            const k = this.chart;
            let U = { xAxis: [], yAxis: [] };
            return (
              k.polar
                ? k.axes.forEach((_) => {
                    if (_.coll !== "colorAxis") {
                      var W = _.isXAxis,
                        tt = _.center,
                        j = H.chartX - tt[0] - k.plotLeft;
                      (tt = H.chartY - tt[1] - k.plotTop),
                        U[W ? "xAxis" : "yAxis"].push({
                          axis: _,
                          value: _.translate(
                            W
                              ? Math.PI - Math.atan2(j, tt)
                              : Math.sqrt(Math.pow(j, 2) + Math.pow(tt, 2)),
                            !0
                          ),
                        });
                    }
                  })
                : (U = K.call(this, H)),
              U
            );
          }
          function A(K, H) {
            this.chart.polar || K.call(this, H);
          }
          function m(K, H) {
            const k = this,
              U = this.chart,
              _ = this.group,
              W = this.markerGroup,
              tt = this.xAxis && this.xAxis.center,
              j = U.plotLeft,
              I = U.plotTop;
            let F = this.options.animation,
              V,
              Q,
              $,
              et,
              st;
            U.polar
              ? k.isRadialBar
                ? H ||
                  ((k.startAngleRad = u(
                    k.translatedThreshold,
                    k.xAxis.startAngleRad
                  )),
                  a.seriesTypes.pie.prototype.animate.call(k, H))
                : ((F = b(F)),
                  k.is("column")
                    ? H ||
                      ((V = tt[3] / 2),
                      k.points.forEach((ot) => {
                        (Q = ot.graphic),
                          (et = ($ = ot.shapeArgs) && $.r),
                          (st = $ && $.innerR),
                          Q &&
                            $ &&
                            (Q.attr({ r: V, innerR: V }),
                            Q.animate(
                              { r: et, innerR: st },
                              k.options.animation
                            ));
                      }))
                    : H
                    ? ((K = {
                        translateX: tt[0] + j,
                        translateY: tt[1] + I,
                        scaleX: 0.001,
                        scaleY: 0.001,
                      }),
                      _.attr(K),
                      W && W.attr(K))
                    : ((K = {
                        translateX: j,
                        translateY: I,
                        scaleX: 1,
                        scaleY: 1,
                      }),
                      _.animate(K, F),
                      W && W.animate(K, F)))
              : K.call(this, H);
          }
          function f(K, H, k, U) {
            return (
              this.chart.polar
                ? U
                  ? ((K = G(H, U, !0, this.connectEnds)),
                    (H = K.prevPointCont && K.prevPointCont.rightContX),
                    (k = K.prevPointCont && K.prevPointCont.rightContY),
                    (K = [
                      "C",
                      r(H) ? H : K.plotX,
                      r(k) ? k : K.plotY,
                      r(K.leftContX) ? K.leftContX : K.plotX,
                      r(K.leftContY) ? K.leftContY : K.plotY,
                      K.plotX,
                      K.plotY,
                    ]))
                  : (K = ["M", k.plotX, k.plotY])
                : (K = K.call(this, H, k, U)),
              K
            );
          }
          const { animObject: b } = i,
            {
              addEvent: y,
              defined: C,
              find: o,
              isNumber: r,
              merge: c,
              pick: u,
              relativeLength: v,
              splat: N,
              uniqueKey: w,
              wrap: R,
            } = B,
            X = [];
          class J {
            static compose(H, k, U, _, W, tt, j, I, F) {
              O.compose(H, W),
                B.pushUnique(X, k) &&
                  (y(k, "afterDrawChartBox", Y),
                  y(k, "getAxes", E),
                  y(k, "init", L),
                  R(k.prototype, "get", l)),
                B.pushUnique(X, U) &&
                  ((H = U.prototype),
                  R(H, "getCoordinates", D),
                  R(H, "pinch", A),
                  y(U, "getSelectionMarkerAttrs", S),
                  y(U, "getSelectionBox", z)),
                B.pushUnique(X, _) &&
                  (y(_, "afterInit", x),
                  y(_, "afterTranslate", P, { order: 2 }),
                  y(_, "afterColumnTranslate", g, { order: 4 }),
                  R(_.prototype, "animate", m)),
                j &&
                  B.pushUnique(X, j) &&
                  ((U = j.prototype),
                  R(U, "alignDataLabel", p),
                  R(U, "animate", m)),
                I && B.pushUnique(X, I) && R(I.prototype, "getGraphPath", T),
                F &&
                  B.pushUnique(X, F) &&
                  ((I = F.prototype),
                  R(I, "getPointSpline", f),
                  tt &&
                    B.pushUnique(X, tt) &&
                    (tt.prototype.getPointSpline = I.getPointSpline));
            }
            constructor(H) {
              this.series = H;
            }
            arc(H, k, U, _) {
              const W = this.series,
                tt = W.xAxis.center,
                j = W.yAxis.len,
                I = tt[3] / 2;
              return (
                (k = j - k + I),
                (H = j - u(H, j) + I),
                W.yAxis.reversed && (0 > k && (k = I), 0 > H && (H = I)),
                { x: tt[0], y: tt[1], r: k, innerR: H, start: U, end: _ }
              );
            }
            toXY(H) {
              var k = this.series;
              const U = k.chart,
                _ = k.xAxis;
              var W = k.yAxis;
              const tt = H.plotX,
                j = U.inverted,
                I = H.y;
              let F = H.plotY,
                V = j ? tt : W.len - F;
              j &&
                k &&
                !k.isRadialBar &&
                (H.plotY = F = r(I) ? W.translate(I) : 0),
                (H.rectPlotX = tt),
                (H.rectPlotY = F),
                W.center && (V += W.center[3] / 2),
                r(F) &&
                  ((W = j ? W.postTranslate(F, V) : _.postTranslate(tt, V)),
                  (H.plotX = H.polarPlotX = W.x - U.plotLeft),
                  (H.plotY = H.polarPlotY = W.y - U.plotTop)),
                k.kdByAngle
                  ? ((k =
                      ((tt / Math.PI) * 180 + _.pane.options.startAngle) % 360),
                    0 > k && (k += 360),
                    (H.clientX = k))
                  : (H.clientX = H.plotX);
            }
          }
          return J;
        }
      ),
      n(
        e,
        "masters/highcharts-more.src.js",
        [
          e["Core/Globals.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Series/Bubble/BubbleSeries.js"],
          e["Series/PackedBubble/PackedBubbleSeries.js"],
          e["Series/PolarComposition.js"],
        ],
        function (i, a, d, M, O) {
          d.compose(i.Axis, i.Chart, i.Legend, i.Series),
            M.compose(i.Axis, i.Chart, i.Legend, i.Series),
            O.compose(
              i.Axis,
              i.Chart,
              i.Pointer,
              i.Series,
              i.Tick,
              a.seriesTypes.areasplinerange,
              a.seriesTypes.column,
              a.seriesTypes.line,
              a.seriesTypes.spline
            );
        }
      );
  });
})(ed);
var Op = ed.exports;
const Ip = Ci(Op);
var id = { exports: {} };
(function (t) {
  (function (e) {
    t.exports
      ? ((e.default = e), (t.exports = e))
      : e(typeof Highcharts < "u" ? Highcharts : void 0);
  })(function (e) {
    function n(i, a, d, M) {
      i.hasOwnProperty(a) ||
        ((i[a] = M.apply(null, d)),
        typeof CustomEvent == "function" &&
          window.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: a, module: i[a] },
            })
          ));
    }
    (e = e ? e._modules : {}),
      n(
        e,
        "Series/NodesComposition.js",
        [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const {
              series: {
                prototype: d,
                prototype: {
                  pointClass: { prototype: M },
                },
              },
            } = i,
            { defined: O, extend: B, find: G, merge: Y, pick: L } = a;
          var E;
          return (
            (function (z) {
              function S() {
                return (
                  (this.data = [].concat(this.points || [], this.nodes)),
                  d.destroy.apply(this, arguments)
                );
              }
              function x() {
                this.nodes &&
                  (this.nodes.forEach((l) => {
                    l.destroy();
                  }),
                  (this.nodes.length = 0)),
                  d.setData.apply(this, arguments);
              }
              function P(l) {
                const p = arguments,
                  g = this.isNode
                    ? this.linksTo.concat(this.linksFrom)
                    : [this.fromNode, this.toNode];
                l !== "select" &&
                  g.forEach((T) => {
                    T &&
                      T.series &&
                      (M.setState.apply(T, p),
                      T.isNode ||
                        (T.fromNode.graphic && M.setState.apply(T.fromNode, p),
                        T.toNode &&
                          T.toNode.graphic &&
                          M.setState.apply(T.toNode, p)));
                  }),
                  M.setState.apply(this, p);
              }
              function h(l, p, g, T) {
                const D = this.series.options.nodes,
                  A = this.series.options.data,
                  m = (A && A.length) || 0,
                  f = A && A[this.index];
                M.update.call(this, l, this.isNode ? !1 : p, g, T),
                  this.isNode &&
                    ((l = (D || []).reduce(
                      (b, y, C) => (this.id === y.id ? C : b),
                      -1
                    )),
                    (T = Y((D && D[l]) || {}, (A && A[this.index]) || {})),
                    A && (f ? (A[this.index] = f) : (A.length = m)),
                    D
                      ? 0 <= l
                        ? (D[l] = T)
                        : D.push(T)
                      : (this.series.options.nodes = [T]),
                    L(p, !0) && this.series.chart.redraw(g));
              }
              const s = [];
              (z.compose = function (l, p) {
                return (
                  a.pushUnique(s, l) &&
                    ((l = l.prototype),
                    (l.setNodeState = P),
                    (l.setState = P),
                    (l.update = h)),
                  a.pushUnique(s, p) &&
                    ((l = p.prototype), (l.destroy = S), (l.setData = x)),
                  p
                );
              }),
                (z.createNode = function (l) {
                  const p = this.pointClass;
                  var g = (D, A) => G(D, (m) => m.id === A);
                  let T = g(this.nodes, l);
                  if (!T) {
                    g = this.options.nodes && g(this.options.nodes, l);
                    const D = new p().init(
                      this,
                      B(
                        {
                          className: "highcharts-node",
                          isNode: !0,
                          id: l,
                          y: 1,
                        },
                        g
                      )
                    );
                    (D.linksTo = []),
                      (D.linksFrom = []),
                      (D.getSum = function () {
                        let A = 0,
                          m = 0;
                        return (
                          D.linksTo.forEach((f) => {
                            A += f.weight || 0;
                          }),
                          D.linksFrom.forEach((f) => {
                            m += f.weight || 0;
                          }),
                          Math.max(A, m)
                        );
                      }),
                      (D.offset = function (A, m) {
                        let f = 0;
                        for (let b = 0; b < D[m].length; b++) {
                          if (D[m][b] === A) return f;
                          f += D[m][b].weight;
                        }
                      }),
                      (D.hasShape = function () {
                        let A = 0;
                        return (
                          D.linksTo.forEach((m) => {
                            m.outgoing && A++;
                          }),
                          !D.linksTo.length || A !== D.linksTo.length
                        );
                      }),
                      (D.index = this.nodes.push(D) - 1),
                      (T = D);
                  }
                  return (
                    (T.formatPrefix = "node"),
                    (T.name = T.name || T.options.id || ""),
                    (T.mass = L(
                      T.options.mass,
                      T.options.marker && T.options.marker.radius,
                      this.options.marker && this.options.marker.radius,
                      4
                    )),
                    T
                  );
                }),
                (z.destroy = S),
                (z.generatePoints = function () {
                  const l = this.chart,
                    p = {};
                  d.generatePoints.call(this),
                    this.nodes || (this.nodes = []),
                    (this.colorCounter = 0),
                    this.nodes.forEach((g) => {
                      (g.linksFrom.length = 0),
                        (g.linksTo.length = 0),
                        (g.level = g.options.level);
                    }),
                    this.points.forEach((g) => {
                      O(g.from) &&
                        (p[g.from] || (p[g.from] = this.createNode(g.from)),
                        p[g.from].linksFrom.push(g),
                        (g.fromNode = p[g.from]),
                        l.styledMode
                          ? (g.colorIndex = L(
                              g.options.colorIndex,
                              p[g.from].colorIndex
                            ))
                          : (g.color = g.options.color || p[g.from].color)),
                        O(g.to) &&
                          (p[g.to] || (p[g.to] = this.createNode(g.to)),
                          p[g.to].linksTo.push(g),
                          (g.toNode = p[g.to])),
                        (g.name = g.name || g.id);
                    }, this),
                    (this.nodeLookup = p);
                }),
                (z.setNodeState = P),
                (z.updateNode = h);
            })(E || (E = {})),
            E
          );
        }
      ),
      n(
        e,
        "Series/Sankey/SankeyPoint.js",
        [
          e["Core/Series/Point.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          ({
            seriesTypes: { column: a },
          } = a);
          const { defined: M } = d;
          class O extends a.prototype.pointClass {
            constructor() {
              super(...arguments),
                (this.toNode =
                  this.series =
                  this.options =
                  this.nodeY =
                  this.nodeX =
                  this.mass =
                  this.linksTo =
                  this.linksFrom =
                  this.linkBase =
                  this.level =
                  this.fromNode =
                  this.className =
                    void 0);
            }
            applyOptions(G, Y) {
              return (
                i.prototype.applyOptions.call(this, G, Y),
                M(this.options.level) &&
                  (this.options.column = this.column = this.options.level),
                this
              );
            }
            getClassName() {
              return (
                (this.isNode ? "highcharts-node " : "highcharts-link ") +
                i.prototype.getClassName.call(this)
              );
            }
            getFromNode() {
              let G = -1,
                Y;
              for (let L = 0; L < this.linksTo.length; L++) {
                const E = this.linksTo[L];
                E.fromNode.column > G &&
                  E.fromNode !== this &&
                  ((Y = E.fromNode), (G = Y.column));
              }
              return { fromNode: Y, fromColumn: G };
            }
            setNodeColumn() {
              M(this.options.column) ||
                (this.column =
                  this.linksTo.length === 0
                    ? 0
                    : this.getFromNode().fromColumn + 1);
            }
            isValid() {
              return this.isNode || typeof this.weight == "number";
            }
          }
          return O;
        }
      ),
      n(e, "Series/Sankey/SankeySeriesDefaults.js", [], function () {
        return {
          borderWidth: 0,
          colorByPoint: !0,
          curveFactor: 0.33,
          dataLabels: {
            enabled: !0,
            backgroundColor: "none",
            crop: !1,
            nodeFormat: void 0,
            nodeFormatter: function () {
              return this.point.name;
            },
            format: void 0,
            formatter: function () {},
            inside: !0,
          },
          inactiveOtherPoints: !0,
          linkOpacity: 0.5,
          opacity: 1,
          minLinkWidth: 0,
          nodeWidth: 20,
          nodePadding: 10,
          showInLegend: !1,
          states: {
            hover: { linkOpacity: 1, opacity: 1 },
            inactive: {
              linkOpacity: 0.1,
              opacity: 0.1,
              animation: { duration: 50 },
            },
          },
          tooltip: {
            followPointer: !0,
            headerFormat:
              '<span style="font-size: 0.8em">{series.name}</span><br/>',
            pointFormat:
              "{point.fromNode.name}  {point.toNode.name}: <b>{point.weight}</b><br/>",
            nodeFormat: "{point.name}: <b>{point.sum}</b><br/>",
          },
        };
      }),
      n(
        e,
        "Series/Sankey/SankeyColumnComposition.js",
        [e["Core/Utilities.js"]],
        function (i) {
          const { defined: a, relativeLength: d } = i;
          var M;
          return (
            (function (O) {
              O.compose = function (G, Y) {
                return (G.sankeyColumn = new B(G, Y)), G;
              };
              class B {
                constructor(Y, L) {
                  (this.points = Y), (this.series = L);
                }
                getTranslationFactor(Y) {
                  const L = this.points,
                    E = L.slice(),
                    z = Y.options.minLinkWidth || 0;
                  let S = 0,
                    x,
                    P =
                      (Y.chart.plotSizeY || 0) -
                      (Y.options.borderWidth || 0) -
                      (L.length - 1) * Y.nodePadding;
                  for (; L.length; ) {
                    for (
                      S = P / L.sankeyColumn.sum(), Y = !1, x = L.length;
                      x--;

                    )
                      L[x].getSum() * S < z &&
                        (L.splice(x, 1), (P -= z), (Y = !0));
                    if (!Y) break;
                  }
                  return (
                    (L.length = 0),
                    E.forEach((h) => {
                      L.push(h);
                    }),
                    S
                  );
                }
                top(Y) {
                  const L = this.series,
                    E = L.nodePadding,
                    z = this.points.reduce(function (S, x) {
                      return (
                        0 < S && (S += E),
                        (x = Math.max(
                          x.getSum() * Y,
                          L.options.minLinkWidth || 0
                        )),
                        S + x
                      );
                    }, 0);
                  return ((L.chart.plotSizeY || 0) - z) / 2;
                }
                left(Y) {
                  const L = this.series,
                    E = L.chart,
                    z = L.options.equalNodes,
                    S = E.inverted ? E.plotHeight : E.plotWidth,
                    x = L.nodePadding,
                    P = this.points.reduce(function (h, s) {
                      return (
                        0 < h && (h += x),
                        (s = z
                          ? S / s.series.nodes.length - x
                          : Math.max(
                              s.getSum() * Y,
                              L.options.minLinkWidth || 0
                            )),
                        h + s
                      );
                    }, 0);
                  return ((E.plotSizeX || 0) - Math.round(P)) / 2;
                }
                sum() {
                  return this.points.reduce(function (Y, L) {
                    return Y + L.getSum();
                  }, 0);
                }
                offset(Y, L) {
                  const E = this.points,
                    z = this.series,
                    S = z.nodePadding;
                  let x = 0;
                  if (z.is("organization") && Y.hangsFrom)
                    return { absoluteTop: Y.hangsFrom.nodeY };
                  for (let h = 0; h < E.length; h++) {
                    var P = E[h].getSum();
                    const s = Math.max(P * L, z.options.minLinkWidth || 0),
                      l =
                        Y.options[
                          z.chart.inverted
                            ? "offsetHorizontal"
                            : "offsetVertical"
                        ],
                      p = Y.options.offset || 0;
                    if (((P = P ? s + S : 0), E[h] === Y))
                      return { relativeTop: x + (a(l) ? d(l, s) : d(p, P)) };
                    x += P;
                  }
                }
              }
              O.SankeyColumnAdditions = B;
            })(M || (M = {})),
            M
          );
        }
      ),
      n(
        e,
        "Series/TreeUtilities.js",
        [e["Core/Color/Color.js"], e["Core/Utilities.js"]],
        function (i, a) {
          function d(E, z) {
            var S = z.before;
            const x = z.idRoot,
              P = z.mapIdToNode[x],
              h = z.points[E.i],
              s = (h && h.options) || {},
              l = [];
            let p = 0;
            return (
              (E.levelDynamic =
                E.level - (z.levelIsConstant !== !1 ? 0 : P.level)),
              (E.name = L(h && h.name, "")),
              (E.visible = x === E.id || z.visible === !0),
              typeof S == "function" && (E = S(E, z)),
              E.children.forEach((g, T) => {
                const D = M({}, z);
                M(D, {
                  index: T,
                  siblings: E.children.length,
                  visible: E.visible,
                }),
                  (g = d(g, D)),
                  l.push(g),
                  g.visible && (p += g.val);
              }),
              (S = L(s.value, p)),
              (E.visible = 0 <= S && (0 < p || E.visible)),
              (E.children = l),
              (E.childrenTotal = p),
              (E.isLeaf = E.visible && !p),
              (E.val = S),
              E
            );
          }
          const {
            extend: M,
            isArray: O,
            isNumber: B,
            isObject: G,
            merge: Y,
            pick: L,
          } = a;
          return {
            getColor: function (E, z) {
              const S = z.index;
              var x = z.mapOptionsToLevel;
              const P = z.parentColor,
                h = z.parentColorIndex,
                s = z.series;
              var l = z.colors;
              const p = z.siblings;
              var g = s.points,
                T = s.chart.options.chart;
              let D;
              var A;
              let m;
              if (E) {
                if (
                  ((g = g[E.i]),
                  (E = x[E.level] || {}),
                  (x = g && E.colorByPoint))
                ) {
                  D = g.index % (l ? l.length : T.colorCount);
                  var f = l && l[D];
                }
                s.chart.styledMode ||
                  ((l = g && g.options.color),
                  (T = E && E.color),
                  (A = P) &&
                    (A =
                      (A = E && E.colorVariation) &&
                      A.key === "brightness" &&
                      S &&
                      p
                        ? i
                            .parse(P)
                            .brighten((S / p) * A.to)
                            .get()
                        : P),
                  (A = L(l, T, f, A, s.color))),
                  (m = L(
                    g && g.options.colorIndex,
                    E && E.colorIndex,
                    D,
                    h,
                    z.colorIndex
                  ));
              }
              return { color: A, colorIndex: m };
            },
            getLevelOptions: function (E) {
              let z = {},
                S,
                x,
                P;
              if (G(E)) {
                P = B(E.from) ? E.from : 1;
                var h = E.levels;
                for (
                  x = {},
                    S = G(E.defaults) ? E.defaults : {},
                    O(h) &&
                      (x = h.reduce((s, l) => {
                        let p, g;
                        return (
                          G(l) &&
                            B(l.level) &&
                            ((g = Y({}, l)),
                            (p = L(g.levelIsConstant, S.levelIsConstant)),
                            delete g.levelIsConstant,
                            delete g.level,
                            (l = l.level + (p ? 0 : P - 1)),
                            G(s[l]) ? Y(!0, s[l], g) : (s[l] = g)),
                          s
                        );
                      }, {})),
                    h = B(E.to) ? E.to : 1,
                    E = 0;
                  E <= h;
                  E++
                )
                  z[E] = Y({}, S, G(x[E]) ? x[E] : {});
              }
              return z;
            },
            setTreeValues: d,
            updateRootId: function (E) {
              if (G(E)) {
                var z = G(E.options) ? E.options : {};
                (z = L(E.rootNode, z.rootId, "")),
                  G(E.userOptions) && (E.userOptions.rootId = z),
                  (E.rootNode = z);
              }
              return z;
            },
          };
        }
      ),
      n(
        e,
        "Series/Sankey/SankeySeries.js",
        [
          e["Core/Color/Color.js"],
          e["Core/Globals.js"],
          e["Series/NodesComposition.js"],
          e["Series/Sankey/SankeyPoint.js"],
          e["Series/Sankey/SankeySeriesDefaults.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Series/Sankey/SankeyColumnComposition.js"],
          e["Series/TreeUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B, G, Y, L) {
          const {
              series: E,
              seriesTypes: { column: z },
            } = B,
            { getLevelOptions: S } = Y,
            {
              clamp: x,
              extend: P,
              isObject: h,
              merge: s,
              pick: l,
              relativeLength: p,
              stableSort: g,
            } = L;
          class T extends z {
            constructor() {
              super(...arguments),
                (this.translationFactor =
                  this.points =
                  this.options =
                  this.nodeWidth =
                  this.nodes =
                  this.nodePadding =
                  this.nodeLookup =
                  this.group =
                  this.data =
                  this.colDistance =
                    void 0);
            }
            static getDLOptions(A) {
              const m = h(A.optionsPoint) ? A.optionsPoint.dataLabels : {};
              return (
                (A = h(A.level) ? A.level.dataLabels : {}),
                s({ style: {} }, A, m)
              );
            }
            createNodeColumns() {
              const A = [];
              this.nodes.forEach(function (m) {
                m.setNodeColumn(),
                  A[m.column] || (A[m.column] = G.compose([], this)),
                  A[m.column].push(m);
              }, this);
              for (let m = 0; m < A.length; m++)
                typeof A[m] > "u" && (A[m] = G.compose([], this));
              return A;
            }
            order(A, m) {
              const f = this;
              typeof A.level > "u" &&
                ((A.level = m),
                A.linksFrom.forEach(function (b) {
                  b.toNode && f.order(b.toNode, m + 1);
                }));
            }
            generatePoints() {
              d.generatePoints.apply(this, arguments);
              const A = this;
              this.orderNodes &&
                (this.nodes
                  .filter(function (m) {
                    return m.linksTo.length === 0;
                  })
                  .forEach(function (m) {
                    A.order(m, 0);
                  }),
                g(this.nodes, function (m, f) {
                  return m.level - f.level;
                }));
            }
            getNodePadding() {
              let A = this.options.nodePadding || 0;
              if (this.nodeColumns) {
                const m = this.nodeColumns.reduce(
                  (f, b) => Math.max(f, b.length),
                  0
                );
                m * A > this.chart.plotSizeY && (A = this.chart.plotSizeY / m);
              }
              return A;
            }
            hasData() {
              return !!this.processedXData.length;
            }
            pointAttribs(A, m) {
              if (!A) return {};
              const f = this,
                b =
                  f.mapOptionsToLevel[
                    (A.isNode ? A.level : A.fromNode.level) || 0
                  ] || {},
                y = A.options,
                C = (b.states && b.states[m || ""]) || {};
              m = [
                "colorByPoint",
                "borderColor",
                "borderWidth",
                "linkOpacity",
                "opacity",
              ].reduce(function (r, c) {
                return (r[c] = l(C[c], y[c], b[c], f.options[c])), r;
              }, {});
              const o = l(C.color, y.color, m.colorByPoint ? A.color : b.color);
              return A.isNode
                ? {
                    fill: o,
                    stroke: m.borderColor,
                    "stroke-width": m.borderWidth,
                    opacity: m.opacity,
                  }
                : { fill: i.parse(o).setOpacity(m.linkOpacity).get() };
            }
            drawTracker() {
              z.prototype.drawTracker.call(this, this.points),
                z.prototype.drawTracker.call(this, this.nodes);
            }
            drawPoints() {
              z.prototype.drawPoints.call(this, this.points),
                z.prototype.drawPoints.call(this, this.nodes);
            }
            drawDataLabels() {
              z.prototype.drawDataLabels.call(this, this.points),
                z.prototype.drawDataLabels.call(this, this.nodes);
            }
            translate() {
              this.processedXData || this.processData(),
                this.generatePoints(),
                (this.nodeColumns = this.createNodeColumns()),
                (this.nodeWidth = p(
                  this.options.nodeWidth,
                  this.chart.plotSizeX
                ));
              const A = this,
                m = this.chart,
                f = this.options,
                b = this.nodeWidth,
                y = this.nodeColumns;
              (this.nodePadding = this.getNodePadding()),
                (this.translationFactor = y.reduce(
                  (C, o) => Math.min(C, o.sankeyColumn.getTranslationFactor(A)),
                  1 / 0
                )),
                (this.colDistance =
                  (m.plotSizeX - b - f.borderWidth) /
                  Math.max(1, y.length - 1)),
                (A.mapOptionsToLevel = S({
                  from: 1,
                  levels: f.levels,
                  to: y.length - 1,
                  defaults: {
                    borderColor: f.borderColor,
                    borderRadius: f.borderRadius,
                    borderWidth: f.borderWidth,
                    color: A.color,
                    colorByPoint: f.colorByPoint,
                    levelIsConstant: !0,
                    linkColor: f.linkColor,
                    linkLineWidth: f.linkLineWidth,
                    linkOpacity: f.linkOpacity,
                    states: f.states,
                  },
                })),
                y.forEach(function (C) {
                  C.forEach(function (o) {
                    A.translateNode(o, C);
                  });
                }, this),
                this.nodes.forEach(function (C) {
                  C.linksFrom.forEach(function (o) {
                    (o.weight || o.isNull) &&
                      o.to &&
                      (A.translateLink(o), (o.allowShadow = !1));
                  });
                });
            }
            translateLink(A) {
              var m = (R, X) => (
                (X = R.offset(A, X) * C),
                Math.min(
                  R.nodeY + X,
                  R.nodeY + ((R.shapeArgs && R.shapeArgs.height) || 0) - o
                )
              );
              let f = A.fromNode;
              var b = A.toNode;
              let y = this.chart,
                C = this.translationFactor,
                o = Math.max(A.weight * C, this.options.minLinkWidth);
              var r =
                (y.inverted ? -this.colDistance : this.colDistance) *
                this.options.curveFactor;
              let c = m(f, "linksFrom");
              m = m(b, "linksTo");
              let u = f.nodeX,
                v = this.nodeWidth;
              b = b.nodeX;
              var N = A.outgoing,
                w = b > u + v;
              if (
                (y.inverted &&
                  ((c = y.plotSizeY - c),
                  (m = (y.plotSizeY || 0) - m),
                  (v = -v),
                  (o = -o),
                  (w = u > b)),
                (A.shapeType = "path"),
                (A.linkBase = [c, c + o, m, m + o]),
                w && typeof m == "number")
              )
                A.shapeArgs = {
                  d: [
                    ["M", u + v, c],
                    ["C", u + v + r, c, b - r, m, b, m],
                    ["L", b + (N ? v : 0), m + o / 2],
                    ["L", b, m + o],
                    ["C", b - r, m + o, u + v + r, c + o, u + v, c + o],
                    ["Z"],
                  ],
                };
              else if (typeof m == "number") {
                (r = b - 20 - o), (N = b - 20), (w = u + v);
                const R = w + 20,
                  X = R + o,
                  J = c,
                  K = c + o,
                  H = K + 20,
                  k = H + (y.plotHeight - c - o),
                  U = k + 20,
                  _ = U + o,
                  W = m,
                  tt = W + o,
                  j = tt + 20,
                  I = U + 0.7 * o,
                  F = b - 0.7 * o,
                  V = w + 0.7 * o;
                A.shapeArgs = {
                  d: [
                    ["M", w, J],
                    ["C", V, J, X, K - 0.7 * o, X, H],
                    ["L", X, k],
                    ["C", X, I, V, _, w, _],
                    ["L", b, _],
                    ["C", F, _, r, I, r, k],
                    ["L", r, j],
                    ["C", r, tt - 0.7 * o, F, W, b, W],
                    ["L", b, tt],
                    ["C", N, tt, N, tt, N, j],
                    ["L", N, k],
                    ["C", N, U, N, U, b, U],
                    ["L", w, U],
                    ["C", R, U, R, U, R, k],
                    ["L", R, H],
                    ["C", R, K, R, K, w, K],
                    ["Z"],
                  ],
                };
              }
              (A.dlBox = {
                x: u + (b - u + v) / 2,
                y: c + (m - c) / 2,
                height: o,
                width: 0,
              }),
                (A.tooltipPos = y.inverted
                  ? [y.plotSizeY - A.dlBox.y - o / 2, y.plotSizeX - A.dlBox.x]
                  : [A.dlBox.x, A.dlBox.y + o / 2]),
                (A.y = A.plotY = 1),
                (A.x = A.plotX = 1),
                A.color || (A.color = f.color);
            }
            translateNode(A, m) {
              var f = this.translationFactor;
              const b = this.chart,
                y = this.options,
                { borderRadius: C, borderWidth: o = 0 } = y;
              var r = A.getSum();
              const c = Math.max(Math.round(r * f), this.options.minLinkWidth),
                u = Math.round(this.nodeWidth);
              var v = (Math.round(o) % 2) / 2,
                N = m.sankeyColumn.offset(A, f);
              if (
                ((m =
                  Math.floor(
                    l(N.absoluteTop, m.sankeyColumn.top(f) + N.relativeTop)
                  ) + v),
                (v =
                  Math.floor(this.colDistance * A.column + o / 2) +
                  p(A.options.offsetHorizontal || 0, u) +
                  v),
                (v = b.inverted ? b.plotSizeX - v : v),
                (A.sum = r))
              ) {
                (A.shapeType = "roundedRect"),
                  (A.nodeX = v),
                  (A.nodeY = m),
                  (r = v),
                  (f = m),
                  (N = A.options.width || y.width || u);
                let w = A.options.height || y.height || c;
                const R = x(
                  p(typeof C == "object" ? C.radius : C || 0, N),
                  0,
                  c / 2
                );
                b.inverted &&
                  ((r = v - u),
                  (f = b.plotSizeY - m - c),
                  (N = A.options.height || y.height || u),
                  (w = A.options.width || y.width || c)),
                  (A.dlOptions = T.getDLOptions({
                    level: this.mapOptionsToLevel[A.level],
                    optionsPoint: A.options,
                  })),
                  (A.plotX = 1),
                  (A.plotY = 1),
                  (A.tooltipPos = b.inverted
                    ? [b.plotSizeY - f - w / 2, b.plotSizeX - r - N / 2]
                    : [r + N / 2, f + w / 2]),
                  (A.shapeArgs = {
                    x: r,
                    y: f,
                    width: N,
                    height: w,
                    r: R,
                    display: A.hasShape() ? "" : "none",
                  });
              } else A.dlOptions = { enabled: !1 };
            }
          }
          return (
            (T.defaultOptions = s(z.defaultOptions, O)),
            d.compose(M, T),
            P(T.prototype, {
              animate: E.prototype.animate,
              createNode: d.createNode,
              forceDL: !0,
              invertible: !0,
              isCartesian: !1,
              orderNodes: !0,
              noSharedTooltip: !0,
              pointArrayMap: ["from", "to", "weight"],
              pointClass: M,
              searchPoint: a.noop,
            }),
            B.registerSeriesType("sankey", T),
            T
          );
        }
      ),
      n(e, "masters/modules/sankey.src.js", [], function () {});
  });
})(id);
var Bp = id.exports;
const Rp = Ci(Bp);
var nd = { exports: {} };
(function (t, e) {
  (function (n, i) {
    t.exports = i(Ft);
  })(typeof self < "u" ? self : Hl, function (n) {
    return (function (i) {
      function a(M) {
        if (d[M]) return d[M].exports;
        var O = (d[M] = { i: M, l: !1, exports: {} });
        return i[M].call(O.exports, O, O.exports, a), (O.l = !0), O.exports;
      }
      var d = {};
      return (
        (a.m = i),
        (a.c = d),
        (a.d = function (M, O, B) {
          a.o(M, O) ||
            Object.defineProperty(M, O, {
              configurable: !1,
              enumerable: !0,
              get: B,
            });
        }),
        (a.n = function (M) {
          var O =
            M && M.__esModule
              ? function () {
                  return M.default;
                }
              : function () {
                  return M;
                };
          return a.d(O, "a", O), O;
        }),
        (a.o = function (M, O) {
          return Object.prototype.hasOwnProperty.call(M, O);
        }),
        (a.p = ""),
        a((a.s = 0))
      );
    })([
      function (i, a, d) {
        function M() {
          return (
            (M = Object.assign
              ? Object.assign.bind()
              : function (s) {
                  for (var l = 1; l < arguments.length; l++) {
                    var p = arguments[l];
                    for (var g in p)
                      Object.prototype.hasOwnProperty.call(p, g) &&
                        (s[g] = p[g]);
                  }
                  return s;
                }),
            M.apply(this, arguments)
          );
        }
        function O(s) {
          return L(s) || Y(s) || G(s) || B();
        }
        function B() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function G(s, l) {
          if (s) {
            if (typeof s == "string") return E(s, l);
            var p = Object.prototype.toString.call(s).slice(8, -1);
            return (
              p === "Object" && s.constructor && (p = s.constructor.name),
              p === "Map" || p === "Set"
                ? Array.from(s)
                : p === "Arguments" ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(p)
                ? E(s, l)
                : void 0
            );
          }
        }
        function Y(s) {
          if (
            (typeof Symbol < "u" && s[Symbol.iterator] != null) ||
            s["@@iterator"] != null
          )
            return Array.from(s);
        }
        function L(s) {
          if (Array.isArray(s)) return E(s);
        }
        function E(s, l) {
          (l == null || l > s.length) && (l = s.length);
          for (var p = 0, g = new Array(l); p < l; p++) g[p] = s[p];
          return g;
        }
        function z(s) {
          "@babel/helpers - typeof";
          return (z =
            typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
              ? function (l) {
                  return typeof l;
                }
              : function (l) {
                  return l &&
                    typeof Symbol == "function" &&
                    l.constructor === Symbol &&
                    l !== Symbol.prototype
                    ? "symbol"
                    : typeof l;
                })(s);
        }
        Object.defineProperty(a, "__esModule", { value: !0 }),
          d.d(a, "HighchartsReact", function () {
            return h;
          });
        var S = d(1),
          x = d.n(S),
          P = typeof window < "u" ? S.useLayoutEffect : S.useEffect,
          h = Object(S.memo)(
            Object(S.forwardRef)(function (s, l) {
              var p = Object(S.useRef)(),
                g = Object(S.useRef)(),
                T = Object(S.useRef)(s.constructorType),
                D = Object(S.useRef)(s.highcharts);
              return (
                P(
                  function () {
                    function A() {
                      var f =
                          s.highcharts ||
                          ((typeof window > "u" ? "undefined" : z(window)) ===
                            "object" &&
                            window.Highcharts),
                        b = s.constructorType || "chart";
                      f
                        ? f[b]
                          ? s.options
                            ? (g.current = f[b](
                                p.current,
                                s.options,
                                s.callback
                              ))
                            : console.warn(
                                'The "options" property was not passed.'
                              )
                          : console.warn(
                              'The "constructorType" property is incorrect or some required module is not imported.'
                            )
                        : console.warn(
                            'The "highcharts" property was not passed.'
                          );
                    }
                    if (g.current) {
                      if (s.allowChartUpdate !== !1)
                        if (
                          s.constructorType !== T.current ||
                          s.highcharts !== D.current
                        )
                          (T.current = s.constructorType),
                            (D.current = s.highcharts),
                            A();
                        else if (!s.immutable && g.current) {
                          var m;
                          (m = g.current).update.apply(
                            m,
                            [s.options].concat(O(s.updateArgs || [!0, !0]))
                          );
                        } else A();
                    } else A();
                  },
                  [
                    s.options,
                    s.allowChartUpdate,
                    s.updateArgs,
                    s.containerProps,
                    s.highcharts,
                    s.constructorType,
                  ]
                ),
                P(function () {
                  return function () {
                    g.current && (g.current.destroy(), (g.current = null));
                  };
                }, []),
                Object(S.useImperativeHandle)(
                  l,
                  function () {
                    return {
                      get chart() {
                        return g.current;
                      },
                      container: p,
                    };
                  },
                  []
                ),
                x.a.createElement("div", M({}, s.containerProps, { ref: p }))
              );
            })
          );
        a.default = h;
      },
      function (i, a) {
        i.exports = n;
      },
    ]);
  });
})(nd);
var zp = nd.exports;
const Fp = Ci(zp);
var sd = { exports: {} };
(function (t) {
  (function (e) {
    t.exports
      ? ((e.default = e), (t.exports = e))
      : e(typeof Highcharts < "u" ? Highcharts : void 0);
  })(function (e) {
    function n(i, a, d, M) {
      i.hasOwnProperty(a) ||
        ((i[a] = M.apply(null, d)),
        typeof CustomEvent == "function" &&
          window.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: a, module: i[a] },
            })
          ));
    }
    (e = e ? e._modules : {}),
      n(
        e,
        "Series/VariablePie/VariablePieSeries.js",
        [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const {
              seriesTypes: { pie: d },
            } = i,
            {
              arrayMax: M,
              arrayMin: O,
              clamp: B,
              extend: G,
              fireEvent: Y,
              merge: L,
              pick: E,
            } = a;
          class z extends d {
            constructor() {
              super(...arguments),
                (this.radii = this.points = this.options = this.data = void 0);
            }
            calculateExtremes() {
              var x = this.chart;
              let P = this.options;
              var h = this.zData;
              let s =
                  Math.min(x.plotWidth, x.plotHeight) -
                  2 * (P.slicedOffset || 0),
                l = {};
              (x = this.center || this.getCenter()),
                ["minPointSize", "maxPointSize"].forEach(function (p) {
                  let g = P[p],
                    T = /%$/.test(g);
                  (g = parseInt(g, 10)), (l[p] = T ? (s * g) / 100 : 2 * g);
                }),
                (this.minPxSize = x[3] + l.minPointSize),
                (this.maxPxSize = B(
                  x[2],
                  x[3] + l.minPointSize,
                  l.maxPointSize
                )),
                h.length &&
                  ((x = E(P.zMin, O(h.filter(this.zValEval)))),
                  (h = E(P.zMax, M(h.filter(this.zValEval)))),
                  this.getRadii(x, h, this.minPxSize, this.maxPxSize));
            }
            getRadii(x, P, h, s) {
              let l = 0,
                p = this.zData,
                g = p.length,
                T = [],
                D = this.options.sizeBy !== "radius",
                A = P - x;
              for (l; l < g; l++) {
                var m = this.zValEval(p[l]) ? p[l] : x;
                m <= x
                  ? (m = h / 2)
                  : m >= P
                  ? (m = s / 2)
                  : ((m = 0 < A ? (m - x) / A : 0.5),
                    D && (m = Math.sqrt(m)),
                    (m = Math.ceil(h + m * (s - h)) / 2)),
                  T.push(m);
              }
              this.radii = T;
            }
            redraw() {
              (this.center = null), super.redraw.apply(this, arguments);
            }
            translate(x) {
              this.generatePoints();
              let P = 0;
              var h = this.options;
              let s = h.slicedOffset,
                l = s + (h.borderWidth || 0);
              var p = h.startAngle || 0;
              let g = (Math.PI / 180) * (p - 90);
              var T = (Math.PI / 180) * (E(h.endAngle, p + 360) - 90);
              p = T - g;
              let D = this.points,
                A,
                m = h.dataLabels.distance;
              h = h.ignoreHiddenPoint;
              let f = D.length,
                b;
              for (
                this.startAngleRad = g,
                  this.endAngleRad = T,
                  this.calculateExtremes(),
                  x || (this.center = x = this.getCenter()),
                  T = 0;
                T < f;
                T++
              ) {
                b = D[T];
                var y = this.radii[T];
                (b.labelDistance = E(
                  b.options.dataLabels && b.options.dataLabels.distance,
                  m
                )),
                  (this.maxLabelDistance = Math.max(
                    this.maxLabelDistance || 0,
                    b.labelDistance
                  ));
                var C = g + P * p;
                (!h || b.visible) && (P += b.percentage / 100);
                var o = g + P * p;
                (b.shapeType = "arc"),
                  (b.shapeArgs = {
                    x: x[0],
                    y: x[1],
                    r: y,
                    innerR: x[3] / 2,
                    start: Math.round(1e3 * C) / 1e3,
                    end: Math.round(1e3 * o) / 1e3,
                  }),
                  (C = (o + C) / 2),
                  C > 1.5 * Math.PI
                    ? (C -= 2 * Math.PI)
                    : C < -Math.PI / 2 && (C += 2 * Math.PI),
                  (b.slicedTranslation = {
                    translateX: Math.round(Math.cos(C) * s),
                    translateY: Math.round(Math.sin(C) * s),
                  });
                var r = (Math.cos(C) * x[2]) / 2;
                (A = (Math.sin(C) * x[2]) / 2),
                  (o = Math.cos(C) * y),
                  (y *= Math.sin(C)),
                  (b.tooltipPos = [x[0] + 0.7 * r, x[1] + 0.7 * A]),
                  (b.half = C < -Math.PI / 2 || C > Math.PI / 2 ? 1 : 0),
                  (b.angle = C),
                  (r = Math.min(l, b.labelDistance / 5)),
                  (b.labelPosition = {
                    natural: {
                      x: x[0] + o + Math.cos(C) * b.labelDistance,
                      y: x[1] + y + Math.sin(C) * b.labelDistance,
                    },
                    computed: {},
                    alignment: b.half ? "right" : "left",
                    connectorPosition: {
                      breakAt: {
                        x: x[0] + o + Math.cos(C) * r,
                        y: x[1] + y + Math.sin(C) * r,
                      },
                      touchingSliceAt: { x: x[0] + o, y: x[1] + y },
                    },
                  });
              }
              Y(this, "afterTranslate");
            }
            zValEval(x) {
              return typeof x != "number" || isNaN(x) ? null : !0;
            }
          }
          return (
            (z.defaultOptions = L(d.defaultOptions, {
              minPointSize: "10%",
              maxPointSize: "100%",
              zMin: void 0,
              zMax: void 0,
              sizeBy: "area",
              tooltip: {
                pointFormat:
                  '<span style="color:{point.color}"></span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>',
              },
            })),
            G(z.prototype, {
              pointArrayMap: ["y", "z"],
              parallelArrays: ["x", "y", "z"],
            }),
            i.registerSeriesType("variablepie", z),
            z
          );
        }
      ),
      n(e, "masters/modules/variable-pie.src.js", [], function () {});
  });
})(sd);
var Hp = sd.exports;
const Up = Ci(Hp),
  Ct = {
    Design: {
      name: "Design",
      color: "#db5461",
      projects: 12,
      experience: 76,
      sort: 1,
    },
    Frontend: {
      name: "Frontend",
      color: "#ffb133",
      projects: 12,
      experience: 130,
      sort: 2,
    },
    Backend: {
      name: "Backend",
      color: "#0e79b2",
      projects: 10,
      experience: 110,
      sort: 3,
    },
    Integration: {
      name: "Integration",
      color: "#ecdcb0",
      projects: 10,
      experience: 70,
      sort: 4,
    },
    DevOps: {
      name: "DevOps",
      color: "#8cc084",
      projects: 8,
      experience: 80,
      sort: 5,
    },
  },
  pt = {
    Photoshop: {
      name: "Photoshop",
      image: "",
      type: Ct.Design,
      experience: 48 + 10,
      projects: 12,
    },
    Illustrator: {
      name: "Illustrator",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 60 + 10,
      projects: 10,
    },
    Figma: {
      name: "Figma",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 14 + 10,
      projects: 3,
    },
    AdobeXD: {
      name: "Adobe XD",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 8 + 10,
      projects: 2,
    },
    Max: {
      name: "3ds Max",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 42 + 10,
      projects: 10,
    },
    AutoCAD: {
      name: "AutoCAD",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 39 + 10,
      projects: 7,
    },
    InDesign: {
      name: "InDesign",
      image: "",
      type: Ct.Design,
      color: "#db5461",
      experience: 39 + 10,
      projects: 6,
    },
    HTML: {
      name: "HTML/CSS/JS",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 120 + 10,
      projects: 15,
    },
    Typescript: {
      name: "Typescript",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 56 + 10,
      projects: 8,
    },
    React: {
      name: "React",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 19 + 10,
      projects: 3,
    },
    Vue: {
      name: "Vue JS",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 58 + 10,
      projects: 10,
    },
    Angular: {
      name: "Angular",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 12 + 10,
      projects: 2,
    },
    PWA: {
      name: "Progressive Web App",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 19 + 10,
      projects: 3,
    },
    Material: {
      name: "Material Design",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 60 + 10,
      projects: 8,
    },
    JQuery: {
      name: "jQuery",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 38 + 10,
      projects: 3,
    },
    Quasar: {
      name: "Quasar",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 48 + 10,
      projects: 6,
    },
    PDF: {
      name: "PDF Generation",
      image: "",
      type: Ct.Frontend,
      color: "#ffb133",
      experience: 70 + 10,
      projects: 6,
    },
    MySQL: {
      name: "MySQL",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 70 + 10,
      projects: 10,
    },
    Node: {
      name: "NodeJS",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 40 + 10,
      projects: 8,
    },
    ColdFusion: {
      name: "ColdFusion/Lucee",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 60 + 10,
      projects: 3,
    },
    PHP: {
      name: "PHP",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 25 + 10,
      projects: 4,
    },
    NET: {
      name: ".NET",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 30 + 10,
      projects: 5,
    },
    Python: {
      name: "Python",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 12 + 10,
      projects: 2,
    },
    Go: {
      name: "GoLang",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 6 + 10,
      projects: 1,
    },
    EntityFramework: {
      name: "Entity Framework",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 30 + 10,
      projects: 4,
    },
    PostgreSQL: {
      name: "PostgreSQL",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 40 + 10,
      projects: 6,
    },
    MSSQL: {
      name: "Microsoft SQL Server",
      image: "",
      type: Ct.Backend,
      color: "#0e79b2",
      experience: 20 + 10,
      projects: 4,
    },
    NetSuite: {
      name: "NetSuite/SuiteScript",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 70 + 10,
      projects: 3,
    },
    QuickBooks: {
      name: "QuickBooks",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 20 + 10,
      projects: 3,
    },
    Salesforce: {
      name: "Salesforce",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 12 + 10,
      projects: 1,
    },
    Maps: {
      name: "Google Maps",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 40 + 10,
      projects: 6,
    },
    Plaid: {
      name: "Plaid/Stripe/Checkbook",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 18 + 10,
      projects: 2,
    },
    Stripe: {
      name: "Stripe",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 18 + 10,
      projects: 2,
    },
    Checkbook: {
      name: "Checkbook",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 5 + 10,
      projects: 1,
    },
    Auth0: {
      name: "Auth0/Octa/Cognito",
      image: "",
      type: Ct.Integration,
      color: "#ecdcb0",
      experience: 40 + 10,
      projects: 6,
    },
    Bash: {
      name: "Bash/CLI",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 72 + 10,
      projects: 10,
    },
    CI: {
      name: "CI/CD",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 26 + 10,
      projects: 6,
    },
    Git: {
      name: "Git/Github/Actions",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 80 + 10,
      projects: 12,
    },
    AWS: {
      name: "AWS/EC2/S3/SES",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 62 + 10,
      projects: 11,
    },
    Lambda: {
      name: "AWS/Lambda/Elastic Beanstalk/RDS",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 50 + 10,
      projects: 6,
    },
    CloudFront: {
      name: "AWS CloudFront/CloudWatch/Route53",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 50 + 10,
      projects: 8,
    },
    CodeDeploy: {
      name: "AWS CodeDeploy/CodePipeline",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 12 + 10,
      projects: 1,
    },
    Azure: {
      name: "Azure",
      image: "",
      type: Ct.DevOps,
      color: "#8cc084",
      experience: 30 + 10,
      projects: 2,
    },
  },
  Gp = [
    {
      type: "Professional",
      name: "Critical View",
      url: "https://criticalview.us",
      description:
        "Due to the success of SiteView I've received many enquiries for building similar platforms for other companies in the industry. Critical View is one of them. Custom tailored to fit Critical Components needs it includes modules for site and asset management, work orders, service reports, pdf generation, scheduling and more. It is a highly scalable, fast and reliable application. Some other major features are mobile and offline support, scope of work management, advanced inventory system and task management. Unfortunately, it is not publicly available. I am happy to provide a demo upon request.",
      start: new Date(2023, 5, 1),
      end: new Date(),
      company: "Critical Components Inc",
      preview: "/iamdustin/projects/Critical View/preview.png",
      images: [
        {
          src: "/iamdustin/projects/Critical View/preview.png",
          title: "Scope of Work Management",
        },
        {
          src: "/iamdustin/projects/Critical View/Service Report Generation.png",
          title: "PDF Generation",
        },
        {
          src: "/iamdustin/projects/Critical View/Task Management.png",
          title: "Task Management",
        },
        {
          src: "/iamdustin/projects/Critical View/Task Management - Mobile.png",
          title: "Mobile Support",
        },
        {
          src: "/iamdustin/projects/Critical View/Add Customer Dialog.png",
          title: "Form Design and Validation",
        },
      ],
      roles: [
        "Architecture",
        "Design",
        "Frontend",
        "Backend",
        "DevOps",
        "Maintenance",
        "Tech Support",
      ],
      tools: [
        pt.Typescript,
        pt.Vue,
        pt.Quasar,
        pt.Material,
        pt.Node,
        pt.PostgreSQL,
        pt.Maps,
        pt.QuickBooks,
        pt.Bash,
        pt.Git,
        pt.CI,
        pt.AWS,
        pt.Lambda,
      ],
    },
    {
      hideInList: !0,
      type: "Professional",
      name: "Tech Smart",
      url: "https://techsmart.app",
      description: "",
      start: new Date(2023, 5, 1),
      end: new Date(),
      company: "DandCode",
      images: [],
      roles: [
        "Architecture",
        "Design",
        "Frontend",
        "Backend",
        "DevOps",
        "Maintenance",
        "Tech Support",
      ],
      tools: [
        pt.Typescript,
        pt.Vue,
        pt.Quasar,
        pt.Material,
        pt.Node,
        pt.PostgreSQL,
        pt.Maps,
        pt.Salesforce,
        pt.Bash,
        pt.Git,
        pt.CI,
        pt.AWS,
        pt.Lambda,
      ],
    },
    {
      type: "Startup",
      name: "Get Actual",
      url: "https://getactual.io",
      preview: "/iamdustin/projects/GetActual/preview.png",
      description:
        "Get Actual is an ERP/CRM system for production studios. It includes modules for project management, time tracking, proposals, invoicing, payments, etc. As part of the team I was responsible for api integrations with various third parties - QuickBooks, Checkbook, Plaid, Butler, Salesforce, etc. I also worked on setting up their subscription and payment services, automating the notification system as well as various other features and bug fixes. One of my first tasks was implementing their frontpage redesign. I also helped with is migrating part of the codebase from Javascript to Typescript. It was great experience working with a creative team and solving unique challenges in the entertainment industry",
      start: new Date(2022, 2, 1),
      end: new Date(2023, 5, 1),
      company: "Get Actual",
      images: [
        {
          src: "/iamdustin/projects/GetActual/get-actual-home-2.gif",
          title: "Get Actual Homepage",
        },
        {
          src: "/iamdustin/projects/GetActual/quickbooks-estimate.gif",
          title: "QuickBooks integration",
        },
        {
          src: "/iamdustin/projects/GetActual/Monthly Statement.png",
          title: "Monthly Statement Example",
        },
        {
          src: "/iamdustin/projects/GetActual/Payment notification.png",
          title: "Payment Notification Example",
        },
      ],
      roles: ["Frontend", "Backend", "Integration"],
      tools: [
        pt.Typescript,
        pt.Material,
        pt.React,
        pt.Node,
        pt.PostgreSQL,
        pt.HTML,
        pt.AWS,
        pt.QuickBooks,
        pt.Plaid,
      ],
    },
    {
      type: "Professional",
      name: "SiteView",
      url: "https://siteview.io",
      preview: "/iamdustin/projects/SiteView/SiteView.jpg",
      description:
        "Based on a previous project I worked on (Facility Manager) SiteView was adopted by Unified Power during one of the acquisitions as replacement of TechPortal. It is an internal field management platform specifically designed for services in the power industry. It includes core modules for site and asset management, work orders, service reports, pdf generation, scheduling and more. SiteView quickly became one of the best applications in the industry with recognition by regional managers, field engineers, back office staff and customers. One of the core features of SiteView is seamless real time two way synchronization with NetSuite. Proven to be highly scalable, fast and reliable it handles thousands of transactions and millions of records. Unfortunately, it is not publicly available. I am happy to provide a demo upon request.",
      start: new Date(2016, 10, 1),
      end: new Date(2023, 9, 1),
      company: "Unified Power USA",
      images: [
        {
          src: "/iamdustin/projects/SiteView/SiteView.jpg",
          title: "SiteView Preview",
        },
        {
          src: "/iamdustin/projects/SiteView/Scheduler.png",
          title: "Scheduling Module",
        },
        {
          src: "/iamdustin/projects/SiteView/Check List.png",
          title: "Service Report Module",
        },
        {
          src: "/iamdustin/projects/SiteView/Workorder Approval.png",
          title: "Workorder Approval Module",
        },
      ],
      roles: [
        "Architecture",
        "Design",
        "Frontend",
        "Backend",
        "Maintenance",
        "DevOps",
        "Tech Support",
      ],
      tools: [
        pt.ColdFusion,
        pt.JQuery,
        pt.PDF,
        pt.HTML,
        pt.Maps,
        pt.Bash,
        pt.AWS,
      ],
    },
    {
      hideInList: !0,
      type: "Integration",
      name: "NetSuite Sync",
      url: "",
      description: "",
      start: new Date(2016, 1, 1),
      end: new Date(2023, 10, 1),
      company: "Unified Power USA",
      images: [],
      roles: [
        "Architecture",
        "Backend",
        "DevOps",
        "Maintenance",
        "Tech Support",
      ],
      tools: [pt.PHP, pt.NetSuite, pt.Bash, pt.Git, pt.AWS, pt.CloudFront],
    },
    {
      type: "Personal",
      name: "Pulse Games",
      url: "https://ttapulse.com",
      github: "https://github.com/whimsy-cat/Pulse.Backend",
      demo: "https://test.pulsegames.io/games/schotten2?matchId=demoAttack",
      presentation:
        "https://www.kickstarter.com/iamdustin/projects/pulsegamesst2/pulsegamesio-the-mobile-board-gaming-platform?ref=website",
      preview: "/iamdustin/projects/Pulse Games/preview.jpg",
      description:
        "Every developer sooner or later has an idea for a game. I am no exception. I've been playing board games for years and I always wanted to build a digital game platform. I started working on Pulse Games in 2020. It is a competitive 2 player mobile board gaming platform. It includes a web app, mobile app and backend. The various features include matchmaker, leaderboard, stats, achievements, graphic customizations, etc. I've mostly abandoned the project since family professional tasks took over the majority of my free time. However there are still a few active users. One of the sub-divisions of the project is TTA Pulse - unofficial competitive app for Through The Ages. It's very popular among the community with more than 10 seasons completed to date.",
      start: new Date(2020, 2, 1),
      end: new Date(2021, 4, 1),
      company: "Pulse Games",
      images: [
        {
          src: "/iamdustin/projects/Pulse Games/Match History.png",
          title: "Match History",
        },
        {
          src: "/iamdustin/projects/Pulse Games/pulsegames-2.gif",
          title: "Matchmaker Preview",
        },
        {
          src: "/iamdustin/projects/Pulse Games/pulsegames-5.gif",
          title: "Schotten Totten Victory Screen",
        },
        {
          src: "/iamdustin/projects/Pulse Games/pulsegames-1.gif",
          title: "Game Selection",
        },
        {
          src: "/iamdustin/projects/Pulse Games/ThroughTheAges-Pulse-Stretch-Goals.jpg",
          title: "Through The Ages Stats",
        },
        {
          src: "/iamdustin/projects/Pulse Games/ThroughTheAges-Pulse-Leaderboard-System.jpg",
          title: "Through The Ages Leaderboard History",
        },
        {
          src: "/iamdustin/projects/Pulse Games/ThroughTheAges-Pulse-Leaderboard-S2.jpg",
          title: "Through The Ages Leaderboard",
        },
      ],
      roles: [
        "Design",
        "Frontend",
        "Backend",
        "DevOps",
        "Testing",
        "Maintenance",
      ],
      tools: [
        pt.Typescript,
        pt.Vue,
        pt.Quasar,
        pt.NET,
        pt.EntityFramework,
        pt.MSSQL,
        pt.Azure,
        pt.CI,
        pt.Git,
      ],
    },
    {
      type: "Professional",
      name: "Customer Portal",
      url: "https://portal.siteview.io",
      demo: "https://portal.siteview.io/demo/health",
      preview: "/iamdustin/projects/Customer Portal/preview.jpg",
      description:
        "Customer Portal designed to provide access for customers, resellers and rep firms to scheduling tools, site and unit management, proposals, billing, reports and more. It is specifically tailored for the power industry and it is available to thousands of customers across the US. Some of the biggest consumers include Amazon, Google, Microsoft, etc. It is a highly scalable, fast and reliable application. It handles thousands of transactions and millions of records. Unfortunately, it is not publicly available. I am happy to provide a demo upon request.",
      start: new Date(2019, 10, 1),
      end: new Date(2023, 9, 1),
      company: "Unified Power USA",
      images: [
        {
          src: "/iamdustin/projects/Customer Portal/Page-HealthReport.png",
          title: "Health Report",
        },
        {
          src: "/iamdustin/projects/Customer Portal/Mobile-HealthReport.png",
          title: "Health Report - Mobile",
        },
        {
          src: "/iamdustin/projects/Customer Portal/Page-SiteHealth.png",
          title: "Site Health",
        },
        {
          src: "/iamdustin/projects/Customer Portal/Mobile-SiteHealth.png",
          title: "Site Health - Mobile",
        },
      ],
      roles: [
        "Architecture",
        "Design",
        "Frontend",
        "Backend",
        "Maintenance",
        "DevOps",
        "Tech Support",
      ],
      tools: [
        pt.Figma,
        pt.HTML,
        pt.Typescript,
        pt.Vue,
        pt.Quasar,
        pt.Node,
        pt.AWS,
        pt.Bash,
        pt.Git,
        pt.Lambda,
        pt.Maps,
      ],
    },
    {
      type: "Startup",
      name: "Datafi Console",
      url: "https://datafi.us",
      presentation: "/iamdustin/projects/Datafi Console/index.html",
      preview: "/iamdustin/projects/Datafi Console/preview.png",
      description:
        "I found Datafi in 2020 while searching for a better database design and management tool. I was very impressed with the product and I decided to join the team. I worked with them for over an year. My contributions include complete redesign of the UI/UX, complete refactor of the backend, integration with various AWS services, CI/CD, deployment and maintenance. Despite working on the project only in my spare time I was the top contributor with 1000+ commits, 220+ PRs and resolved over 100+ issues in various stages of the project and tech stacks. I am very proud of the work I did and I am looking forward to see the product grow and succeed. I wrote an article on dev.to about it.",
      start: new Date(2021, 5, 1),
      end: new Date(2022, 5, 1),
      company: "Datafi Labs",
      images: [
        {
          src: "/iamdustin/projects/Datafi Console/DBMS-Datafi.png",
          title: "Datafi Cloud Preview",
        },
        {
          src: "/iamdustin/projects/Datafi Console/presentation-image.png",
          title: "Datafi Cloud Presentation",
        },
        {
          src: "/iamdustin/projects/Datafi Console/dataview-search.gif",
          title: "Dataview Search Demo",
        },
        {
          src: "/iamdustin/projects/Datafi Console/quickstart-demo.png",
          title: "Quickstart Demo",
        },
        {
          src: "/iamdustin/projects/Datafi Console/datafi-dataapp-test.gif",
          title: "DataApp Demo",
        },
        {
          src: "/iamdustin/projects/Datafi Console/policy-configuration.png",
          title: "Policy Configuration",
        },
      ],
      roles: ["Design", "Frontend", "Backend", "DevOps"],
      tools: [
        pt.React,
        pt.Vue,
        pt.PostgreSQL,
        pt.AWS,
        pt.Photoshop,
        pt.Illustrator,
        pt.Quasar,
        pt.Material,
        pt.HTML,
        pt.Typescript,
        pt.Node,
        pt.Auth0,
        pt.Bash,
        pt.Git,
        pt.AWS,
        pt.Lambda,
        pt.CodeDeploy,
        pt.CloudFront,
      ],
    },
    {
      type: "Personal",
      name: "Go To Anything",
      url: "https://marketplace.visualstudio.com/items?itemName=Cmacu.gotoanything",
      preview: "/iamdustin/projects/GoToAnything/preview.png",
      description:
        "I used Sublime Text 2 and 3 (as well as other editors) for years. Still as developer I am always on the lookout for new tools. That's how I discovered VSCode. After giving it a couple of tries I was very impressed with the developer experience and performance. One of the things I liked and missed about Sublime Text was the Go To Anything feature. It allows you to quickly navigate to any file, function, symbol, etc. in your project. So I decided to build it myself. I've been used it for a while now and I am very happy with the results. I've also published it on the VS Code Marketplace and it has over 5000 downloads.",
      start: new Date(2020, 1, 1),
      end: new Date(2021, 1, 1),
      company: "VS Code",
      github: "https://github.com/whimsy-cat/gotoanything",
      images: [
        {
          src: "/iamdustin/projects/GoToAnything/marketplace.png",
          title: "Marketplace Page",
        },
        {
          src: "/iamdustin/projects/GoToAnything/goto_command.gif",
          title: "Go To Command Demo",
        },
        {
          src: "/iamdustin/projects/GoToAnything/goto_file_function.gif",
          title: "Go To Symbol Demo",
        },
        {
          src: "/iamdustin/projects/GoToAnything/goto_help.gif",
          title: "Go To Help Demo",
        },
      ],
      roles: ["Frontend", "DevOps"],
      tools: [pt.Typescript, pt.HTML, pt.Git, pt.CI],
    },
    {
      type: "Professional",
      name: "Graphic Design Portfolio",
      url: "https://t.ly/RDzVF",
      preview: "/iamdustin/projects/Graphic Design/preview.png",
      description:
        "In my early to mid twenties I was very passionate about graphic design. I worked as interior designer and I did freelance work as part of the Plus Creative team. I participated in various design competitions and I was lucky enough to win a few. During my graphic design career I completed over 20 projects for interior and exterior 3D visualizations as well as architectural drawings. Other projects include logos, print materials, business cards, etc. Toward the end I focused mostly one web design which was the reason I decided to switch careers and become a web developer. Since then I've worked on various projects both professionally and as a hobby. I often work on presentations and other visual materials for my job and side projects.",
      start: new Date(2011, 4, 1),
      end: new Date(2016, 1, 1),
      company: "Plus Creative",
      github: "",
      images: [
        {
          src: "/iamdustin/projects/Graphic Design/Exterior Rendering 04.jpeg",
          title: "Exterior Rendering for Private House",
        },
        {
          src: "/iamdustin/projects/Graphic Design/SchneiderCompetition_ItsCoffeeTime_Camera01.jpeg",
          title: "Schneider Electric Design Competition 01",
        },
        {
          src: "/iamdustin/projects/Graphic Design/SchneiderCompetition_MovieScene_Camera02.jpeg",
          title: "Schneider Electric Design Competition 02",
        },
        {
          src: "/iamdustin/projects/Graphic Design/GymPark.jpg",
          title: "Gym Park Project brochure",
        },
        {
          src: "/iamdustin/projects/Graphic Design/D2-RockBand.jpg",
          title: "Rock Band Logo Competition",
        },
        {
          src: "/iamdustin/projects/Graphic Design/Eric_Kayser_Dorly_Camera03.jpg",
          title: "Eric Kayser Bakery Design Concept 01",
        },
        {
          src: "/iamdustin/projects/Graphic Design/Eric_Kayser_Dorly_Camera05.jpg",
          title: "Eric Kayser Design Concept 02",
        },
        {
          src: "/iamdustin/projects/Graphic Design/EricKayser_NiceT2_Camera02Option02.jpg",
          title: "Eric Kayser Design Concept 03",
        },
        {
          src: "/iamdustin/projects/Graphic Design/Ocean Coast Electric Logo.png",
          title: "Ocean Coast Electric Logo",
        },
        {
          src: "/iamdustin/projects/Graphic Design/StasiLogo-Large.png",
          title: "Personal Logo",
        },
      ],
      roles: ["Architecture", "Management", "Design", "Visualizations"],
      tools: [pt.Photoshop, pt.Illustrator, pt.Max, pt.AutoCAD, pt.AdobeXD],
    },
  ];
var od = { exports: {} };
(function (t) {
  (function (e) {
    t.exports
      ? ((e.default = e), (t.exports = e))
      : e(typeof Highcharts < "u" ? Highcharts : void 0);
  })(function (e) {
    function n(i, a, d, M) {
      i.hasOwnProperty(a) ||
        ((i[a] = M.apply(null, d)),
        typeof CustomEvent == "function" &&
          window.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: a, module: i[a] },
            })
          ));
    }
    (e = e ? e._modules : {}),
      n(
        e,
        "Accessibility/Utils/HTMLUtilities.js",
        [e["Core/Globals.js"], e["Core/Utilities.js"]],
        function (i, a) {
          function d(L) {
            if (typeof B.MouseEvent == "function")
              return new B.MouseEvent(L.type, L);
            if (O.createEvent) {
              const E = O.createEvent("MouseEvent");
              if (E.initMouseEvent)
                return (
                  E.initMouseEvent(
                    L.type,
                    L.bubbles,
                    L.cancelable,
                    L.view || B,
                    L.detail,
                    L.screenX,
                    L.screenY,
                    L.clientX,
                    L.clientY,
                    L.ctrlKey,
                    L.altKey,
                    L.shiftKey,
                    L.metaKey,
                    L.button,
                    L.relatedTarget
                  ),
                  E
                );
            }
            return M(L.type);
          }
          function M(L, E, z) {
            return (
              (E = E || { x: 0, y: 0 }),
              typeof B.MouseEvent == "function"
                ? new B.MouseEvent(L, {
                    bubbles: !0,
                    cancelable: !0,
                    composed: !0,
                    button: 0,
                    buttons: 1,
                    relatedTarget: z || Y,
                    view: B,
                    detail: L === "click" ? 1 : 0,
                    screenX: E.x,
                    screenY: E.y,
                    clientX: E.x,
                    clientY: E.y,
                  })
                : O.createEvent &&
                  ((z = O.createEvent("MouseEvent")), z.initMouseEvent)
                ? (z.initMouseEvent(
                    L,
                    !0,
                    !0,
                    B,
                    L === "click" ? 1 : 0,
                    E.x,
                    E.y,
                    E.x,
                    E.y,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  ),
                  z)
                : { type: L }
            );
          }
          const { doc: O, win: B } = i,
            { css: G } = a,
            Y = (B.EventTarget && new B.EventTarget()) || "none";
          return {
            addClass: function (L, E) {
              L.classList
                ? L.classList.add(E)
                : 0 > L.className.indexOf(E) && (L.className += " " + E);
            },
            cloneMouseEvent: d,
            cloneTouchEvent: function (L) {
              var E = (z) => {
                const S = [];
                for (let x = 0; x < z.length; ++x) {
                  const P = z.item(x);
                  P && S.push(P);
                }
                return S;
              };
              return typeof B.TouchEvent == "function"
                ? ((E = new B.TouchEvent(L.type, {
                    touches: E(L.touches),
                    targetTouches: E(L.targetTouches),
                    changedTouches: E(L.changedTouches),
                    ctrlKey: L.ctrlKey,
                    shiftKey: L.shiftKey,
                    altKey: L.altKey,
                    metaKey: L.metaKey,
                    bubbles: L.bubbles,
                    cancelable: L.cancelable,
                    composed: L.composed,
                    detail: L.detail,
                    view: L.view,
                  })),
                  L.defaultPrevented && E.preventDefault(),
                  E)
                : ((E = d(L)),
                  (E.touches = L.touches),
                  (E.changedTouches = L.changedTouches),
                  (E.targetTouches = L.targetTouches),
                  E);
            },
            escapeStringForHTML: function (L) {
              return L.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#x27;")
                .replace(/\//g, "&#x2F;");
            },
            getElement: function (L) {
              return O.getElementById(L);
            },
            getFakeMouseEvent: M,
            getHeadingTagNameForElement: function (L) {
              const E = (S) => (
                  (S = parseInt(S.slice(1), 10)), "h" + Math.min(6, S + 1)
                ),
                z = (S) => {
                  var x;
                  t: {
                    for (x = S; (x = x.previousSibling); ) {
                      const P = x.tagName || "";
                      if (/H[1-6]/.test(P)) {
                        x = P;
                        break t;
                      }
                    }
                    x = "";
                  }
                  return x
                    ? E(x)
                    : ((S = S.parentElement),
                      S
                        ? ((x = S.tagName), /H[1-6]/.test(x) ? E(x) : z(S))
                        : "p");
                };
              return z(L);
            },
            removeChildNodes: function (L) {
              for (; L.lastChild; ) L.removeChild(L.lastChild);
            },
            removeClass: function (L, E) {
              L.classList
                ? L.classList.remove(E)
                : (L.className = L.className.replace(new RegExp(E, "g"), ""));
            },
            removeElement: function (L) {
              L && L.parentNode && L.parentNode.removeChild(L);
            },
            reverseChildNodes: function (L) {
              let E = L.childNodes.length;
              for (; E--; ) L.appendChild(L.childNodes[E]);
            },
            simulatedEventTarget: Y,
            stripHTMLTagsFromString: function (L) {
              return typeof L == "string"
                ? L.replace(/<\/?[^>]+(>|$)/g, "")
                : L;
            },
            visuallyHideElement: function (L) {
              G(L, {
                position: "absolute",
                width: "1px",
                height: "1px",
                overflow: "hidden",
                whiteSpace: "nowrap",
                clip: "rect(1px, 1px, 1px, 1px)",
                marginTop: "-3px",
                "-ms-filter":
                  "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
                filter: "alpha(opacity=1)",
                opacity: 0.01,
              });
            },
          };
        }
      ),
      n(
        e,
        "Accessibility/A11yI18n.js",
        [e["Core/Templating.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const { format: d } = i,
            { getNestedProperty: M, pick: O } = a;
          var B;
          return (
            (function (G) {
              function Y(S, x) {
                var P = S.indexOf("#each("),
                  h = S.indexOf("#plural("),
                  s = S.indexOf("[");
                const l = S.indexOf("]");
                if (-1 < P) {
                  s = S.slice(P).indexOf(")") + P;
                  var p = S.substring(0, P);
                  if (
                    ((h = S.substring(s + 1)),
                    (s = S.substring(P + 6, s).split(",")),
                    (P = Number(s[1])),
                    (S = ""),
                    (x = M(s[0], x)))
                  )
                    for (
                      P = isNaN(P) ? x.length : P,
                        P = 0 > P ? x.length + P : Math.min(P, x.length),
                        s = 0;
                      s < P;
                      ++s
                    )
                      S += p + x[s] + h;
                  return S.length ? S : "";
                }
                if (-1 < h) {
                  switch (
                    ((p = S.slice(h).indexOf(")") + h),
                    (S = S.substring(h + 8, p).split(",")),
                    Number(M(S[0], x)))
                  ) {
                    case 0:
                      S = O(S[4], S[1]);
                      break;
                    case 1:
                      S = O(S[2], S[1]);
                      break;
                    case 2:
                      S = O(S[3], S[1]);
                      break;
                    default:
                      S = S[1];
                  }
                  return (
                    S
                      ? ((x = S),
                        (x =
                          (x.trim && x.trim()) || x.replace(/^\s+|\s+$/g, "")))
                      : (x = ""),
                    x
                  );
                }
                return -1 < s
                  ? ((h = S.substring(0, s)),
                    (S = Number(S.substring(s + 1, l))),
                    (x = M(h, x)),
                    !isNaN(S) &&
                      x &&
                      (0 > S
                        ? ((p = x[x.length + S]), typeof p > "u" && (p = x[0]))
                        : ((p = x[S]),
                          typeof p > "u" && (p = x[x.length - 1]))),
                    typeof p < "u" ? p : "")
                  : "{" + S + "}";
              }
              function L(S, x, P) {
                const h = (T, D) => {
                    T = T.slice(D || 0);
                    const A = T.indexOf("{"),
                      m = T.indexOf("}");
                    if (-1 < A && m > A)
                      return {
                        statement: T.substring(A + 1, m),
                        begin: D + A + 1,
                        end: D + m,
                      };
                  },
                  s = [];
                let l,
                  p,
                  g = 0;
                do
                  (l = h(S, g)),
                    (p = S.substring(g, l && l.begin - 1)),
                    p.length && s.push({ value: p, type: "constant" }),
                    l && s.push({ value: l.statement, type: "statement" }),
                    (g = l ? l.end + 1 : g + 1);
                while (l);
                return (
                  s.forEach((T) => {
                    T.type === "statement" && (T.value = Y(T.value, x));
                  }),
                  d(
                    s.reduce((T, D) => T + D.value, ""),
                    x,
                    P
                  )
                );
              }
              function E(S, x) {
                S = S.split(".");
                let P = this.options.lang,
                  h = 0;
                for (; h < S.length; ++h) P = P && P[S[h]];
                return typeof P == "string" ? L(P, x, this) : "";
              }
              const z = [];
              (G.compose = function (S) {
                return a.pushUnique(z, S) && (S.prototype.langFormat = E), S;
              }),
                (G.i18nFormat = L);
            })(B || (B = {})),
            B
          );
        }
      ),
      n(
        e,
        "Accessibility/Utils/ChartUtilities.js",
        [
          e["Core/Globals.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          function M(h, s) {
            const l = s.type,
              p = h.hcEvents;
            E.createEvent && (h.dispatchEvent || h.fireEvent)
              ? h.dispatchEvent
                ? h.dispatchEvent(s)
                : h.fireEvent(l, s)
              : p && p[l]
              ? P(h, l, s)
              : h.element && M(h.element, s);
          }
          function O(h) {
            const s = h.chart,
              l = {};
            let p = "Seconds";
            (l.Seconds =
              ((h.dataMax || h.max || 0) - (h.dataMin || h.min || 0)) / 1e3),
              (l.Minutes = l.Seconds / 60),
              (l.Hours = l.Minutes / 60),
              (l.Days = l.Hours / 24),
              ["Minutes", "Hours", "Days"].forEach(function (T) {
                2 < l[T] && (p = T);
              });
            const g = l[p].toFixed(p !== "Seconds" && p !== "Minutes" ? 1 : 0);
            return s.langFormat("accessibility.axis.timeRange" + p, {
              chart: s,
              axis: h,
              range: g.replace(".0", ""),
            });
          }
          function B(h) {
            const s = h.chart;
            var l = s.options;
            const p =
                (l &&
                  l.accessibility &&
                  l.accessibility.screenReaderSection.axisRangeDateFormat) ||
                "",
              g = {
                min: h.dataMin || h.min || 0,
                max: h.dataMax || h.max || 0,
              };
            return (
              (l = function (T) {
                return h.dateTime
                  ? s.time.dateFormat(p, g[T])
                  : g[T].toString();
              }),
              s.langFormat("accessibility.axis.rangeFromTo", {
                chart: s,
                axis: h,
                rangeFrom: l("min"),
                rangeTo: l("max"),
              })
            );
          }
          function G(h) {
            if (h.points && h.points.length)
              return (
                (h = x(h.points, (s) => !!s.graphic)) &&
                h.graphic &&
                h.graphic.element
              );
          }
          function Y(h) {
            const s = G(h);
            return (
              (s && s.parentNode) ||
              (h.graph && h.graph.element) ||
              (h.group && h.group.element)
            );
          }
          function L(h, s) {
            s.setAttribute("aria-hidden", !1),
              s !== h.renderTo &&
                s.parentNode &&
                s.parentNode !== E.body &&
                (Array.prototype.forEach.call(
                  s.parentNode.childNodes,
                  function (l) {
                    l.hasAttribute("aria-hidden") ||
                      l.setAttribute("aria-hidden", !0);
                  }
                ),
                L(h, s.parentNode));
          }
          const { doc: E } = i,
            { stripHTMLTagsFromString: z } = a,
            { defined: S, find: x, fireEvent: P } = d;
          return {
            fireEventOnWrappedOrUnwrappedElement: M,
            getChartTitle: function (h) {
              return z(
                h.options.title.text ||
                  h.langFormat("accessibility.defaultChartTitle", { chart: h })
              );
            },
            getAxisDescription: function (h) {
              var s, l;
              return (
                h &&
                (((s = h.options.accessibility) === null || s === void 0
                  ? void 0
                  : s.description) ||
                  ((l = h.axisTitle) === null || l === void 0
                    ? void 0
                    : l.textStr) ||
                  h.options.id ||
                  (h.categories && "categories") ||
                  (h.dateTime && "Time") ||
                  "values")
              );
            },
            getAxisRangeDescription: function (h) {
              var s = h.options || {};
              return s.accessibility &&
                typeof s.accessibility.rangeDescription < "u"
                ? s.accessibility.rangeDescription
                : h.categories
                ? ((s = h.chart),
                  (h =
                    h.dataMax && h.dataMin
                      ? s.langFormat("accessibility.axis.rangeCategories", {
                          chart: s,
                          axis: h,
                          numCategories: h.dataMax - h.dataMin + 1,
                        })
                      : ""),
                  h)
                : !h.dateTime || (h.min !== 0 && h.dataMin !== 0)
                ? B(h)
                : O(h);
            },
            getPointFromXY: function (h, s, l) {
              let p = h.length,
                g;
              for (; p--; )
                if (
                  (g = x(h[p].points || [], function (T) {
                    return T.x === s && T.y === l;
                  }))
                )
                  return g;
            },
            getSeriesFirstPointElement: G,
            getSeriesFromName: function (h, s) {
              return s
                ? (h.series || []).filter(function (l) {
                    return l.name === s;
                  })
                : h.series;
            },
            getSeriesA11yElement: Y,
            unhideChartElementFromAT: L,
            hideSeriesFromAT: function (h) {
              (h = Y(h)) && h.setAttribute("aria-hidden", !0);
            },
            scrollToPoint: function (h) {
              var s = h.series.xAxis,
                l = h.series.yAxis;
              const p = s && s.scrollbar ? s : l;
              if ((s = p && p.scrollbar) && S(s.to) && S(s.from)) {
                if (((l = s.to - s.from), S(p.dataMin) && S(p.dataMax))) {
                  var g = p.toPixels(p.dataMin),
                    T = p.toPixels(p.dataMax);
                  h =
                    (p.toPixels(h[p.coll === "xAxis" ? "x" : "y"] || 0) - g) /
                    (T - g);
                } else h = 0;
                s.updatePosition(h - l / 2, h + l / 2),
                  P(s, "changed", {
                    from: s.from,
                    to: s.to,
                    trigger: "scrollbar",
                    DOMEvent: null,
                  });
              }
            },
          };
        }
      ),
      n(
        e,
        "Accessibility/Utils/DOMElementProvider.js",
        [e["Core/Globals.js"], e["Accessibility/Utils/HTMLUtilities.js"]],
        function (i, a) {
          const { doc: d } = i,
            { removeElement: M } = a;
          class O {
            constructor() {
              this.elements = [];
            }
            createElement() {
              const G = d.createElement.apply(d, arguments);
              return this.elements.push(G), G;
            }
            destroyCreatedElements() {
              this.elements.forEach(function (G) {
                M(G);
              }),
                (this.elements = []);
            }
          }
          return O;
        }
      ),
      n(
        e,
        "Accessibility/Utils/EventProvider.js",
        [e["Core/Globals.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const { addEvent: d } = a;
          class M {
            constructor() {
              this.eventRemovers = [];
            }
            addEvent() {
              const B = d.apply(i, arguments);
              return this.eventRemovers.push(B), B;
            }
            removeAddedEvents() {
              this.eventRemovers.forEach((B) => B()), (this.eventRemovers = []);
            }
          }
          return M;
        }
      ),
      n(
        e,
        "Accessibility/AccessibilityComponent.js",
        [
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/DOMElementProvider.js"],
          e["Accessibility/Utils/EventProvider.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          const { fireEventOnWrappedOrUnwrappedElement: B } = i,
            { getFakeMouseEvent: G } = M;
          ({ extend: i } = O);
          class Y {
            constructor() {
              this.proxyProvider =
                this.keyCodes =
                this.eventProvider =
                this.domElementProvider =
                this.chart =
                  void 0;
            }
            initBase(E, z) {
              (this.chart = E),
                (this.eventProvider = new d()),
                (this.domElementProvider = new a()),
                (this.proxyProvider = z),
                (this.keyCodes = {
                  left: 37,
                  right: 39,
                  up: 38,
                  down: 40,
                  enter: 13,
                  space: 32,
                  esc: 27,
                  tab: 9,
                  pageUp: 33,
                  pageDown: 34,
                  end: 35,
                  home: 36,
                });
            }
            addEvent(E, z, S, x) {
              return this.eventProvider.addEvent(E, z, S, x);
            }
            createElement(E, z) {
              return this.domElementProvider.createElement(E, z);
            }
            fakeClickEvent(E) {
              const z = G("click");
              B(E, z);
            }
            destroyBase() {
              this.domElementProvider.destroyCreatedElements(),
                this.eventProvider.removeAddedEvents();
            }
          }
          return (
            i(Y.prototype, {
              init() {},
              getKeyboardNavigation: function () {},
              onChartUpdate() {},
              onChartRender() {},
              destroy() {},
            }),
            Y
          );
        }
      ),
      n(
        e,
        "Accessibility/KeyboardNavigationHandler.js",
        [e["Core/Utilities.js"]],
        function (i) {
          const { find: a } = i;
          class d {
            constructor(O, B) {
              (this.chart = O),
                (this.keyCodeMap = B.keyCodeMap || []),
                (this.validate = B.validate),
                (this.init = B.init),
                (this.terminate = B.terminate),
                (this.response = {
                  success: 1,
                  prev: 2,
                  next: 3,
                  noHandler: 4,
                  fail: 5,
                });
            }
            run(O) {
              const B = O.which || O.keyCode;
              let G = this.response.noHandler;
              const Y = a(this.keyCodeMap, function (L) {
                return -1 < L[0].indexOf(B);
              });
              return (
                Y
                  ? (G = Y[1].call(this, B, O))
                  : B === 9 &&
                    (G = this.response[O.shiftKey ? "prev" : "next"]),
                G
              );
            }
          }
          return d;
        }
      ),
      n(
        e,
        "Accessibility/Components/ContainerComponent.js",
        [
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Core/Globals.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (i, a, d, M, O) {
          const { unhideChartElementFromAT: B, getChartTitle: G } = d,
            { doc: Y } = M,
            { stripHTMLTagsFromString: L } = O;
          class E extends i {
            onChartUpdate() {
              this.handleSVGTitleElement(),
                this.setSVGContainerLabel(),
                this.setGraphicContainerAttrs(),
                this.setRenderToAttrs(),
                this.makeCreditsAccessible();
            }
            handleSVGTitleElement() {
              const S = this.chart,
                x = "highcharts-title-" + S.index,
                P = L(
                  S.langFormat("accessibility.svgContainerTitle", {
                    chartTitle: G(S),
                  })
                );
              if (P.length) {
                const h = (this.svgTitleElement =
                  this.svgTitleElement ||
                  Y.createElementNS("http://www.w3.org/2000/svg", "title"));
                (h.textContent = P),
                  (h.id = x),
                  S.renderTo.insertBefore(h, S.renderTo.firstChild);
              }
            }
            setSVGContainerLabel() {
              const S = this.chart,
                x = S.langFormat("accessibility.svgContainerLabel", {
                  chartTitle: G(S),
                });
              S.renderer.box &&
                x.length &&
                S.renderer.box.setAttribute("aria-label", x);
            }
            setGraphicContainerAttrs() {
              const S = this.chart,
                x = S.langFormat("accessibility.graphicContainerLabel", {
                  chartTitle: G(S),
                });
              x.length && S.container.setAttribute("aria-label", x);
            }
            setRenderToAttrs() {
              const S = this.chart,
                x = S.options.accessibility.landmarkVerbosity !== "disabled",
                P = S.langFormat("accessibility.chartContainerLabel", {
                  title: G(S),
                  chart: S,
                });
              P &&
                (S.renderTo.setAttribute("role", x ? "region" : "group"),
                S.renderTo.setAttribute("aria-label", P));
            }
            makeCreditsAccessible() {
              const S = this.chart,
                x = S.credits;
              x &&
                (x.textStr &&
                  x.element.setAttribute(
                    "aria-label",
                    S.langFormat("accessibility.credits", {
                      creditsStr: L(x.textStr),
                    })
                  ),
                B(S, x.element));
            }
            getKeyboardNavigation() {
              const S = this.chart;
              return new a(S, {
                keyCodeMap: [],
                validate: function () {
                  return !0;
                },
                init: function () {
                  const x = S.accessibility;
                  x && x.keyboardNavigation.tabindexContainer.focus();
                },
              });
            }
            destroy() {
              this.chart.renderTo.setAttribute("aria-hidden", !0);
            }
          }
          return E;
        }
      ),
      n(
        e,
        "Accessibility/FocusBorder.js",
        [e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Utilities.js"]],
        function (i, a) {
          const { addEvent: d, pick: M } = a;
          var O;
          return (
            (function (B) {
              function G() {
                const s = this.focusElement,
                  l = this.options.accessibility.keyboardNavigation.focusBorder;
                s &&
                  (s.removeFocusBorder(),
                  l.enabled &&
                    s.addFocusBorder(l.margin, {
                      stroke: l.style.color,
                      strokeWidth: l.style.lineWidth,
                      r: l.style.borderRadius,
                    }));
              }
              function Y(s, l) {
                const p =
                  this.options.accessibility.keyboardNavigation.focusBorder;
                (l = l || s.element) &&
                  l.focus &&
                  ((l.hcEvents && l.hcEvents.focusin) ||
                    d(l, "focusin", function () {}),
                  l.focus(),
                  p.hideBrowserFocusOutline && (l.style.outline = "none")),
                  this.focusElement && this.focusElement.removeFocusBorder(),
                  (this.focusElement = s),
                  this.renderFocusBorder();
              }
              function L(s) {
                if (!s.focusBorderDestroyHook) {
                  var l = s.destroy;
                  (s.destroy = function () {
                    return (
                      s.focusBorder &&
                        s.focusBorder.destroy &&
                        s.focusBorder.destroy(),
                      l.apply(s, arguments)
                    );
                  }),
                    (s.focusBorderDestroyHook = l);
                }
              }
              function E(s, l) {
                this.focusBorder && this.removeFocusBorder();
                const p = this.getBBox(),
                  g = M(s, 3),
                  T = this.parentGroup;
                var D = this.scaleX || (T && T.scaleX),
                  A = this.scaleY || (T && T.scaleY);
                (D = (D ? !A : A)
                  ? Math.abs(D || A || 1)
                  : (Math.abs(D || 1) + Math.abs(A || 1)) / 2),
                  (p.x += this.translateX ? this.translateX : 0),
                  (p.y += this.translateY ? this.translateY : 0),
                  (A = p.x - g);
                let m = p.y - g,
                  f = p.width + 2 * g,
                  b = p.height + 2 * g;
                var y = this instanceof i;
                if (this.element.nodeName === "text" || y) {
                  const r = !!this.rotation;
                  if (y) var C = { x: r ? 1 : 0, y: 0 };
                  else {
                    var o = (C = 0);
                    this.attr("text-anchor") === "middle"
                      ? (C = o = 0.5)
                      : this.rotation
                      ? (C = 0.25)
                      : (o = 0.75),
                      (C = { x: C, y: o });
                  }
                  o = +this.attr("x");
                  const c = +this.attr("y");
                  isNaN(o) || (A = o - p.width * C.x - g),
                    isNaN(c) || (m = c - p.height * C.y - g),
                    y &&
                      r &&
                      ((y = f),
                      (f = b),
                      (b = y),
                      isNaN(o) || (A = o - p.height * C.x - g),
                      isNaN(c) || (m = c - p.width * C.y - g));
                }
                (this.focusBorder = this.renderer
                  .rect(
                    A,
                    m,
                    f,
                    b,
                    parseInt(((l && l.r) || 0).toString(), 10) / D
                  )
                  .addClass("highcharts-focus-border")
                  .attr({ zIndex: 99 })
                  .add(T)),
                  this.renderer.styledMode ||
                    this.focusBorder.attr({
                      stroke: l && l.stroke,
                      "stroke-width": ((l && l.strokeWidth) || 0) / D,
                    }),
                  z(this, s, l),
                  L(this);
              }
              function z(s, ...l) {
                s.focusBorderUpdateHooks ||
                  ((s.focusBorderUpdateHooks = {}),
                  h.forEach((p) => {
                    p += "Setter";
                    const g = s[p] || s._defaultSetter;
                    (s.focusBorderUpdateHooks[p] = g),
                      (s[p] = function () {
                        const T = g.apply(s, arguments);
                        return s.addFocusBorder.apply(s, l), T;
                      });
                  }));
              }
              function S() {
                x(this),
                  this.focusBorderDestroyHook &&
                    ((this.destroy = this.focusBorderDestroyHook),
                    delete this.focusBorderDestroyHook),
                  this.focusBorder &&
                    (this.focusBorder.destroy(), delete this.focusBorder);
              }
              function x(s) {
                s.focusBorderUpdateHooks &&
                  (Object.keys(s.focusBorderUpdateHooks).forEach((l) => {
                    const p = s.focusBorderUpdateHooks[l];
                    p === s._defaultSetter ? delete s[l] : (s[l] = p);
                  }),
                  delete s.focusBorderUpdateHooks);
              }
              const P = [],
                h = "x y transform width height r d stroke-width".split(" ");
              B.compose = function (s, l) {
                a.pushUnique(P, s) &&
                  ((s = s.prototype),
                  (s.renderFocusBorder = G),
                  (s.setFocusToElement = Y)),
                  a.pushUnique(P, l) &&
                    ((l = l.prototype),
                    (l.addFocusBorder = E),
                    (l.removeFocusBorder = S));
              };
            })(O || (O = {})),
            O
          );
        }
      ),
      n(
        e,
        "Accessibility/Utils/Announcer.js",
        [
          e["Core/Renderer/HTML/AST.js"],
          e["Accessibility/Utils/DOMElementProvider.js"],
          e["Core/Globals.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          const { doc: B } = d,
            { addClass: G, visuallyHideElement: Y } = M,
            { attr: L } = O;
          class E {
            constructor(S, x) {
              (this.chart = S),
                (this.domElementProvider = new a()),
                (this.announceRegion = this.addAnnounceRegion(x));
            }
            destroy() {
              this.domElementProvider.destroyCreatedElements();
            }
            announce(S) {
              i.setElementHTML(this.announceRegion, S),
                this.clearAnnouncementRegionTimer &&
                  clearTimeout(this.clearAnnouncementRegionTimer),
                (this.clearAnnouncementRegionTimer = setTimeout(() => {
                  (this.announceRegion.innerHTML = i.emptyHTML),
                    delete this.clearAnnouncementRegionTimer;
                }, 1e3));
            }
            addAnnounceRegion(S) {
              const x =
                  this.chart.announcerContainer ||
                  this.createAnnouncerContainer(),
                P = this.domElementProvider.createElement("div");
              return (
                L(P, { "aria-hidden": !1, "aria-live": S }),
                this.chart.styledMode
                  ? G(P, "highcharts-visually-hidden")
                  : Y(P),
                x.appendChild(P),
                P
              );
            }
            createAnnouncerContainer() {
              const S = this.chart,
                x = B.createElement("div");
              return (
                L(x, {
                  "aria-hidden": !1,
                  class: "highcharts-announcer-container",
                }),
                (x.style.position = "relative"),
                S.renderTo.insertBefore(x, S.renderTo.firstChild),
                (S.announcerContainer = x)
              );
            }
          }
          return E;
        }
      ),
      n(
        e,
        "Accessibility/Components/AnnotationsA11y.js",
        [e["Accessibility/Utils/HTMLUtilities.js"]],
        function (i) {
          function a(Y) {
            return (Y.annotations || []).reduce(
              (L, E) => (
                E.options &&
                  E.options.visible !== !1 &&
                  (L = L.concat(E.labels)),
                L
              ),
              []
            );
          }
          function d(Y) {
            return (
              (Y.options &&
                Y.options.accessibility &&
                Y.options.accessibility.description) ||
              (Y.graphic && Y.graphic.text && Y.graphic.text.textStr) ||
              ""
            );
          }
          function M(Y) {
            var L =
              Y.options &&
              Y.options.accessibility &&
              Y.options.accessibility.description;
            if (L) return L;
            L = Y.chart;
            const E = d(Y),
              z = Y.points
                .filter((P) => !!P.graphic)
                .map((P) => {
                  const h =
                    (P.accessibility && P.accessibility.valueDescription) ||
                    (P.graphic &&
                      P.graphic.element &&
                      P.graphic.element.getAttribute("aria-label")) ||
                    "";
                  return (
                    (P = (P && P.series.name) || ""),
                    (P ? P + ", " : "") + "data point " + h
                  );
                })
                .filter((P) => !!P),
              S = z.length,
              x =
                "accessibility.screenReaderSection.annotations.description" +
                (1 < S ? "MultiplePoints" : S ? "SinglePoint" : "NoPoints");
            return (
              (Y = {
                annotationText: E,
                annotation: Y,
                numPoints: S,
                annotationPoint: z[0],
                additionalAnnotationPoints: z.slice(1),
              }),
              L.langFormat(x, Y)
            );
          }
          function O(Y) {
            return a(Y).map((L) => ((L = B(G(M(L)))) ? `<li>${L}</li>` : ""));
          }
          const { escapeStringForHTML: B, stripHTMLTagsFromString: G } = i;
          return {
            getAnnotationsInfoHTML: function (Y) {
              const L = Y.annotations;
              return L && L.length
                ? `<ul style="list-style-type: none">${O(Y).join(" ")}</ul>`
                : "";
            },
            getAnnotationLabelDescription: M,
            getAnnotationListItems: O,
            getPointAnnotationTexts: function (Y) {
              const L = a(Y.series.chart).filter(
                (E) => -1 < E.points.indexOf(Y)
              );
              return L.length ? L.map((E) => `${d(E)}`) : [];
            },
          };
        }
      ),
      n(
        e,
        "Accessibility/Components/InfoRegionsComponent.js",
        [
          e["Accessibility/A11yI18n.js"],
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/Utils/Announcer.js"],
          e["Accessibility/Components/AnnotationsA11y.js"],
          e["Core/Renderer/HTML/AST.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Core/Templating.js"],
          e["Core/Globals.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B, G, Y, L, E) {
          function z(C, o) {
            var r = o[0],
              c = (C.series && C.series[0]) || {};
            if (
              ((c = {
                numSeries: C.series.length,
                numPoints: c.points && c.points.length,
                chart: C,
                mapTitle:
                  C.mapView && C.mapView.geoMap && C.mapView.geoMap.title,
              }),
              !r)
            )
              return C.langFormat("accessibility.chartTypes.emptyChart", c);
            if (r === "map" || r === "tiledwebmap")
              return c.mapTitle
                ? C.langFormat("accessibility.chartTypes.mapTypeDescription", c)
                : C.langFormat("accessibility.chartTypes.unknownMap", c);
            if (1 < C.types.length)
              return C.langFormat(
                "accessibility.chartTypes.combinationChart",
                c
              );
            {
              (o = o[0]),
                (r = C.langFormat(
                  "accessibility.seriesTypeDescriptions." + o,
                  c
                ));
              const u = C.series && 2 > C.series.length ? "Single" : "Multiple";
              C =
                (C.langFormat("accessibility.chartTypes." + o + u, c) ||
                  C.langFormat("accessibility.chartTypes.default" + u, c)) +
                (r ? " " + r : "");
            }
            return C;
          }
          const { getAnnotationsInfoHTML: S } = M,
            {
              getAxisDescription: x,
              getAxisRangeDescription: P,
              getChartTitle: h,
              unhideChartElementFromAT: s,
            } = B,
            { format: l } = G,
            { doc: p } = Y,
            {
              addClass: g,
              getElement: T,
              getHeadingTagNameForElement: D,
              stripHTMLTagsFromString: A,
              visuallyHideElement: m,
            } = L,
            { attr: f, pick: b } = E;
          class y extends a {
            constructor() {
              super(...arguments),
                (this.announcer = void 0),
                (this.screenReaderSections = {});
            }
            init() {
              const o = this.chart,
                r = this;
              this.initRegionsDefinitions(),
                this.addEvent(o, "aftergetTableAST", function (c) {
                  r.onDataTableCreated(c);
                }),
                this.addEvent(o, "afterViewData", function (c) {
                  c.wasHidden &&
                    ((r.dataTableDiv = c.element),
                    setTimeout(function () {
                      r.focusDataTable();
                    }, 300));
                }),
                (this.announcer = new d(o, "assertive"));
            }
            initRegionsDefinitions() {
              const o = this;
              this.screenReaderSections = {
                before: {
                  element: null,
                  buildContent: function (r) {
                    const c =
                      r.options.accessibility.screenReaderSection
                        .beforeChartFormatter;
                    return c ? c(r) : o.defaultBeforeChartFormatter(r);
                  },
                  insertIntoDOM: function (r, c) {
                    c.renderTo.insertBefore(r, c.renderTo.firstChild);
                  },
                  afterInserted: function () {
                    typeof o.sonifyButtonId < "u" &&
                      o.initSonifyButton(o.sonifyButtonId),
                      typeof o.dataTableButtonId < "u" &&
                        o.initDataTableButton(o.dataTableButtonId);
                  },
                },
                after: {
                  element: null,
                  buildContent: function (r) {
                    const c =
                      r.options.accessibility.screenReaderSection
                        .afterChartFormatter;
                    return c ? c(r) : o.defaultAfterChartFormatter();
                  },
                  insertIntoDOM: function (r, c) {
                    c.renderTo.insertBefore(r, c.container.nextSibling);
                  },
                  afterInserted: function () {
                    o.chart.accessibility &&
                      o.chart.accessibility.keyboardNavigation.updateExitAnchor();
                  },
                },
              };
            }
            onChartRender() {
              const o = this;
              (this.linkedDescriptionElement =
                this.getLinkedDescriptionElement()),
                this.setLinkedDescriptionAttrs(),
                Object.keys(this.screenReaderSections).forEach(function (r) {
                  o.updateScreenReaderSection(r);
                });
            }
            getLinkedDescriptionElement() {
              var o = this.chart.options.accessibility.linkedDescription;
              if (o) {
                if (typeof o != "string") return o;
                if (
                  ((o = l(o, this.chart)),
                  (o = p.querySelectorAll(o)),
                  o.length === 1)
                )
                  return o[0];
              }
            }
            setLinkedDescriptionAttrs() {
              const o = this.linkedDescriptionElement;
              o &&
                (o.setAttribute("aria-hidden", "true"),
                g(o, "highcharts-linked-description"));
            }
            updateScreenReaderSection(o) {
              const r = this.chart,
                c = this.screenReaderSections[o],
                u = c.buildContent(r),
                v = (c.element = c.element || this.createElement("div")),
                N = v.firstChild || this.createElement("div");
              u
                ? (this.setScreenReaderSectionAttribs(v, o),
                  O.setElementHTML(N, u),
                  v.appendChild(N),
                  c.insertIntoDOM(v, r),
                  r.styledMode ? g(N, "highcharts-visually-hidden") : m(N),
                  s(r, N),
                  c.afterInserted && c.afterInserted())
                : (v.parentNode && v.parentNode.removeChild(v),
                  (c.element = null));
            }
            setScreenReaderSectionAttribs(o, r) {
              const c = this.chart,
                u = c.langFormat(
                  "accessibility.screenReaderSection." + r + "RegionLabel",
                  { chart: c, chartTitle: h(c) }
                );
              f(o, {
                id: `highcharts-screen-reader-region-${r}-${c.index}`,
                "aria-label": u || void 0,
              }),
                (o.style.position = "relative"),
                u &&
                  o.setAttribute(
                    "role",
                    c.options.accessibility.landmarkVerbosity === "all"
                      ? "region"
                      : "group"
                  );
            }
            defaultBeforeChartFormatter() {
              var o = this.chart;
              const r =
                o.options.accessibility.screenReaderSection.beforeChartFormat;
              if (!r) return "";
              var c = this.getAxesDescription();
              const u =
                  o.sonify &&
                  o.options.sonification &&
                  o.options.sonification.enabled,
                v = "highcharts-a11y-sonify-data-btn-" + o.index,
                N = "hc-linkto-highcharts-data-table-" + o.index,
                w = S(o),
                R = o.langFormat(
                  "accessibility.screenReaderSection.annotations.heading",
                  { chart: o }
                );
              return (
                (c = {
                  headingTagName: D(o.renderTo),
                  chartTitle: h(o),
                  typeDescription: this.getTypeDescriptionText(),
                  chartSubtitle: this.getSubtitleText(),
                  chartLongdesc: this.getLongdescText(),
                  xAxisDescription: c.xAxis,
                  yAxisDescription: c.yAxis,
                  playAsSoundButton: u ? this.getSonifyButtonText(v) : "",
                  viewTableButton: o.getCSV
                    ? this.getDataTableButtonText(N)
                    : "",
                  annotationsTitle: w ? R : "",
                  annotationsList: w,
                }),
                (o = i.i18nFormat(r, c, o)),
                (this.dataTableButtonId = N),
                (this.sonifyButtonId = v),
                o.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "")
              );
            }
            defaultAfterChartFormatter() {
              const o = this.chart,
                r =
                  o.options.accessibility.screenReaderSection.afterChartFormat;
              if (!r) return "";
              const c = { endOfChartMarker: this.getEndOfChartMarkerText() };
              return i
                .i18nFormat(r, c, o)
                .replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
            }
            getLinkedDescription() {
              const o = this.linkedDescriptionElement;
              return A((o && o.innerHTML) || "");
            }
            getLongdescText() {
              const o = this.chart.options;
              var r = o.caption;
              r = r && r.text;
              const c = this.getLinkedDescription();
              return o.accessibility.description || c || r || "";
            }
            getTypeDescriptionText() {
              const o = this.chart;
              return o.types
                ? o.options.accessibility.typeDescription || z(o, o.types)
                : "";
            }
            getDataTableButtonText(o) {
              var r = this.chart;
              return (
                (r = r.langFormat(
                  "accessibility.table.viewAsDataTableButtonText",
                  { chart: r, chartTitle: h(r) }
                )),
                '<button id="' + o + '">' + r + "</button>"
              );
            }
            getSonifyButtonText(o) {
              var r = this.chart;
              return r.options.sonification &&
                r.options.sonification.enabled === !1
                ? ""
                : ((r = r.langFormat(
                    "accessibility.sonification.playAsSoundButtonText",
                    { chart: r, chartTitle: h(r) }
                  )),
                  '<button id="' + o + '">' + r + "</button>");
            }
            getSubtitleText() {
              const o = this.chart.options.subtitle;
              return A((o && o.text) || "");
            }
            getEndOfChartMarkerText() {
              const o = this.chart,
                r = o.langFormat(
                  "accessibility.screenReaderSection.endOfChartMarker",
                  { chart: o }
                );
              return (
                '<div id="highcharts-end-of-chart-marker-' +
                o.index +
                '">' +
                r +
                "</div>"
              );
            }
            onDataTableCreated(o) {
              const r = this.chart;
              if (r.options.accessibility.enabled) {
                this.viewDataTableButton &&
                  this.viewDataTableButton.setAttribute(
                    "aria-expanded",
                    "true"
                  );
                const c = o.tree.attributes || {};
                (c.tabindex = -1),
                  (c.summary = r.langFormat(
                    "accessibility.table.tableSummary",
                    { chart: r }
                  )),
                  (o.tree.attributes = c);
              }
            }
            focusDataTable() {
              var o = this.dataTableDiv;
              (o = o && o.getElementsByTagName("table")[0]) &&
                o.focus &&
                o.focus();
            }
            initSonifyButton(o) {
              const r = (this.sonifyButton = T(o)),
                c = this.chart,
                u = (v) => {
                  r &&
                    (r.setAttribute("aria-hidden", "true"),
                    r.setAttribute("aria-label", "")),
                    v.preventDefault(),
                    v.stopPropagation(),
                    (v = c.langFormat(
                      "accessibility.sonification.playAsSoundClickAnnouncement",
                      { chart: c }
                    )),
                    this.announcer.announce(v),
                    setTimeout(() => {
                      r &&
                        (r.removeAttribute("aria-hidden"),
                        r.removeAttribute("aria-label")),
                        c.sonify && c.sonify();
                    }, 1e3);
                };
              r &&
                c &&
                (r.setAttribute("tabindex", -1),
                (r.onclick = function (v) {
                  (
                    (c.options.accessibility &&
                      c.options.accessibility.screenReaderSection
                        .onPlayAsSoundClick) ||
                    u
                  ).call(this, v, c);
                }));
            }
            initDataTableButton(o) {
              const r = (this.viewDataTableButton = T(o)),
                c = this.chart;
              (o = o.replace("hc-linkto-", "")),
                r &&
                  (f(r, { tabindex: -1, "aria-expanded": !!T(o) }),
                  (r.onclick =
                    c.options.accessibility.screenReaderSection
                      .onViewDataTableClick ||
                    function () {
                      c.viewData();
                    }));
            }
            getAxesDescription() {
              const o = this.chart;
              var r = function (N, w) {
                  return (
                    (N = o[N]),
                    1 < N.length ||
                      (N[0] &&
                        b(
                          N[0].options.accessibility &&
                            N[0].options.accessibility.enabled,
                          w
                        ))
                  );
                },
                c =
                  !!o.types &&
                  0 > o.types.indexOf("map") &&
                  0 > o.types.indexOf("treemap") &&
                  0 > o.types.indexOf("tilemap");
              const u = !!o.hasCartesianSeries,
                v = r("xAxis", !o.angular && u && c);
              return (
                (r = r("yAxis", u && c)),
                (c = {}),
                v && (c.xAxis = this.getAxisDescriptionText("xAxis")),
                r && (c.yAxis = this.getAxisDescriptionText("yAxis")),
                c
              );
            }
            getAxisDescriptionText(o) {
              const r = this.chart,
                c = r[o];
              return r.langFormat(
                "accessibility.axis." +
                  o +
                  "Description" +
                  (1 < c.length ? "Plural" : "Singular"),
                {
                  chart: r,
                  names: c.map(function (u) {
                    return x(u);
                  }),
                  ranges: c.map(function (u) {
                    return P(u);
                  }),
                  numAxes: c.length,
                }
              );
            }
            destroy() {
              this.announcer && this.announcer.destroy();
            }
          }
          return y;
        }
      ),
      n(
        e,
        "Accessibility/Components/MenuComponent.js",
        [
          e["Core/Chart/Chart.js"],
          e["Core/Utilities.js"],
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (i, a, d, M, O, B) {
          const { attr: G } = a,
            { getChartTitle: Y, unhideChartElementFromAT: L } = O,
            { getFakeMouseEvent: E } = B;
          class z extends d {
            init() {
              const x = this.chart,
                P = this;
              this.addEvent(x, "exportMenuShown", function () {
                P.onMenuShown();
              }),
                this.addEvent(x, "exportMenuHidden", function () {
                  P.onMenuHidden();
                }),
                this.createProxyGroup();
            }
            onMenuHidden() {
              const x = this.chart.exportContextMenu;
              x && x.setAttribute("aria-hidden", "true"),
                this.setExportButtonExpandedState("false");
            }
            onMenuShown() {
              const x = this.chart,
                P = x.exportContextMenu;
              P && (this.addAccessibleContextMenuAttribs(), L(x, P)),
                this.setExportButtonExpandedState("true");
            }
            setExportButtonExpandedState(x) {
              this.exportButtonProxy &&
                this.exportButtonProxy.buttonElement.setAttribute(
                  "aria-expanded",
                  x
                );
            }
            onChartRender() {
              const x = this.chart,
                P = x.focusElement,
                h = x.accessibility;
              this.proxyProvider.clearGroup("chartMenu"),
                this.proxyMenuButton(),
                this.exportButtonProxy &&
                  P &&
                  P === x.exportingGroup &&
                  (P.focusBorder
                    ? x.setFocusToElement(
                        P,
                        this.exportButtonProxy.buttonElement
                      )
                    : h && h.keyboardNavigation.tabindexContainer.focus());
            }
            proxyMenuButton() {
              const x = this.chart,
                P = this.proxyProvider,
                h = x.exportSVGElements && x.exportSVGElements[0];
              {
                var s = x.options.exporting;
                const l = x.exportSVGElements && x.exportSVGElements[0];
                s = !!(
                  s &&
                  s.enabled !== !1 &&
                  s.accessibility &&
                  s.accessibility.enabled &&
                  l &&
                  l.element
                );
              }
              s &&
                h &&
                (this.exportButtonProxy = P.addProxyElement(
                  "chartMenu",
                  { click: h },
                  {
                    "aria-label": x.langFormat(
                      "accessibility.exporting.menuButtonLabel",
                      { chart: x, chartTitle: Y(x) }
                    ),
                    "aria-expanded": !1,
                    title: x.options.lang.contextButtonTitle || null,
                  }
                ));
            }
            createProxyGroup() {
              this.chart &&
                this.proxyProvider &&
                this.proxyProvider.addGroup("chartMenu", "div");
            }
            addAccessibleContextMenuAttribs() {
              const x = this.chart;
              var P = x.exportDivElements;
              P &&
                P.length &&
                (P.forEach((h) => {
                  h &&
                    (h.tagName !== "LI" || (h.children && h.children.length)
                      ? h.setAttribute("aria-hidden", "true")
                      : h.setAttribute("tabindex", -1));
                }),
                (P = P[0] && P[0].parentNode) &&
                  G(P, {
                    "aria-hidden": void 0,
                    "aria-label": x.langFormat(
                      "accessibility.exporting.chartMenuLabel",
                      { chart: x }
                    ),
                    role: "list",
                  }));
            }
            getKeyboardNavigation() {
              const x = this.keyCodes,
                P = this.chart,
                h = this;
              return new M(P, {
                keyCodeMap: [
                  [
                    [x.left, x.up],
                    function () {
                      return h.onKbdPrevious(this);
                    },
                  ],
                  [
                    [x.right, x.down],
                    function () {
                      return h.onKbdNext(this);
                    },
                  ],
                  [
                    [x.enter, x.space],
                    function () {
                      return h.onKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return (
                    !!P.exporting &&
                    P.options.exporting.enabled !== !1 &&
                    P.options.exporting.accessibility.enabled !== !1
                  );
                },
                init: function () {
                  const s = h.exportButtonProxy,
                    l = h.chart.exportingGroup;
                  s && l && P.setFocusToElement(l, s.buttonElement);
                },
                terminate: function () {
                  P.hideExportMenu();
                },
              });
            }
            onKbdPrevious(x) {
              const P = this.chart,
                h = P.options.accessibility;
              x = x.response;
              let s = P.highlightedExportItemIx || 0;
              for (; s--; ) if (P.highlightExportItem(s)) return x.success;
              return h.keyboardNavigation.wrapAround
                ? (P.highlightLastExportItem(), x.success)
                : x.prev;
            }
            onKbdNext(x) {
              const P = this.chart,
                h = P.options.accessibility;
              x = x.response;
              for (
                let s = (P.highlightedExportItemIx || 0) + 1;
                s < P.exportDivElements.length;
                ++s
              )
                if (P.highlightExportItem(s)) return x.success;
              return h.keyboardNavigation.wrapAround
                ? (P.highlightExportItem(0), x.success)
                : x.next;
            }
            onKbdClick(x) {
              const P = this.chart,
                h = P.exportDivElements[P.highlightedExportItemIx],
                s = (P.exportSVGElements && P.exportSVGElements[0]).element;
              return (
                P.openMenu
                  ? this.fakeClickEvent(h)
                  : (this.fakeClickEvent(s), P.highlightExportItem(0)),
                x.response.success
              );
            }
          }
          return (
            (function (S) {
              function x() {
                var p = this.exportSVGElements && this.exportSVGElements[0];
                p && ((p = p.element), p.onclick) && p.onclick(E("click"));
              }
              function P() {
                const p = this.exportDivElements;
                p &&
                  this.exportContextMenu &&
                  this.openMenu &&
                  (p.forEach((g) => {
                    g &&
                      g.className === "highcharts-menu-item" &&
                      g.onmouseout &&
                      g.onmouseout(E("mouseout"));
                  }),
                  (this.highlightedExportItemIx = 0),
                  this.exportContextMenu.hideMenu(),
                  this.container.focus());
              }
              function h(p) {
                const g = this.exportDivElements && this.exportDivElements[p],
                  T =
                    this.exportDivElements &&
                    this.exportDivElements[this.highlightedExportItemIx];
                if (
                  g &&
                  g.tagName === "LI" &&
                  (!g.children || !g.children.length)
                ) {
                  const D = !!(this.renderTo.getElementsByTagName("g")[0] || {})
                    .focus;
                  return (
                    g.focus && D && g.focus(),
                    T && T.onmouseout && T.onmouseout(E("mouseout")),
                    g.onmouseover && g.onmouseover(E("mouseover")),
                    (this.highlightedExportItemIx = p),
                    !0
                  );
                }
                return !1;
              }
              function s() {
                if (this.exportDivElements) {
                  let p = this.exportDivElements.length;
                  for (; p--; ) if (this.highlightExportItem(p)) return !0;
                }
                return !1;
              }
              const l = [];
              S.compose = function (p) {
                a.pushUnique(l, p) &&
                  ((p = i.prototype),
                  (p.hideExportMenu = P),
                  (p.highlightExportItem = h),
                  (p.highlightLastExportItem = s),
                  (p.showExportMenu = x));
              };
            })(z || (z = {})),
            z
          );
        }
      ),
      n(
        e,
        "Accessibility/KeyboardNavigation.js",
        [
          e["Core/Globals.js"],
          e["Accessibility/Components/MenuComponent.js"],
          e["Core/Utilities.js"],
          e["Accessibility/Utils/EventProvider.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (i, a, d, M, O) {
          const { doc: B, win: G } = i,
            { addEvent: Y, fireEvent: L } = d,
            { getElement: E, simulatedEventTarget: z } = O;
          class S {
            constructor(P, h) {
              (this.components = this.chart = void 0),
                (this.currentModuleIx = NaN),
                (this.exitAnchor = this.eventProvider = void 0),
                (this.modules = []),
                (this.tabindexContainer = void 0),
                this.init(P, h);
            }
            init(P, h) {
              const s = (this.eventProvider = new M());
              (this.chart = P),
                (this.components = h),
                (this.modules = []),
                (this.currentModuleIx = 0),
                this.update(),
                s.addEvent(this.tabindexContainer, "keydown", (l) =>
                  this.onKeydown(l)
                ),
                s.addEvent(this.tabindexContainer, "focus", (l) =>
                  this.onFocus(l)
                ),
                ["mouseup", "touchend"].forEach((l) =>
                  s.addEvent(B, l, (p) => this.onMouseUp(p))
                ),
                ["mousedown", "touchstart"].forEach((l) =>
                  s.addEvent(P.renderTo, l, () => {
                    this.isClickingChart = !0;
                  })
                );
            }
            update(P) {
              var h = this.chart.options.accessibility;
              h = h && h.keyboardNavigation;
              const s = this.components;
              this.updateContainerTabindex(),
                h && h.enabled && P && P.length
                  ? ((this.modules = P.reduce(function (l, p) {
                      return (p = s[p].getKeyboardNavigation()), l.concat(p);
                    }, [])),
                    this.updateExitAnchor())
                  : ((this.modules = []),
                    (this.currentModuleIx = 0),
                    this.removeExitAnchor());
            }
            updateExitAnchor() {
              const P = E(`highcharts-end-of-chart-marker-${this.chart.index}`);
              this.removeExitAnchor(),
                P
                  ? (this.makeElementAnExitAnchor(P), (this.exitAnchor = P))
                  : this.createExitAnchor();
            }
            move(P) {
              var h = this.modules && this.modules[this.currentModuleIx];
              if (
                (h && h.terminate && h.terminate(P),
                this.chart.focusElement &&
                  this.chart.focusElement.removeFocusBorder(),
                (this.currentModuleIx += P),
                (h = this.modules && this.modules[this.currentModuleIx]))
              ) {
                if (h.validate && !h.validate()) return this.move(P);
                if (h.init) return h.init(P), !0;
              }
              return (
                (this.currentModuleIx = 0),
                (this.exiting = !0),
                0 < P
                  ? this.exitAnchor && this.exitAnchor.focus()
                  : this.tabindexContainer.focus(),
                !1
              );
            }
            onFocus(P) {
              var h = this.chart;
              (P = P.relatedTarget && h.container.contains(P.relatedTarget)),
                !(h = (h = h.options.accessibility) && h.keyboardNavigation) ||
                  !h.enabled ||
                  this.exiting ||
                  this.tabbingInBackwards ||
                  this.isClickingChart ||
                  P ||
                  ((P = this.getFirstValidModuleIx()),
                  P !== null &&
                    ((this.currentModuleIx = P), this.modules[P].init(1))),
                (this.exiting = !1);
            }
            onMouseUp(P) {
              if (
                (delete this.isClickingChart,
                !this.keyboardReset && P.relatedTarget !== z)
              ) {
                const h = this.chart;
                (P.target && h.container.contains(P.target)) ||
                  ((P =
                    this.modules && this.modules[this.currentModuleIx || 0]) &&
                    P.terminate &&
                    P.terminate(),
                  (this.currentModuleIx = 0)),
                  h.focusElement &&
                    (h.focusElement.removeFocusBorder(), delete h.focusElement),
                  (this.keyboardReset = !0);
              }
            }
            onKeydown(P) {
              P = P || G.event;
              const h =
                this.modules &&
                this.modules.length &&
                this.modules[this.currentModuleIx];
              let s;
              if (((this.exiting = this.keyboardReset = !1), h)) {
                const l = h.run(P);
                l === h.response.success
                  ? (s = !0)
                  : l === h.response.prev
                  ? (s = this.move(-1))
                  : l === h.response.next && (s = this.move(1)),
                  s && (P.preventDefault(), P.stopPropagation());
              }
            }
            updateContainerTabindex() {
              var P = this.chart.options.accessibility;
              (P = P && P.keyboardNavigation), (P = !(P && P.enabled === !1));
              const h = this.chart;
              var s = h.container;
              h.renderTo.hasAttribute("tabindex") &&
                (s.removeAttribute("tabindex"), (s = h.renderTo)),
                (this.tabindexContainer = s);
              const l = s.getAttribute("tabindex");
              P && !l
                ? s.setAttribute("tabindex", "0")
                : P || h.container.removeAttribute("tabindex");
            }
            createExitAnchor() {
              const P = this.chart,
                h = (this.exitAnchor = B.createElement("div"));
              P.renderTo.appendChild(h), this.makeElementAnExitAnchor(h);
            }
            makeElementAnExitAnchor(P) {
              const h = this.tabindexContainer.getAttribute("tabindex") || 0;
              P.setAttribute("class", "highcharts-exit-anchor"),
                P.setAttribute("tabindex", h),
                P.setAttribute("aria-hidden", !1),
                this.addExitAnchorEventsToEl(P);
            }
            removeExitAnchor() {
              this.exitAnchor &&
                this.exitAnchor.parentNode &&
                (this.exitAnchor.parentNode.removeChild(this.exitAnchor),
                delete this.exitAnchor);
            }
            addExitAnchorEventsToEl(P) {
              const h = this.chart,
                s = this;
              this.eventProvider.addEvent(P, "focus", function (l) {
                l = l || G.event;
                const p = !(
                  (l.relatedTarget && h.container.contains(l.relatedTarget)) ||
                  s.exiting
                );
                h.focusElement && delete h.focusElement,
                  p
                    ? ((s.tabbingInBackwards = !0),
                      s.tabindexContainer.focus(),
                      delete s.tabbingInBackwards,
                      l.preventDefault(),
                      s.modules &&
                        s.modules.length &&
                        ((s.currentModuleIx = s.modules.length - 1),
                        (l = s.modules[s.currentModuleIx]) &&
                        l.validate &&
                        !l.validate()
                          ? s.move(-1)
                          : l && l.init(-1)))
                    : (s.exiting = !1);
              });
            }
            getFirstValidModuleIx() {
              const P = this.modules.length;
              for (let h = 0; h < P; ++h) {
                const s = this.modules[h];
                if (!s.validate || s.validate()) return h;
              }
              return null;
            }
            destroy() {
              this.removeExitAnchor(),
                this.eventProvider.removeAddedEvents(),
                this.chart.container.removeAttribute("tabindex");
            }
          }
          return (
            (function (x) {
              function P() {
                const l = this;
                L(this, "dismissPopupContent", {}, function () {
                  l.tooltip && l.tooltip.hide(0), l.hideExportMenu();
                });
              }
              function h(l) {
                (l.which || l.keyCode) === 27 &&
                  i.charts &&
                  i.charts.forEach((p) => {
                    p && p.dismissPopupContent && p.dismissPopupContent();
                  });
              }
              const s = [];
              x.compose = function (l) {
                return (
                  a.compose(l),
                  d.pushUnique(s, l) && (l.prototype.dismissPopupContent = P),
                  d.pushUnique(s, B) && Y(B, "keydown", h),
                  l
                );
              };
            })(S || (S = {})),
            S
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/LegendComponent.js",
        [
          e["Core/Animation/AnimationUtilities.js"],
          e["Core/Globals.js"],
          e["Core/Legend/Legend.js"],
          e["Core/Utilities.js"],
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (i, a, d, M, O, B, G, Y) {
          function L(m) {
            const f = m.legend && m.legend.allItems,
              b = m.options.legend.accessibility || {};
            return (
              (m =
                m.colorAxis &&
                m.colorAxis.some(
                  (y) => !y.dataClasses || !y.dataClasses.length
                )),
              !(!f || !f.length || m || b.enabled === !1)
            );
          }
          function E(m, f) {
            const b = f.legendItem || {};
            f.setState(m ? "hover" : "", !0);
            for (const y of ["group", "label", "symbol"])
              (f = ((f = b[y]) && f.element) || f) &&
                P(f, m ? "mouseover" : "mouseout");
          }
          const { animObject: z } = i,
            { doc: S } = a,
            {
              addEvent: x,
              fireEvent: P,
              isNumber: h,
              pick: s,
              syncTimeout: l,
            } = M,
            { getChartTitle: p } = G,
            { stripHTMLTagsFromString: g, addClass: T, removeClass: D } = Y;
          class A extends O {
            constructor() {
              super(...arguments),
                (this.highlightedLegendItemIx = NaN),
                (this.proxyGroup = null);
            }
            init() {
              const f = this;
              this.recreateProxies(),
                this.addEvent(d, "afterScroll", function () {
                  this.chart === f.chart &&
                    (f.proxyProvider.updateGroupProxyElementPositions("legend"),
                    f.updateLegendItemProxyVisibility(),
                    -1 < f.highlightedLegendItemIx &&
                      this.chart.highlightLegendItem(
                        f.highlightedLegendItemIx
                      ));
                }),
                this.addEvent(d, "afterPositionItem", function (b) {
                  this.chart === f.chart &&
                    this.chart.renderer &&
                    f.updateProxyPositionForItem(b.item);
                }),
                this.addEvent(d, "afterRender", function () {
                  this.chart === f.chart &&
                    this.chart.renderer &&
                    f.recreateProxies() &&
                    l(
                      () =>
                        f.proxyProvider.updateGroupProxyElementPositions(
                          "legend"
                        ),
                      z(s(this.chart.renderer.globalAnimation, !0)).duration
                    );
                });
            }
            updateLegendItemProxyVisibility() {
              const f = this.chart,
                b = f.legend,
                y = b.currentPage || 1,
                C = b.clipHeight || 0;
              let o;
              (b.allItems || []).forEach((r) => {
                if (r.a11yProxyElement) {
                  var c = b.pages && b.pages.length;
                  const v = r.a11yProxyElement.element;
                  var u = !1;
                  (o = r.legendItem || {}),
                    c &&
                      ((r = o.pageIx || 0),
                      (c = o.y || 0),
                      (u = o.label ? Math.round(o.label.getBBox().height) : 0),
                      (u = c + u - b.pages[r] > C || r !== y - 1)),
                    u
                      ? f.styledMode
                        ? T(v, "highcharts-a11y-invisible")
                        : (v.style.visibility = "hidden")
                      : (D(v, "highcharts-a11y-invisible"),
                        (v.style.visibility = ""));
                }
              });
            }
            onChartRender() {
              L(this.chart) || this.removeProxies();
            }
            highlightAdjacentLegendPage(f) {
              const b = this.chart;
              var y = b.legend;
              f = (y.currentPage || 1) + f;
              var C = y.pages || [];
              if (0 < f && f <= C.length) {
                C = 0;
                for (const o of y.allItems)
                  ((o.legendItem || {}).pageIx || 0) + 1 === f &&
                    (y = b.highlightLegendItem(C)) &&
                    (this.highlightedLegendItemIx = C),
                    ++C;
              }
            }
            updateProxyPositionForItem(f) {
              f.a11yProxyElement && f.a11yProxyElement.refreshPosition();
            }
            recreateProxies() {
              var f = S.activeElement;
              const b = this.proxyGroup;
              return (
                (f = f && b && b.contains(f)),
                this.removeProxies(),
                L(this.chart)
                  ? (this.addLegendProxyGroup(),
                    this.proxyLegendItems(),
                    this.updateLegendItemProxyVisibility(),
                    this.updateLegendTitle(),
                    f &&
                      this.chart.highlightLegendItem(
                        this.highlightedLegendItemIx
                      ),
                    !0)
                  : !1
              );
            }
            removeProxies() {
              this.proxyProvider.removeGroup("legend");
            }
            updateLegendTitle() {
              var f = this.chart;
              const b = g(
                (
                  (f.legend &&
                    f.legend.options.title &&
                    f.legend.options.title.text) ||
                  ""
                ).replace(/<br ?\/?>/g, " ")
              );
              (f = f.langFormat(
                "accessibility.legend.legendLabel" + (b ? "" : "NoTitle"),
                { chart: f, legendTitle: b, chartTitle: p(f) }
              )),
                this.proxyProvider.updateGroupAttrs("legend", {
                  "aria-label": f,
                });
            }
            addLegendProxyGroup() {
              this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", {
                "aria-label": "_placeholder_",
                role:
                  this.chart.options.accessibility.landmarkVerbosity === "all"
                    ? "region"
                    : null,
              });
            }
            proxyLegendItems() {
              const f = this;
              let b;
              ((this.chart.legend || {}).allItems || []).forEach((y) => {
                (b = y.legendItem || {}),
                  b.label && b.label.element && f.proxyLegendItem(y);
              });
            }
            proxyLegendItem(f) {
              const b = f.legendItem || {};
              if (b.label && b.group) {
                var y = this.chart.langFormat(
                  "accessibility.legend.legendItem",
                  { chart: this.chart, itemName: g(f.name), item: f }
                );
                f.a11yProxyElement = this.proxyProvider.addProxyElement(
                  "legend",
                  {
                    click: b.label,
                    visual: (b.group.div ? b.label : b.group).element,
                  },
                  { tabindex: -1, "aria-pressed": f.visible, "aria-label": y }
                );
              }
            }
            getKeyboardNavigation() {
              const f = this.keyCodes,
                b = this,
                y = this.chart;
              return new B(y, {
                keyCodeMap: [
                  [
                    [f.left, f.right, f.up, f.down],
                    function (C) {
                      return b.onKbdArrowKey(this, C);
                    },
                  ],
                  [
                    [f.enter, f.space],
                    function () {
                      return b.onKbdClick(this);
                    },
                  ],
                  [
                    [f.pageDown, f.pageUp],
                    function (C) {
                      return (
                        b.highlightAdjacentLegendPage(
                          C === f.pageDown ? 1 : -1
                        ),
                        this.response.success
                      );
                    },
                  ],
                ],
                validate: function () {
                  return b.shouldHaveLegendNavigation();
                },
                init: function () {
                  y.highlightLegendItem(0), (b.highlightedLegendItemIx = 0);
                },
                terminate: function () {
                  (b.highlightedLegendItemIx = -1),
                    y.legend.allItems.forEach((C) => E(!1, C));
                },
              });
            }
            onKbdArrowKey(f, b) {
              const y = this.keyCodes,
                C = f.response,
                o = this.chart,
                r = o.options.accessibility,
                c = o.legend.allItems.length;
              return (
                (b = b === y.left || b === y.up ? -1 : 1),
                o.highlightLegendItem(this.highlightedLegendItemIx + b)
                  ? ((this.highlightedLegendItemIx += b), C.success)
                  : (1 < c && r.keyboardNavigation.wrapAround && f.init(b),
                    C.success)
              );
            }
            onKbdClick(f) {
              const b =
                this.chart.legend.allItems[this.highlightedLegendItemIx];
              return (
                b && b.a11yProxyElement && b.a11yProxyElement.click(),
                f.response.success
              );
            }
            shouldHaveLegendNavigation() {
              if (!L(this.chart)) return !1;
              const f = this.chart,
                b = (f.options.legend || {}).accessibility || {};
              return !!(
                f.legend.display &&
                b.keyboardNavigation &&
                b.keyboardNavigation.enabled
              );
            }
          }
          return (
            (function (m) {
              function f(C) {
                var o = this.legend.allItems,
                  r =
                    this.accessibility &&
                    this.accessibility.components.legend
                      .highlightedLegendItemIx;
                const c = o[C];
                var u = c.legendItem || {};
                return c
                  ? (h(r) && o[r] && E(!1, o[r]),
                    (o = this.legend),
                    (C = (o.allItems[C].legendItem || {}).pageIx),
                    (r = o.currentPage),
                    typeof C < "u" && C + 1 !== r && o.scroll(1 + C - r),
                    (u = u.label),
                    (C =
                      c.a11yProxyElement && c.a11yProxyElement.buttonElement),
                    u && u.element && C && this.setFocusToElement(u, C),
                    E(!0, c),
                    !0)
                  : !1;
              }
              function b(C) {
                const o = C.item;
                this.chart.options.accessibility.enabled &&
                  o &&
                  o.a11yProxyElement &&
                  o.a11yProxyElement.buttonElement.setAttribute(
                    "aria-pressed",
                    C.visible ? "true" : "false"
                  );
              }
              const y = [];
              m.compose = function (C, o) {
                M.pushUnique(y, C) && (C.prototype.highlightLegendItem = f),
                  M.pushUnique(y, o) && x(o, "afterColorizeItem", b);
              };
            })(A || (A = {})),
            A
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/SeriesComponent/SeriesDescriber.js",
        [
          e["Accessibility/Components/AnnotationsA11y.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Core/Templating.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          function B(u) {
            const v = u.index;
            return (
              (u.series &&
                u.series.data &&
                c(v) &&
                y(u.series.data, function (N) {
                  return !!(
                    N &&
                    typeof N.index < "u" &&
                    N.index > v &&
                    N.graphic &&
                    N.graphic.element
                  );
                })) ||
              null
            );
          }
          function G(u) {
            const v =
              u.chart.options.accessibility.series
                .pointDescriptionEnabledThreshold;
            return !!(v !== !1 && u.points && u.points.length >= v);
          }
          function Y(u) {
            const v = u.options.accessibility || {};
            return !G(u) && !v.exposeAsGroupOnly;
          }
          function L(u) {
            const v =
              u.chart.options.accessibility.keyboardNavigation.seriesNavigation;
            return !(
              !u.points ||
              !(
                u.points.length < v.pointNavigationEnabledThreshold ||
                v.pointNavigationEnabledThreshold === !1
              )
            );
          }
          function E(u, v) {
            var N = u.series,
              w = N.chart;
            u = w.options.accessibility.point || {};
            const R =
              (N.options.accessibility && N.options.accessibility.point) || {};
            return (
              (N = N.tooltipOptions || {}),
              (w = w.options.lang),
              C(v)
                ? m(
                    v,
                    R.valueDecimals || u.valueDecimals || N.valueDecimals || -1,
                    w.decimalPoint,
                    w.accessibility.thousandsSep || w.thousandsSep
                  )
                : v
            );
          }
          function z(u) {
            const v = (u.options.accessibility || {}).description;
            return (
              (v &&
                u.chart.langFormat("accessibility.series.description", {
                  description: v,
                  series: u,
                })) ||
              ""
            );
          }
          function S(u, v) {
            return u.chart.langFormat(
              "accessibility.series." + v + "Description",
              { name: p(u[v]), series: u }
            );
          }
          function x(u, v, N) {
            const w = v || "",
              R = N || "";
            return u.series.pointArrayMap.reduce(function (X, J) {
              {
                const K = E(u, r(u[J], u.options[J]));
                J = K !== void 0 ? J + ": " + w + K + R : K;
              }
              return J ? X + (X.length ? ", " : "") + J : X;
            }, "");
          }
          function P(u) {
            var v = u.series,
              N = 1 < v.chart.series.length || v.options.name,
              w = u.series,
              R = w.chart,
              X = w.options.accessibility;
            if (
              ((X =
                (X && X.point && X.point.valueDescriptionFormat) ||
                R.options.accessibility.point.valueDescriptionFormat),
              (w = r(
                w.xAxis &&
                  w.xAxis.options.accessibility &&
                  w.xAxis.options.accessibility.enabled,
                !R.angular && w.type !== "flowmap"
              )),
              w)
            ) {
              var J = u.series,
                K = J.chart,
                H =
                  (J.options.accessibility && J.options.accessibility.point) ||
                  {},
                k = K.options.accessibility.point || {};
              (J = J.xAxis && J.xAxis.dateTime)
                ? ((J = J.getXDateFormat(
                    u.x || 0,
                    K.options.tooltip.dateTimeLabelFormats
                  )),
                  (H =
                    (H.dateFormatter && H.dateFormatter(u)) ||
                    (k.dateFormatter && k.dateFormatter(u)) ||
                    H.dateFormat ||
                    k.dateFormat ||
                    J),
                  (K = K.time.dateFormat(H, u.x || 0, void 0)))
                : (K = void 0),
                (H =
                  (u.series.xAxis || {}).categories &&
                  c(u.category) &&
                  ("" + u.category).replace("<br/>", " ")),
                (k = c(u.id) && 0 > ("" + u.id).indexOf("highcharts-")),
                (J = "x, " + u.x),
                (K = u.name || K || H || (k ? u.id : J));
            } else K = "";
            (H = K), (K = c(u.index) ? u.index + 1 : "");
            {
              k = u.series;
              var U = k.chart.options.accessibility.point || {},
                _ =
                  (k.chart.options.accessibility &&
                    k.chart.options.accessibility.point) ||
                  {};
              const W = k.tooltipOptions || {};
              (J = _.valuePrefix || U.valuePrefix || W.valuePrefix || ""),
                (U = _.valueSuffix || U.valueSuffix || W.valueSuffix || ""),
                (_ = E(u, u[typeof u.value < "u" ? "value" : "y"])),
                (k = u.isNull
                  ? k.chart.langFormat("accessibility.series.nullPointValue", {
                      point: u,
                    })
                  : k.pointArrayMap
                  ? x(u, J, U)
                  : J + _ + U);
            }
            return (
              (R = A(
                X,
                {
                  point: u,
                  index: K,
                  xDescription: H,
                  value: k,
                  separator: w ? ", " : "",
                },
                R
              )),
              (X = (X =
                u.options &&
                u.options.accessibility &&
                u.options.accessibility.description)
                ? " " + X
                : ""),
              (v = N ? " " + v.name + "." : ""),
              (N = u.series.chart),
              (w = l(u)),
              (K = { point: u, annotations: w }),
              (N = w.length
                ? N.langFormat(
                    "accessibility.series.pointAnnotationsDescription",
                    K
                  )
                : ""),
              (u.accessibility = u.accessibility || {}),
              (u.accessibility.valueDescription = R),
              R + X + v + (N ? " " + N : "")
            );
          }
          function h(u) {
            const v = Y(u),
              N = L(u),
              w = u.chart.options.accessibility.point.describeNull;
            (v || N) &&
              u.points.forEach((R) => {
                var X;
                if (!(X = R.graphic && R.graphic.element)) {
                  var J = R.series;
                  if (
                    ((X = J && J.chart),
                    (J = J && J.is("sunburst")),
                    (X = X && X.options.accessibility.point.describeNull),
                    (X = R.isNull && !J && X))
                  ) {
                    J = R.series;
                    var K = B(R);
                    (J = (X = K && K.graphic)
                      ? X.parentGroup
                      : J.graph || J.group),
                      (K = K
                        ? {
                            x: r(R.plotX, K.plotX, 0),
                            y: r(R.plotY, K.plotY, 0),
                          }
                        : { x: r(R.plotX, 0), y: r(R.plotY, 0) }),
                      (K = R.series.chart.renderer.rect(K.x, K.y, 1, 1)),
                      K.attr({
                        class: "highcharts-a11y-mock-point",
                        fill: "none",
                        opacity: 0,
                        "fill-opacity": 0,
                        "stroke-opacity": 0,
                      }),
                      J && J.element
                        ? ((R.graphic = K),
                          (R.hasMockGraphic = !0),
                          K.add(J),
                          J.element.insertBefore(
                            K.element,
                            X ? X.element : null
                          ),
                          (X = K.element))
                        : (X = void 0);
                  }
                }
                if (
                  ((J =
                    R.options &&
                    R.options.accessibility &&
                    R.options.accessibility.enabled === !1),
                  X)
                )
                  if (R.isNull && !w) X.setAttribute("aria-hidden", !0);
                  else if (
                    (X.setAttribute("tabindex", "-1"),
                    u.chart.styledMode || (X.style.outline = "none"),
                    v && !J)
                  ) {
                    var H, k, U;
                    (J = R.series),
                      (K =
                        ((H = J.options.accessibility) === null || H === void 0
                          ? void 0
                          : H.point) || {}),
                      (H = J.chart.options.accessibility.point || {}),
                      (R = b(
                        (o(K.descriptionFormat) &&
                          A(K.descriptionFormat, R, J.chart)) ||
                          ((k = K.descriptionFormatter) === null || k === void 0
                            ? void 0
                            : k.call(K, R)) ||
                          (o(H.descriptionFormat) &&
                            A(H.descriptionFormat, R, J.chart)) ||
                          ((U = H.descriptionFormatter) === null || U === void 0
                            ? void 0
                            : U.call(H, R)) ||
                          P(R)
                      )),
                      X.setAttribute("role", "img"),
                      X.setAttribute("aria-label", R);
                  } else X.setAttribute("aria-hidden", !0);
              });
          }
          function s(u) {
            const v = u.chart;
            var N = v.types || [];
            const w = z(u);
            var R = function (k) {
              return v[k] && 1 < v[k].length && u[k];
            };
            const X = u.index + 1;
            var J = S(u, "xAxis");
            const K = S(u, "yAxis");
            var H = { seriesNumber: X, series: u, chart: v };
            return (
              (N = 1 < N.length ? "Combination" : ""),
              (H =
                v.langFormat("accessibility.series.summary." + u.type + N, H) ||
                v.langFormat("accessibility.series.summary.default" + N, H)),
              (R =
                (R("yAxis") ? " " + K + "." : "") +
                (R("xAxis") ? " " + J + "." : "")),
              (J = r(
                u.options.accessibility &&
                  u.options.accessibility.descriptionFormat,
                v.options.accessibility.series.descriptionFormat,
                ""
              )),
              A(
                J,
                {
                  seriesDescription: H,
                  authorDescription: w ? " " + w : "",
                  axisDescription: R,
                  series: u,
                  chart: v,
                  seriesNumber: X,
                },
                void 0
              )
            );
          }
          const { getPointAnnotationTexts: l } = i,
            {
              getAxisDescription: p,
              getSeriesFirstPointElement: g,
              getSeriesA11yElement: T,
              unhideChartElementFromAT: D,
            } = a,
            { format: A, numberFormat: m } = d,
            { reverseChildNodes: f, stripHTMLTagsFromString: b } = M,
            { find: y, isNumber: C, isString: o, pick: r, defined: c } = O;
          return {
            defaultPointDescriptionFormatter: P,
            defaultSeriesDescriptionFormatter: s,
            describeSeries: function (u) {
              var v = u.chart,
                N = g(u);
              const w = T(u);
              var R = v.is3d && v.is3d();
              if (w) {
                w.lastChild !== N || R || f(w), h(u), D(v, w);
                {
                  (R = u.chart),
                    (v = R.options.chart),
                    (N = 1 < R.series.length),
                    (R = R.options.accessibility.series.describeSingleSeries);
                  const X = (u.options.accessibility || {}).exposeAsGroupOnly;
                  v =
                    !(v.options3d && v.options3d.enabled && N) &&
                    (N || R || X || G(u));
                }
                v
                  ? ((v = u.chart.options.accessibility),
                    (N = v.landmarkVerbosity),
                    (u.options.accessibility || {}).exposeAsGroupOnly
                      ? w.setAttribute("role", "img")
                      : N === "all"
                      ? w.setAttribute("role", "region")
                      : w.setAttribute("role", "group"),
                    w.setAttribute("tabindex", "-1"),
                    u.chart.styledMode || (w.style.outline = "none"),
                    w.setAttribute(
                      "aria-label",
                      b(
                        (v.series.descriptionFormatter &&
                          v.series.descriptionFormatter(u)) ||
                          s(u)
                      )
                    ))
                  : w.removeAttribute("aria-label");
              }
            },
          };
        }
      ),
      n(
        e,
        "Accessibility/Components/SeriesComponent/NewDataAnnouncer.js",
        [
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
          e["Accessibility/Utils/Announcer.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/EventProvider.js"],
          e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
        ],
        function (i, a, d, M, O, B) {
          function G(h) {
            const s = h.series.data.filter((l) => h.x === l.x && h.y === l.y);
            return s.length === 1 ? s[0] : h;
          }
          function Y(h, s) {
            const l = (h || [])
              .concat(s || [])
              .reduce((p, g) => ((p[g.name + g.index] = g), p), {});
            return Object.keys(l).map((p) => l[p]);
          }
          const { addEvent: L, defined: E } = a,
            { getChartTitle: z } = M,
            {
              defaultPointDescriptionFormatter: S,
              defaultSeriesDescriptionFormatter: x,
            } = B;
          class P {
            constructor(s) {
              (this.announcer = void 0),
                (this.dirty = { allSeries: {} }),
                (this.eventProvider = void 0),
                (this.lastAnnouncementTime = 0),
                (this.chart = s);
            }
            init() {
              const s = this.chart,
                l = s.options.accessibility.announceNewData.interruptUser
                  ? "assertive"
                  : "polite";
              (this.lastAnnouncementTime = 0),
                (this.dirty = { allSeries: {} }),
                (this.eventProvider = new O()),
                (this.announcer = new d(s, l)),
                this.addEventListeners();
            }
            destroy() {
              this.eventProvider.removeAddedEvents(), this.announcer.destroy();
            }
            addEventListeners() {
              const s = this,
                l = this.chart,
                p = this.eventProvider;
              p.addEvent(l, "afterApplyDrilldown", function () {
                s.lastAnnouncementTime = 0;
              }),
                p.addEvent(l, "afterAddSeries", function (g) {
                  s.onSeriesAdded(g.series);
                }),
                p.addEvent(l, "redraw", function () {
                  s.announceDirtyData();
                });
            }
            onSeriesAdded(s) {
              this.chart.options.accessibility.announceNewData.enabled &&
                ((this.dirty.hasDirty = !0),
                (this.dirty.allSeries[s.name + s.index] = s),
                (this.dirty.newSeries = E(this.dirty.newSeries) ? void 0 : s));
            }
            announceDirtyData() {
              const s = this;
              if (
                this.chart.options.accessibility.announceNewData &&
                this.dirty.hasDirty
              ) {
                let l = this.dirty.newPoint;
                l && (l = G(l)),
                  this.queueAnnouncement(
                    Object.keys(this.dirty.allSeries).map(
                      (p) => s.dirty.allSeries[p]
                    ),
                    this.dirty.newSeries,
                    l
                  ),
                  (this.dirty = { allSeries: {} });
              }
            }
            queueAnnouncement(s, l, p) {
              var g = this.chart.options.accessibility.announceNewData;
              if (g.enabled) {
                const T = +new Date();
                (g = Math.max(
                  0,
                  g.minAnnounceInterval - (T - this.lastAnnouncementTime)
                )),
                  (s = Y(
                    this.queuedAnnouncement && this.queuedAnnouncement.series,
                    s
                  )),
                  (l = this.buildAnnouncementMessage(s, l, p)) &&
                    (this.queuedAnnouncement &&
                      clearTimeout(this.queuedAnnouncementTimer),
                    (this.queuedAnnouncement = {
                      time: T,
                      message: l,
                      series: s,
                    }),
                    (this.queuedAnnouncementTimer = setTimeout(() => {
                      this &&
                        this.announcer &&
                        ((this.lastAnnouncementTime = +new Date()),
                        this.announcer.announce(
                          this.queuedAnnouncement.message
                        ),
                        delete this.queuedAnnouncement,
                        delete this.queuedAnnouncementTimer);
                    }, g)));
              }
            }
            buildAnnouncementMessage(s, l, p) {
              const g = this.chart;
              var T = g.options.accessibility.announceNewData;
              return T.announcementFormatter &&
                ((s = T.announcementFormatter(s, l, p)), s !== !1)
                ? s.length
                  ? s
                  : null
                : ((s =
                    i.charts && 1 < i.charts.length ? "Multiple" : "Single"),
                  (s = l
                    ? "newSeriesAnnounce" + s
                    : p
                    ? "newPointAnnounce" + s
                    : "newDataAnnounce"),
                  (T = z(g)),
                  g.langFormat("accessibility.announceNewData." + s, {
                    chartTitle: T,
                    seriesDesc: l ? x(l) : null,
                    pointDesc: p ? S(p) : null,
                    point: p,
                    series: l,
                  }));
            }
          }
          return (
            (function (h) {
              function s(p) {
                const g = this.chart,
                  T = this.newDataAnnouncer;
                T &&
                  T.chart === g &&
                  g.options.accessibility.announceNewData.enabled &&
                  (T.dirty.newPoint = E(T.dirty.newPoint) ? void 0 : p.point);
              }
              function l() {
                const p = this.chart,
                  g = this.newDataAnnouncer;
                g &&
                  g.chart === p &&
                  p.options.accessibility.announceNewData.enabled &&
                  ((g.dirty.hasDirty = !0),
                  (g.dirty.allSeries[this.name + this.index] = this));
              }
              (h.composedMembers = []),
                (h.compose = function (p) {
                  a.pushUnique(h.composedMembers, p) &&
                    (L(p, "addPoint", s), L(p, "updatedData", l));
                });
            })(P || (P = {})),
            P
          );
        }
      ),
      n(
        e,
        "Accessibility/ProxyElement.js",
        [
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
          e["Accessibility/Utils/EventProvider.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (i, a, d, M, O) {
          const { doc: B } = i,
            { attr: G, css: Y, merge: L } = a,
            { fireEventOnWrappedOrUnwrappedElement: E } = M,
            {
              cloneMouseEvent: z,
              cloneTouchEvent: S,
              getFakeMouseEvent: x,
              removeElement: P,
            } = O;
          class h {
            constructor(l, p, g, T) {
              (this.chart = l),
                (this.target = p),
                (this.groupType = g),
                (g = g === "ul"),
                (this.eventProvider = new d());
              const D = g ? B.createElement("li") : null,
                A = (this.buttonElement = B.createElement("button"));
              l.styledMode || this.hideButtonVisually(A),
                D
                  ? (g && !l.styledMode && (D.style.listStyle = "none"),
                    D.appendChild(A),
                    (this.element = D))
                  : (this.element = A),
                this.updateTarget(p, T);
            }
            click() {
              var l = this.getTargetPosition();
              (l.x += l.width / 2),
                (l.y += l.height / 2),
                (l = x("click", l)),
                E(this.target.click, l);
            }
            updateTarget(l, p) {
              (this.target = l), this.updateCSSClassName();
              const g = p || {};
              Object.keys(g).forEach((T) => {
                g[T] === null && delete g[T];
              }),
                G(
                  this.buttonElement,
                  L(
                    { "aria-label": this.getTargetAttr(l.click, "aria-label") },
                    g
                  )
                ),
                this.eventProvider.removeAddedEvents(),
                this.addProxyEventsToButton(this.buttonElement, l.click),
                this.refreshPosition();
            }
            refreshPosition() {
              const l = this.getTargetPosition();
              Y(this.buttonElement, {
                width: (l.width || 1) + "px",
                height: (l.height || 1) + "px",
                left: (Math.round(l.x) || 0) + "px",
                top: (Math.round(l.y) || 0) + "px",
              });
            }
            remove() {
              this.eventProvider.removeAddedEvents(), P(this.element);
            }
            updateCSSClassName() {
              var l = this.chart.legend;
              (l = l.group && l.group.div),
                (l =
                  -1 <
                  ((l && l.className) || "").indexOf("highcharts-no-tooltip"));
              const p =
                -1 <
                (this.getTargetAttr(this.target.click, "class") || "").indexOf(
                  "highcharts-no-tooltip"
                );
              this.buttonElement.className =
                l || p
                  ? "highcharts-a11y-proxy-button highcharts-no-tooltip"
                  : "highcharts-a11y-proxy-button";
            }
            addProxyEventsToButton(l, p) {
              "click touchstart touchend touchcancel touchmove mouseover mouseenter mouseleave mouseout"
                .split(" ")
                .forEach((g) => {
                  const T = g.indexOf("touch") === 0;
                  this.eventProvider.addEvent(
                    l,
                    g,
                    (D) => {
                      const A = T ? S(D) : z(D);
                      p && E(p, A),
                        D.stopPropagation(),
                        T || D.preventDefault();
                    },
                    { passive: !1 }
                  );
                });
            }
            hideButtonVisually(l) {
              Y(l, {
                borderWidth: 0,
                backgroundColor: "transparent",
                cursor: "pointer",
                outline: "none",
                opacity: 0.001,
                filter: "alpha(opacity=1)",
                zIndex: 999,
                overflow: "hidden",
                padding: 0,
                margin: 0,
                display: "block",
                position: "absolute",
                "-ms-filter":
                  "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
              });
            }
            getTargetPosition() {
              var l = this.target.click;
              if (
                ((l = l.element ? l.element : l),
                (l = this.target.visual || l),
                this.chart.renderTo && l && l.getBoundingClientRect)
              ) {
                l = l.getBoundingClientRect();
                const p = this.chart.pointer.getChartPosition();
                return {
                  x: (l.left - p.left) / p.scaleX,
                  y: (l.top - p.top) / p.scaleY,
                  width: l.right / p.scaleX - l.left / p.scaleX,
                  height: l.bottom / p.scaleY - l.top / p.scaleY,
                };
              }
              return { x: 0, y: 0, width: 1, height: 1 };
            }
            getTargetAttr(l, p) {
              return l.element ? l.element.getAttribute(p) : l.getAttribute(p);
            }
          }
          return h;
        }
      ),
      n(
        e,
        "Accessibility/ProxyProvider.js",
        [
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/DOMElementProvider.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Accessibility/ProxyElement.js"],
        ],
        function (i, a, d, M, O, B) {
          const { doc: G } = i,
            { attr: Y, css: L } = a,
            { unhideChartElementFromAT: E } = d,
            { removeElement: z, removeChildNodes: S } = O;
          class x {
            constructor(h) {
              (this.chart = h),
                (this.domElementProvider = new M()),
                (this.groups = {}),
                (this.groupOrder = []),
                (this.beforeChartProxyPosContainer =
                  this.createProxyPosContainer("before")),
                (this.afterChartProxyPosContainer =
                  this.createProxyPosContainer("after")),
                this.update();
            }
            addProxyElement(h, s, l) {
              const p = this.groups[h];
              if (!p)
                throw Error(
                  "ProxyProvider.addProxyElement: Invalid group key " + h
                );
              return (
                (h = new B(this.chart, s, p.type, l)),
                p.proxyContainerElement.appendChild(h.element),
                p.proxyElements.push(h),
                h
              );
            }
            addGroup(h, s, l) {
              var p = this.groups[h];
              if (p) return p.groupElement;
              p = this.domElementProvider.createElement(s);
              let g;
              return (
                l && l.role && s !== "div"
                  ? ((g = this.domElementProvider.createElement("div")),
                    g.appendChild(p))
                  : (g = p),
                (g.className =
                  "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" +
                  h.replace(/\W/g, "-")),
                (this.groups[h] = {
                  proxyContainerElement: p,
                  groupElement: g,
                  type: s,
                  proxyElements: [],
                }),
                Y(g, l || {}),
                s === "ul" && p.setAttribute("role", "list"),
                this.afterChartProxyPosContainer.appendChild(g),
                this.updateGroupOrder(this.groupOrder),
                g
              );
            }
            updateGroupAttrs(h, s) {
              const l = this.groups[h];
              if (!l)
                throw Error(
                  "ProxyProvider.updateGroupAttrs: Invalid group key " + h
                );
              Y(l.groupElement, s);
            }
            updateGroupOrder(h) {
              if (
                ((this.groupOrder = h.slice()), !this.isDOMOrderGroupOrder())
              ) {
                var s = h.indexOf("series"),
                  l = -1 < s ? h.slice(0, s) : h,
                  p = -1 < s ? h.slice(s + 1) : [];
                (h = G.activeElement),
                  ["before", "after"].forEach((g) => {
                    const T =
                      this[
                        g === "before"
                          ? "beforeChartProxyPosContainer"
                          : "afterChartProxyPosContainer"
                      ];
                    (g = g === "before" ? l : p),
                      S(T),
                      g.forEach((D) => {
                        (D = this.groups[D]) && T.appendChild(D.groupElement);
                      });
                  }),
                  (this.beforeChartProxyPosContainer.contains(h) ||
                    this.afterChartProxyPosContainer.contains(h)) &&
                    h &&
                    h.focus &&
                    h.focus();
              }
            }
            clearGroup(h) {
              const s = this.groups[h];
              if (!s)
                throw Error("ProxyProvider.clearGroup: Invalid group key " + h);
              S(s.proxyContainerElement);
            }
            removeGroup(h) {
              const s = this.groups[h];
              s && (z(s.groupElement), delete this.groups[h]);
            }
            update() {
              this.updatePosContainerPositions(),
                this.updateGroupOrder(this.groupOrder),
                this.updateProxyElementPositions();
            }
            updateProxyElementPositions() {
              Object.keys(this.groups).forEach(
                this.updateGroupProxyElementPositions.bind(this)
              );
            }
            updateGroupProxyElementPositions(h) {
              (h = this.groups[h]) &&
                h.proxyElements.forEach((s) => s.refreshPosition());
            }
            destroy() {
              this.domElementProvider.destroyCreatedElements();
            }
            createProxyPosContainer(h) {
              const s = this.domElementProvider.createElement("div");
              return (
                s.setAttribute("aria-hidden", "false"),
                (s.className =
                  "highcharts-a11y-proxy-container" + (h ? "-" + h : "")),
                L(s, { top: "0", left: "0" }),
                this.chart.styledMode ||
                  ((s.style.whiteSpace = "nowrap"),
                  (s.style.position = "absolute")),
                s
              );
            }
            getCurrentGroupOrderInDOM() {
              const h = (p) => {
                const g = Object.keys(this.groups);
                let T = g.length;
                for (; T--; ) {
                  const D = g[T],
                    A = this.groups[D];
                  if (A && p === A.groupElement) return D;
                }
              };
              var s = (p) => {
                const g = [];
                p = p.children;
                for (let T = 0; T < p.length; ++T) {
                  const D = h(p[T]);
                  D && g.push(D);
                }
                return g;
              };
              const l = s(this.beforeChartProxyPosContainer);
              return (
                (s = s(this.afterChartProxyPosContainer)),
                l.push("series"),
                l.concat(s)
              );
            }
            isDOMOrderGroupOrder() {
              const h = this.getCurrentGroupOrderInDOM(),
                s = this.groupOrder.filter(
                  (p) => p === "series" || !!this.groups[p]
                );
              let l = h.length;
              if (l !== s.length) return !1;
              for (; l--; ) if (h[l] !== s[l]) return !1;
              return !0;
            }
            updatePosContainerPositions() {
              const h = this.chart;
              if (!h.renderer.forExport) {
                var s = h.renderer.box;
                h.container.insertBefore(
                  this.afterChartProxyPosContainer,
                  s.nextSibling
                ),
                  h.container.insertBefore(
                    this.beforeChartProxyPosContainer,
                    s
                  ),
                  E(this.chart, this.afterChartProxyPosContainer),
                  E(this.chart, this.beforeChartProxyPosContainer);
              }
            }
          }
          return x;
        }
      ),
      n(e, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function () {
        return {
          lang: {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "",
          },
          rangeSelector: {
            allButtonsEnabled: !1,
            buttons: void 0,
            buttonSpacing: 5,
            dropdown: "responsive",
            enabled: void 0,
            verticalAlign: "top",
            buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 },
            floating: !1,
            x: 0,
            y: 0,
            height: void 0,
            inputBoxBorderColor: "none",
            inputBoxHeight: 17,
            inputBoxWidth: void 0,
            inputDateFormat: "%e %b %Y",
            inputDateParser: void 0,
            inputEditDateFormat: "%Y-%m-%d",
            inputEnabled: !0,
            inputPosition: { align: "right", x: 0, y: 0 },
            inputSpacing: 5,
            selected: void 0,
            buttonPosition: { align: "left", x: 0, y: 0 },
            inputStyle: {
              color: "#334eff",
              cursor: "pointer",
              fontSize: "0.8em",
            },
            labelStyle: { color: "#666666", fontSize: "0.8em" },
          },
        };
      }),
      n(
        e,
        "Stock/RangeSelector/RangeSelectorComposition.js",
        [
          e["Core/Defaults.js"],
          e["Stock/RangeSelector/RangeSelectorDefaults.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d) {
          function M() {
            const f = this.range,
              b = f.type,
              y = this.max,
              C = this.chart.time,
              o = function (v, N) {
                const w = b === "year" ? "FullYear" : "Month",
                  R = new C.Date(v),
                  X = C.get(w, R);
                return (
                  C.set(w, R, X + N),
                  X === C.get(w, R) && C.set("Date", R, 0),
                  R.getTime() - v
                );
              };
            let r, c;
            p(f)
              ? ((r = y - f), (c = f))
              : f &&
                ((r = y + o(y, -(f.count || 1))),
                this.chart && (this.chart.fixedRange = y - r));
            const u = T(this.dataMin, Number.MIN_VALUE);
            return (
              p(r) || (r = u),
              r <= u &&
                ((r = u),
                typeof c > "u" && (c = o(r, f.count)),
                (this.newMax = Math.min(
                  r + c,
                  T(this.dataMax, Number.MAX_VALUE)
                ))),
              p(y)
                ? !p(f) && f && f._offsetMin && (r += f._offsetMin)
                : (r = void 0),
              r
            );
          }
          function O() {
            this.options.rangeSelector &&
              this.options.rangeSelector.enabled &&
              (this.rangeSelector = new m(this));
          }
          function B() {
            var f = this.axes;
            const b = this.rangeSelector;
            b &&
              (p(b.deferredYTDClick) &&
                (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick),
              f.forEach((y) => {
                y.updateNames(), y.setScale();
              }),
              this.getAxisMargins(),
              b.render(),
              (f = b.options.verticalAlign),
              b.options.floating ||
                (f === "bottom"
                  ? (this.extraBottomMargin = !0)
                  : f !== "middle" && (this.extraTopMargin = !0)));
          }
          function G(f) {
            let b, y, C, o;
            const r = f.rangeSelector,
              c = () => {
                r &&
                  ((b = f.xAxis[0].getExtremes()),
                  (y = f.legend),
                  (o = r && r.options.verticalAlign),
                  p(b.min) && r.render(b.min, b.max),
                  y.display &&
                    o === "top" &&
                    o === y.options.verticalAlign &&
                    ((C = g(f.spacingBox)),
                    (C.y =
                      y.options.layout === "vertical"
                        ? f.plotTop
                        : C.y + r.getHeight()),
                    (y.group.placed = !1),
                    y.align(C)));
              };
            r &&
              (l(D, (u) => u[0] === f) ||
                D.push([
                  f,
                  [
                    P(f.xAxis[0], "afterSetExtremes", function (u) {
                      r && r.render(u.min, u.max);
                    }),
                    P(f, "redraw", c),
                  ],
                ]),
              c());
          }
          function Y() {
            for (let f = 0, b = D.length; f < b; ++f) {
              const y = D[f];
              if (y[0] === this) {
                y[1].forEach((C) => C()), D.splice(f, 1);
                break;
              }
            }
          }
          function L() {
            var f = this.rangeSelector;
            f &&
              ((f = f.getHeight()),
              this.extraTopMargin && (this.plotTop += f),
              this.extraBottomMargin && (this.marginBottom += f));
          }
          function E() {
            var f = this.rangeSelector;
            f &&
              !f.options.floating &&
              (f.render(),
              (f = f.options.verticalAlign),
              f === "bottom"
                ? (this.extraBottomMargin = !0)
                : f !== "middle" && (this.extraTopMargin = !0));
          }
          function z(f) {
            var b = f.options.rangeSelector;
            f = this.extraBottomMargin;
            const y = this.extraTopMargin;
            let C = this.rangeSelector;
            b &&
              b.enabled &&
              !h(C) &&
              this.options.rangeSelector &&
              ((this.options.rangeSelector.enabled = !0),
              (this.rangeSelector = C = new m(this))),
              (this.extraTopMargin = this.extraBottomMargin = !1),
              C &&
                (G(this),
                (b =
                  (b && b.verticalAlign) ||
                  (C.options && C.options.verticalAlign)),
                C.options.floating ||
                  (b === "bottom"
                    ? (this.extraBottomMargin = !0)
                    : b !== "middle" && (this.extraTopMargin = !0)),
                this.extraBottomMargin !== f || this.extraTopMargin !== y) &&
                (this.isDirtyBox = !0);
          }
          const { defaultOptions: S, setOptions: x } = i,
            {
              addEvent: P,
              defined: h,
              extend: s,
              find: l,
              isNumber: p,
              merge: g,
              pick: T,
            } = d,
            D = [],
            A = [];
          let m;
          return {
            compose: function (f, b, y) {
              (m = y),
                d.pushUnique(A, f) && (f.prototype.minFromRange = M),
                d.pushUnique(A, b) &&
                  (P(b, "afterGetContainer", O),
                  P(b, "beforeRender", B),
                  P(b, "destroy", Y),
                  P(b, "getMargins", L),
                  P(b, "render", E),
                  P(b, "update", z),
                  b.prototype.callbacks.push(G)),
                d.pushUnique(A, x) &&
                  (s(S, { rangeSelector: a.rangeSelector }), s(S.lang, a.lang));
            },
          };
        }
      ),
      n(
        e,
        "Stock/RangeSelector/RangeSelector.js",
        [
          e["Core/Axis/Axis.js"],
          e["Core/Defaults.js"],
          e["Core/Globals.js"],
          e["Stock/RangeSelector/RangeSelectorComposition.js"],
          e["Core/Renderer/SVG/SVGElement.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B) {
          function G(b) {
            if (b.indexOf("%L") !== -1) return "text";
            const y = "aAdewbBmoyY"
                .split("")
                .some((o) => b.indexOf("%" + o) !== -1),
              C = "HkIlMS".split("").some((o) => b.indexOf("%" + o) !== -1);
            return y && C ? "datetime-local" : y ? "date" : C ? "time" : "text";
          }
          const { defaultOptions: Y } = a,
            {
              addEvent: L,
              createElement: E,
              css: z,
              defined: S,
              destroyObjectProperties: x,
              discardElement: P,
              extend: h,
              fireEvent: s,
              isNumber: l,
              merge: p,
              objectEach: g,
              pad: T,
              pick: D,
              pInt: A,
              splat: m,
            } = B;
          class f {
            static compose(y, C) {
              M.compose(y, C, f);
            }
            constructor(y) {
              (this.buttons = void 0),
                (this.buttonOptions = f.prototype.defaultButtons),
                (this.initialButtonGroupWidth = 0),
                (this.options = void 0),
                (this.chart = y),
                this.init(y);
            }
            clickButton(y, C) {
              const o = this.chart,
                r = this.buttonOptions[y],
                c = o.xAxis[0];
              var u = (o.scroller && o.scroller.getUnionExtremes()) || c || {},
                v = r.type;
              const N = r.dataGrouping;
              let w = u.dataMin,
                R = u.dataMax,
                X,
                J = c && Math.round(Math.min(c.max, D(R, c.max))),
                K;
              u = r._range;
              let H,
                k,
                U,
                _ = !0;
              if (w !== null && R !== null) {
                if (
                  ((o.fixedRange = u),
                  this.setSelected(y),
                  N &&
                    ((this.forcedDataGrouping = !0),
                    i.prototype.setDataGrouping.call(
                      c || { chart: this.chart },
                      N,
                      !1
                    ),
                    (this.frozenStates = r.preserveDataGrouping)),
                  v === "month" || v === "year")
                )
                  c
                    ? ((v = {
                        range: r,
                        max: J,
                        chart: o,
                        dataMin: w,
                        dataMax: R,
                      }),
                      (X = c.minFromRange.call(v)),
                      l(v.newMax) && (J = v.newMax),
                      (_ = !1))
                    : (u = r);
                else if (u)
                  (X = Math.max(J - u, w)), (J = Math.min(X + u, R)), (_ = !1);
                else if (v === "ytd")
                  if (c)
                    (typeof R > "u" || typeof w > "u") &&
                      ((w = Number.MAX_VALUE),
                      (R = Number.MIN_VALUE),
                      o.series.forEach((W) => {
                        (W = W.xData) &&
                          ((w = Math.min(W[0], w)),
                          (R = Math.max(W[W.length - 1], R)));
                      }),
                      (C = !1)),
                      (v = this.getYTDExtremes(R, w, o.time.useUTC)),
                      (X = H = v.min),
                      (J = v.max);
                  else {
                    this.deferredYTDClick = y;
                    return;
                  }
                else
                  v === "all" &&
                    c &&
                    (o.navigator &&
                      o.navigator.baseSeries[0] &&
                      (o.navigator.baseSeries[0].xAxis.options.range = void 0),
                    (X = w),
                    (J = R));
                _ && r._offsetMin && S(X) && (X += r._offsetMin),
                  r._offsetMax && S(J) && (J += r._offsetMax),
                  this.dropdown && (this.dropdown.selectedIndex = y + 1),
                  c
                    ? c.setExtremes(X, J, D(C, !0), void 0, {
                        trigger: "rangeSelectorButton",
                        rangeSelectorButton: r,
                      })
                    : ((K = m(o.options.xAxis)[0]),
                      (U = K.range),
                      (K.range = u),
                      (k = K.min),
                      (K.min = H),
                      L(o, "load", function () {
                        (K.range = U), (K.min = k);
                      })),
                  s(this, "afterBtnClick");
              }
            }
            setSelected(y) {
              this.selected = this.options.selected = y;
            }
            init(y) {
              const C = this,
                o = y.options.rangeSelector,
                r = o.buttons || C.defaultButtons.slice(),
                c = o.selected,
                u = function () {
                  const v = C.minInput,
                    N = C.maxInput;
                  v && v.blur && s(v, "blur"), N && N.blur && s(N, "blur");
                };
              (C.chart = y),
                (C.options = o),
                (C.buttons = []),
                (C.buttonOptions = r),
                (this.eventsToUnbind = []),
                this.eventsToUnbind.push(L(y.container, "mousedown", u)),
                this.eventsToUnbind.push(L(y, "resize", u)),
                r.forEach(C.computeButtonRange),
                typeof c < "u" && r[c] && this.clickButton(c, !1),
                this.eventsToUnbind.push(
                  L(y, "load", function () {
                    y.xAxis &&
                      y.xAxis[0] &&
                      L(y.xAxis[0], "setExtremes", function (v) {
                        this.max - this.min !== y.fixedRange &&
                          v.trigger !== "rangeSelectorButton" &&
                          v.trigger !== "updatedData" &&
                          C.forcedDataGrouping &&
                          !C.frozenStates &&
                          this.setDataGrouping(!1, !1);
                      });
                  })
                );
            }
            updateButtonStates() {
              const y = this;
              var C = this.chart;
              const o = this.dropdown,
                r = C.xAxis[0],
                c = Math.round(r.max - r.min),
                u = !r.hasVisibleSeries,
                v = (C.scroller && C.scroller.getUnionExtremes()) || r,
                N = v.dataMin,
                w = v.dataMax;
              C = y.getYTDExtremes(w, N, C.time.useUTC);
              const R = C.min,
                X = C.max,
                J = y.selected,
                K = y.options.allButtonsEnabled,
                H = y.buttons;
              let k = l(J);
              y.buttonOptions.forEach((U, _) => {
                var W = U._range,
                  tt = U.type,
                  j = U.count || 1;
                const I = H[_],
                  F = U._offsetMax - U._offsetMin,
                  V = _ === J,
                  Q = W > w - N,
                  $ = W < r.minRange;
                U = 0;
                let et = !1,
                  st = !1;
                (W = W === c),
                  (tt === "month" || tt === "year") &&
                  c + 36e5 >= 864e5 * { month: 28, year: 365 }[tt] * j - F &&
                  c - 36e5 <= 864e5 * { month: 31, year: 366 }[tt] * j + F
                    ? (W = !0)
                    : tt === "ytd"
                    ? ((W = X - R + F === c), (et = !V))
                    : tt === "all" &&
                      ((W = r.max - r.min >= w - N), (st = !V && k && W)),
                  (tt = !K && (Q || $ || st || u)),
                  (j = (V && W) || (W && !k && !et) || (V && y.frozenStates)),
                  tt ? (U = 3) : j && ((k = !0), (U = 2)),
                  I.state !== U &&
                    (I.setState(U),
                    o &&
                      ((o.options[_ + 1].disabled = tt),
                      U === 2 && (o.selectedIndex = _ + 1)),
                    U === 0 && J === _ && y.setSelected());
              });
            }
            computeButtonRange(y) {
              const C = y.type,
                o = y.count || 1,
                r = {
                  millisecond: 1,
                  second: 1e3,
                  minute: 6e4,
                  hour: 36e5,
                  day: 864e5,
                  week: 6048e5,
                };
              r[C]
                ? (y._range = r[C] * o)
                : (C === "month" || C === "year") &&
                  (y._range = 864e5 * { month: 30, year: 365 }[C] * o),
                (y._offsetMin = D(y.offsetMin, 0)),
                (y._offsetMax = D(y.offsetMax, 0)),
                (y._range += y._offsetMax - y._offsetMin);
            }
            getInputValue(y) {
              y = y === "min" ? this.minInput : this.maxInput;
              const C = this.chart.options.rangeSelector,
                o = this.chart.time;
              return y
                ? (
                    (y.type === "text" && C.inputDateParser) ||
                    this.defaultInputDateParser
                  )(y.value, o.useUTC, o)
                : 0;
            }
            setInputValue(y, C) {
              const o = this.options,
                r = this.chart.time,
                c = y === "min" ? this.minInput : this.maxInput;
              if (((y = y === "min" ? this.minDateBox : this.maxDateBox), c)) {
                var u = c.getAttribute("data-hc-time");
                (u = S(u) ? Number(u) : void 0),
                  S(C) &&
                    (S(u) && c.setAttribute("data-hc-time-previous", u),
                    c.setAttribute("data-hc-time", C),
                    (u = C)),
                  (c.value = r.dateFormat(
                    this.inputTypeFormats[c.type] || o.inputEditDateFormat,
                    u
                  )),
                  y && y.attr({ text: r.dateFormat(o.inputDateFormat, u) });
              }
            }
            setInputExtremes(y, C, o) {
              if ((y = y === "min" ? this.minInput : this.maxInput)) {
                const r = this.inputTypeFormats[y.type],
                  c = this.chart.time;
                r &&
                  ((C = c.dateFormat(r, C)),
                  y.min !== C && (y.min = C),
                  (o = c.dateFormat(r, o)),
                  y.max !== o && (y.max = o));
              }
            }
            showInput(y) {
              const C = y === "min" ? this.minDateBox : this.maxDateBox;
              if (
                (y = y === "min" ? this.minInput : this.maxInput) &&
                C &&
                this.inputGroup
              ) {
                const o = y.type === "text",
                  { translateX: r, translateY: c } = this.inputGroup,
                  { inputBoxWidth: u } = this.options;
                z(y, {
                  width: o ? C.width + (u ? -2 : 20) + "px" : "auto",
                  height: C.height - 2 + "px",
                  border: "2px solid silver",
                }),
                  o && u
                    ? z(y, { left: r + C.x + "px", top: c + "px" })
                    : z(y, {
                        left:
                          Math.min(
                            Math.round(C.x + r - (y.offsetWidth - C.width) / 2),
                            this.chart.chartWidth - y.offsetWidth
                          ) + "px",
                        top: c - (y.offsetHeight - C.height) / 2 + "px",
                      });
              }
            }
            hideInput(y) {
              (y = y === "min" ? this.minInput : this.maxInput) &&
                z(y, {
                  top: "-9999em",
                  border: 0,
                  width: "1px",
                  height: "1px",
                });
            }
            defaultInputDateParser(y, C, o) {
              var r = y.split("/").join("-").split(" ").join("T");
              if ((r.indexOf("T") === -1 && (r += "T00:00"), C)) r += "Z";
              else {
                var c;
                (c = d.isSafari) &&
                  ((c = r),
                  (c = !(
                    6 < c.length &&
                    (c.lastIndexOf("-") === c.length - 6 ||
                      c.lastIndexOf("+") === c.length - 6)
                  ))),
                  c &&
                    ((c = new Date(r).getTimezoneOffset() / 60),
                    (r += 0 >= c ? `+${T(-c)}:00` : `-${T(c)}:00`));
              }
              return (
                (r = Date.parse(r)),
                l(r) ||
                  ((y = y.split("-")),
                  (r = Date.UTC(A(y[0]), A(y[1]) - 1, A(y[2])))),
                o && C && l(r) && (r += o.getTimezoneOffset(r)),
                r
              );
            }
            drawInput(y) {
              function C() {
                const { maxInput: H, minInput: k } = u,
                  U = o.xAxis[0];
                var _ = o.scroller && o.scroller.xAxis ? o.scroller.xAxis : U;
                const W = _.dataMin;
                _ = _.dataMax;
                let tt = u.getInputValue(y);
                tt !== Number(J.getAttribute("data-hc-time-previous")) &&
                  l(tt) &&
                  (J.setAttribute("data-hc-time-previous", tt),
                  R && H && l(W)
                    ? tt > Number(H.getAttribute("data-hc-time"))
                      ? (tt = void 0)
                      : tt < W && (tt = W)
                    : k &&
                      l(_) &&
                      (tt < Number(k.getAttribute("data-hc-time"))
                        ? (tt = void 0)
                        : tt > _ && (tt = _)),
                  typeof tt < "u" &&
                    U.setExtremes(
                      R ? tt : U.min,
                      R ? U.max : tt,
                      void 0,
                      void 0,
                      { trigger: "rangeSelectorInput" }
                    ));
              }
              const { chart: o, div: r, inputGroup: c } = this,
                u = this,
                v = o.renderer.style || {};
              var N = o.renderer;
              const w = o.options.rangeSelector,
                R = y === "min";
              var X = Y.lang[R ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              (X = N.label(X, 0)
                .addClass("highcharts-range-label")
                .attr({ padding: X ? 2 : 0, height: X ? w.inputBoxHeight : 0 })
                .add(c)),
                (N = N.label("", 0)
                  .addClass("highcharts-range-input")
                  .attr({
                    padding: 2,
                    width: w.inputBoxWidth,
                    height: w.inputBoxHeight,
                    "text-align": "center",
                  })
                  .on("click", function () {
                    u.showInput(y), u[y + "Input"].focus();
                  })),
                o.styledMode ||
                  N.attr({ stroke: w.inputBoxBorderColor, "stroke-width": 1 }),
                N.add(c);
              const J = E(
                "input",
                { name: y, className: "highcharts-range-selector" },
                void 0,
                r
              );
              J.setAttribute("type", G(w.inputDateFormat || "%e %b %Y")),
                o.styledMode ||
                  (X.css(p(v, w.labelStyle)),
                  N.css(p({ color: "#333333" }, v, w.inputStyle)),
                  z(
                    J,
                    h(
                      {
                        position: "absolute",
                        border: 0,
                        boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                        width: "1px",
                        height: "1px",
                        padding: 0,
                        textAlign: "center",
                        fontSize: v.fontSize,
                        fontFamily: v.fontFamily,
                        top: "-9999em",
                      },
                      w.inputStyle
                    )
                  )),
                (J.onfocus = () => {
                  u.showInput(y);
                }),
                (J.onblur = () => {
                  J === d.doc.activeElement && C(),
                    u.hideInput(y),
                    u.setInputValue(y),
                    J.blur();
                });
              let K = !1;
              return (
                (J.onchange = () => {
                  K || (C(), u.hideInput(y), J.blur());
                }),
                (J.onkeypress = (H) => {
                  H.keyCode === 13 && C();
                }),
                (J.onkeydown = (H) => {
                  (K = !0), (H.keyCode !== 38 && H.keyCode !== 40) || C();
                }),
                (J.onkeyup = () => {
                  K = !1;
                }),
                { dateBox: N, input: J, label: X }
              );
            }
            getPosition() {
              var y = this.chart;
              const C = y.options.rangeSelector;
              return (
                (y =
                  C.verticalAlign === "top" ? y.plotTop - y.axisOffset[0] : 0),
                {
                  buttonTop: y + C.buttonPosition.y,
                  inputTop: y + C.inputPosition.y - 10,
                }
              );
            }
            getYTDExtremes(y, C, o) {
              const r = this.chart.time;
              var c = new r.Date(y);
              const u = r.get("FullYear", c);
              return (
                (o = o ? r.Date.UTC(u, 0, 1) : +new r.Date(u, 0, 1)),
                (C = Math.max(C, o)),
                (c = c.getTime()),
                { max: Math.min(y || c, c), min: C }
              );
            }
            render(y, C) {
              var o = this.chart,
                r = o.renderer;
              const c = o.container;
              var u = o.options;
              const v = u.rangeSelector,
                N = D(u.chart.style && u.chart.style.zIndex, 0) + 1;
              if (((u = v.inputEnabled), v.enabled !== !1)) {
                if (
                  (this.rendered ||
                    ((this.group = r
                      .g("range-selector-group")
                      .attr({ zIndex: 7 })
                      .add()),
                    (this.div = E("div", void 0, {
                      position: "relative",
                      height: 0,
                      zIndex: N,
                    })),
                    this.buttonOptions.length && this.renderButtons(),
                    c.parentNode && c.parentNode.insertBefore(this.div, c),
                    u &&
                      ((this.inputGroup = r.g("input-group").add(this.group)),
                      (r = this.drawInput("min")),
                      (this.minDateBox = r.dateBox),
                      (this.minLabel = r.label),
                      (this.minInput = r.input),
                      (r = this.drawInput("max")),
                      (this.maxDateBox = r.dateBox),
                      (this.maxLabel = r.label),
                      (this.maxInput = r.input))),
                  u &&
                    (this.setInputValue("min", y),
                    this.setInputValue("max", C),
                    (y =
                      (o.scroller && o.scroller.getUnionExtremes()) ||
                      o.xAxis[0] ||
                      {}),
                    S(y.dataMin) &&
                      S(y.dataMax) &&
                      ((o = o.xAxis[0].minRange || 0),
                      this.setInputExtremes(
                        "min",
                        y.dataMin,
                        Math.min(y.dataMax, this.getInputValue("max")) - o
                      ),
                      this.setInputExtremes(
                        "max",
                        Math.max(y.dataMin, this.getInputValue("min")) + o,
                        y.dataMax
                      )),
                    this.inputGroup))
                ) {
                  let w = 0;
                  [
                    this.minLabel,
                    this.minDateBox,
                    this.maxLabel,
                    this.maxDateBox,
                  ].forEach((R) => {
                    if (R) {
                      const { width: X } = R.getBBox();
                      X && (R.attr({ x: w }), (w += X + v.inputSpacing));
                    }
                  });
                }
                this.alignElements(), (this.rendered = !0);
              }
            }
            renderButtons() {
              const { buttons: y, chart: C, options: o } = this,
                r = Y.lang,
                c = C.renderer,
                u = p(o.buttonTheme),
                v = u && u.states,
                N = u.width || 28;
              delete u.width,
                delete u.states,
                (this.buttonGroup = c
                  .g("range-selector-buttons")
                  .add(this.group));
              const w = (this.dropdown = E(
                "select",
                void 0,
                {
                  position: "absolute",
                  width: "1px",
                  height: "1px",
                  padding: 0,
                  border: 0,
                  top: "-9999em",
                  cursor: "pointer",
                  opacity: 1e-4,
                },
                this.div
              ));
              L(w, "touchstart", () => {
                w.style.fontSize = "16px";
              }),
                [
                  [d.isMS ? "mouseover" : "mouseenter"],
                  [d.isMS ? "mouseout" : "mouseleave"],
                  ["change", "click"],
                ].forEach(([R, X]) => {
                  L(w, R, () => {
                    const J = y[this.currentButtonIndex()];
                    J && s(J.element, X || R);
                  });
                }),
                (this.zoomText = c
                  .label((r && r.rangeSelectorZoom) || "", 0)
                  .attr({
                    padding: o.buttonTheme.padding,
                    height: o.buttonTheme.height,
                    paddingLeft: 0,
                    paddingRight: 0,
                  })
                  .add(this.buttonGroup)),
                this.chart.styledMode ||
                  (this.zoomText.css(o.labelStyle),
                  (u["stroke-width"] = D(u["stroke-width"], 0))),
                E(
                  "option",
                  { textContent: this.zoomText.textStr, disabled: !0 },
                  void 0,
                  w
                ),
                this.buttonOptions.forEach((R, X) => {
                  E("option", { textContent: R.title || R.text }, void 0, w),
                    (y[X] = c
                      .button(
                        R.text,
                        0,
                        0,
                        (J) => {
                          const K = R.events && R.events.click;
                          let H;
                          K && (H = K.call(R, J)),
                            H !== !1 && this.clickButton(X),
                            (this.isActive = !0);
                        },
                        u,
                        v && v.hover,
                        v && v.select,
                        v && v.disabled
                      )
                      .attr({ "text-align": "center", width: N })
                      .add(this.buttonGroup)),
                    R.title && y[X].attr("title", R.title);
                });
            }
            alignElements() {
              const {
                buttonGroup: y,
                buttons: C,
                chart: o,
                group: r,
                inputGroup: c,
                options: u,
                zoomText: v,
              } = this;
              var N = o.options;
              const w =
                  N.exporting &&
                  N.exporting.enabled !== !1 &&
                  N.navigation &&
                  N.navigation.buttonOptions,
                { buttonPosition: R, inputPosition: X, verticalAlign: J } = u;
              N = (U, _) =>
                w &&
                this.titleCollision(o) &&
                J === "top" &&
                _.align === "right" &&
                _.y - U.getBBox().height - 12 <
                  (w.y || 0) + (w.height || 0) + o.spacing[0]
                  ? -40
                  : 0;
              var K = o.plotLeft;
              if (r && R && X) {
                var H = R.x - o.spacing[3];
                if (y) {
                  if ((this.positionButtons(), !this.initialButtonGroupWidth)) {
                    let tt = 0;
                    v && (tt += v.getBBox().width + 5),
                      C.forEach((j, I) => {
                        (tt += j.width),
                          I !== C.length - 1 && (tt += u.buttonSpacing);
                      }),
                      (this.initialButtonGroupWidth = tt);
                  }
                  (K -= o.spacing[3]), this.updateButtonStates();
                  var k = N(y, R);
                  this.alignButtonGroup(k), (r.placed = y.placed = o.hasLoaded);
                }
                (k = 0),
                  c &&
                    ((k = N(c, X)),
                    X.align === "left"
                      ? (H = K)
                      : X.align === "right" &&
                        (H = -Math.max(o.axisOffset[1], -k)),
                    c.align(
                      {
                        y: X.y,
                        width: c.getBBox().width,
                        align: X.align,
                        x: X.x + H - 2,
                      },
                      !0,
                      o.spacingBox
                    ),
                    (c.placed = o.hasLoaded)),
                  this.handleCollision(k),
                  r.align({ verticalAlign: J }, !0, o.spacingBox),
                  (N = r.alignAttr.translateY),
                  (K = r.getBBox().height + 20),
                  (H = 0),
                  J === "bottom" &&
                    ((H =
                      (H = o.legend && o.legend.options) &&
                      H.verticalAlign === "bottom" &&
                      H.enabled &&
                      !H.floating
                        ? o.legend.legendHeight + D(H.margin, 10)
                        : 0),
                    (K = K + H - 20),
                    (H =
                      N -
                      K -
                      (u.floating ? 0 : u.y) -
                      (o.titleOffset ? o.titleOffset[2] : 0) -
                      10)),
                  J === "top"
                    ? (u.floating && (H = 0),
                      o.titleOffset &&
                        o.titleOffset[0] &&
                        (H = o.titleOffset[0]),
                      (H += o.margin[0] - o.spacing[0] || 0))
                    : J === "middle" &&
                      (X.y === R.y
                        ? (H = N)
                        : (X.y || R.y) &&
                          (H =
                            0 > X.y || 0 > R.y
                              ? H - Math.min(X.y, R.y)
                              : N - K)),
                  r.translate(u.x, u.y + Math.floor(H));
                const { minInput: U, maxInput: _, dropdown: W } = this;
                u.inputEnabled &&
                  U &&
                  _ &&
                  ((U.style.marginTop = r.translateY + "px"),
                  (_.style.marginTop = r.translateY + "px")),
                  W && (W.style.marginTop = r.translateY + "px");
              }
            }
            alignButtonGroup(y, C) {
              const { chart: o, options: r, buttonGroup: c } = this,
                { buttonPosition: u } = r,
                v = o.plotLeft - o.spacing[3];
              let N = u.x - o.spacing[3];
              u.align === "right"
                ? (N += y - v)
                : u.align === "center" && (N -= v / 2),
                c &&
                  c.align(
                    {
                      y: u.y,
                      width: D(C, this.initialButtonGroupWidth),
                      align: u.align,
                      x: N,
                    },
                    !0,
                    o.spacingBox
                  );
            }
            positionButtons() {
              const { buttons: y, chart: C, options: o, zoomText: r } = this,
                c = C.hasLoaded ? "animate" : "attr",
                { buttonPosition: u } = o,
                v = C.plotLeft;
              let N = v;
              r &&
                r.visibility !== "hidden" &&
                (r[c]({ x: D(v + u.x, v) }),
                (N += u.x + r.getBBox().width + 5));
              for (let w = 0, R = this.buttonOptions.length; w < R; ++w)
                y[w].visibility !== "hidden"
                  ? (y[w][c]({ x: N }), (N += y[w].width + o.buttonSpacing))
                  : y[w][c]({ x: v });
            }
            handleCollision(y) {
              const { chart: C, buttonGroup: o, inputGroup: r } = this,
                {
                  buttonPosition: c,
                  dropdown: u,
                  inputPosition: v,
                } = this.options,
                N = () => {
                  let X = 0;
                  return (
                    this.buttons.forEach((J) => {
                      (J = J.getBBox()), J.width > X && (X = J.width);
                    }),
                    X
                  );
                },
                w = (X) => {
                  if (r && o) {
                    const J =
                        r.alignAttr.translateX +
                        r.alignOptions.x -
                        y +
                        r.getBBox().x +
                        2,
                      K = r.alignOptions.width,
                      H = o.alignAttr.translateX + o.getBBox().x;
                    return (
                      H + X > J && J + K > H && c.y < v.y + r.getBBox().height
                    );
                  }
                  return !1;
                },
                R = () => {
                  r &&
                    o &&
                    r.attr({
                      translateX:
                        r.alignAttr.translateX +
                        (C.axisOffset[1] >= -y ? 0 : -y),
                      translateY:
                        r.alignAttr.translateY + o.getBBox().height + 10,
                    });
                };
              if (o) {
                if (u === "always") {
                  this.collapseButtons(y), w(N()) && R();
                  return;
                }
                u === "never" && this.expandButtons();
              }
              r && o
                ? v.align === c.align || w(this.initialButtonGroupWidth + 20)
                  ? u === "responsive"
                    ? (this.collapseButtons(y), w(N()) && R())
                    : R()
                  : u === "responsive" && this.expandButtons()
                : o &&
                  u === "responsive" &&
                  (this.initialButtonGroupWidth > C.plotWidth
                    ? this.collapseButtons(y)
                    : this.expandButtons());
            }
            collapseButtons(y) {
              const {
                  buttons: C,
                  buttonOptions: o,
                  chart: r,
                  dropdown: c,
                  options: u,
                  zoomText: v,
                } = this,
                N =
                  (r.userOptions.rangeSelector &&
                    r.userOptions.rangeSelector.buttonTheme) ||
                  {},
                w = (J) => ({
                  text: J ? `${J} ` : "",
                  width: "auto",
                  paddingLeft: D(u.buttonTheme.paddingLeft, N.padding, 8),
                  paddingRight: D(u.buttonTheme.paddingRight, N.padding, 8),
                });
              v && v.hide();
              let R = !1;
              o.forEach((J, K) => {
                (K = C[K]),
                  K.state !== 2
                    ? K.hide()
                    : (K.show(), K.attr(w(J.text)), (R = !0));
              }),
                R ||
                  (c && (c.selectedIndex = 0),
                  C[0].show(),
                  C[0].attr(w(this.zoomText && this.zoomText.textStr)));
              const { align: X } = u.buttonPosition;
              this.positionButtons(),
                (X !== "right" && X !== "center") ||
                  this.alignButtonGroup(
                    y,
                    C[this.currentButtonIndex()].getBBox().width
                  ),
                this.showDropdown();
            }
            expandButtons() {
              const {
                buttons: y,
                buttonOptions: C,
                options: o,
                zoomText: r,
              } = this;
              this.hideDropdown(),
                r && r.show(),
                C.forEach((c, u) => {
                  (u = y[u]),
                    u.show(),
                    u.attr({
                      text: c.text,
                      width: o.buttonTheme.width || 28,
                      paddingLeft: D(o.buttonTheme.paddingLeft, "unset"),
                      paddingRight: D(o.buttonTheme.paddingRight, "unset"),
                    }),
                    2 > u.state && u.setState(0);
                }),
                this.positionButtons();
            }
            currentButtonIndex() {
              const { dropdown: y } = this;
              return y && 0 < y.selectedIndex ? y.selectedIndex - 1 : 0;
            }
            showDropdown() {
              const {
                buttonGroup: y,
                buttons: C,
                chart: o,
                dropdown: r,
              } = this;
              if (y && r) {
                const { translateX: c, translateY: u } = y,
                  v = C[this.currentButtonIndex()].getBBox();
                z(r, {
                  left: o.plotLeft + c + "px",
                  top: u + 0.5 + "px",
                  width: v.width + "px",
                  height: v.height + "px",
                }),
                  (this.hasVisibleDropdown = !0);
              }
            }
            hideDropdown() {
              const { dropdown: y } = this;
              y &&
                (z(y, { top: "-9999em", width: "1px", height: "1px" }),
                (this.hasVisibleDropdown = !1));
            }
            getHeight() {
              var y = this.options,
                C = this.group;
              const o = y.y,
                r = y.buttonPosition.y,
                c = y.inputPosition.y;
              return y.height
                ? y.height
                : (this.alignElements(),
                  (y = C ? C.getBBox(!0).height + 13 + o : 0),
                  (C = Math.min(c, r)),
                  ((0 > c && 0 > r) || (0 < c && 0 < r)) && (y += Math.abs(C)),
                  y);
            }
            titleCollision(y) {
              return !(y.options.title.text || y.options.subtitle.text);
            }
            update(y) {
              const C = this.chart;
              p(!0, C.options.rangeSelector, y),
                this.destroy(),
                this.init(C),
                this.render();
            }
            destroy() {
              const y = this,
                C = y.minInput,
                o = y.maxInput;
              y.eventsToUnbind &&
                (y.eventsToUnbind.forEach((r) => r()),
                (y.eventsToUnbind = void 0)),
                x(y.buttons),
                C && (C.onfocus = C.onblur = C.onchange = null),
                o && (o.onfocus = o.onblur = o.onchange = null),
                g(
                  y,
                  function (r, c) {
                    r &&
                      c !== "chart" &&
                      (r instanceof O
                        ? r.destroy()
                        : r instanceof window.HTMLElement && P(r)),
                      r !== f.prototype[c] && (y[c] = null);
                  },
                  this
                );
            }
          }
          return (
            h(f.prototype, {
              defaultButtons: [
                { type: "month", count: 1, text: "1m", title: "View 1 month" },
                { type: "month", count: 3, text: "3m", title: "View 3 months" },
                { type: "month", count: 6, text: "6m", title: "View 6 months" },
                { type: "ytd", text: "YTD", title: "View year to date" },
                { type: "year", count: 1, text: "1y", title: "View 1 year" },
                { type: "all", text: "All", title: "View all" },
              ],
              inputTypeFormats: {
                "datetime-local": "%Y-%m-%dT%H:%M:%S",
                date: "%Y-%m-%d",
                time: "%H:%M:%S",
              },
            }),
            f
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/RangeSelectorComponent.js",
        [
          e["Stock/RangeSelector/RangeSelector.js"],
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/Announcer.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O, B) {
          const { unhideChartElementFromAT: G, getAxisRangeDescription: Y } = d,
            { addEvent: L, attr: E } = B;
          class z extends a {
            constructor() {
              super(...arguments), (this.announcer = void 0);
            }
            init() {
              this.announcer = new M(this.chart, "polite");
            }
            onChartUpdate() {
              const x = this.chart,
                P = this,
                h = x.rangeSelector;
              h &&
                (this.updateSelectorVisibility(),
                this.setDropdownAttrs(),
                h.buttons &&
                  h.buttons.length &&
                  h.buttons.forEach((s) => {
                    P.setRangeButtonAttrs(s);
                  }),
                h.maxInput &&
                  h.minInput &&
                  ["minInput", "maxInput"].forEach(function (s, l) {
                    (s = h[s]) &&
                      (G(x, s),
                      P.setRangeInputAttrs(
                        s,
                        "accessibility.rangeSelector." +
                          (l ? "max" : "min") +
                          "InputLabel"
                      ));
                  }));
            }
            updateSelectorVisibility() {
              const x = this.chart,
                P = x.rangeSelector,
                h = P && P.dropdown,
                s = (P && P.buttons) || [];
              P && P.hasVisibleDropdown && h
                ? (G(x, h),
                  s.forEach((l) => l.element.setAttribute("aria-hidden", !0)))
                : (h && h.setAttribute("aria-hidden", !0),
                  s.forEach((l) => G(x, l.element)));
            }
            setDropdownAttrs() {
              var x = this.chart;
              const P = x.rangeSelector && x.rangeSelector.dropdown;
              P &&
                ((x = x.langFormat(
                  "accessibility.rangeSelector.dropdownLabel",
                  { rangeTitle: x.options.lang.rangeSelectorZoom }
                )),
                P.setAttribute("aria-label", x),
                P.setAttribute("tabindex", -1));
            }
            setRangeButtonAttrs(x) {
              E(x.element, { tabindex: -1, role: "button" });
            }
            setRangeInputAttrs(x, P) {
              const h = this.chart;
              E(x, {
                tabindex: -1,
                "aria-label": h.langFormat(P, { chart: h }),
              });
            }
            onButtonNavKbdArrowKey(x, P) {
              const h = x.response,
                s = this.keyCodes,
                l = this.chart,
                p = l.options.accessibility.keyboardNavigation.wrapAround;
              return (
                (P = P === s.left || P === s.up ? -1 : 1),
                l.highlightRangeSelectorButton(
                  l.highlightedRangeSelectorItemIx + P
                )
                  ? h.success
                  : p
                  ? (x.init(P), h.success)
                  : h[0 < P ? "next" : "prev"]
              );
            }
            onButtonNavKbdClick(x) {
              x = x.response;
              const P = this.chart;
              return (
                P.oldRangeSelectorItemState !== 3 &&
                  this.fakeClickEvent(
                    P.rangeSelector.buttons[P.highlightedRangeSelectorItemIx]
                      .element
                  ),
                x.success
              );
            }
            onAfterBtnClick() {
              var x = this.chart;
              const P = Y(x.xAxis[0]);
              (x = x.langFormat(
                "accessibility.rangeSelector.clickButtonAnnouncement",
                { chart: x, axisRangeDescription: P }
              )) && this.announcer.announce(x);
            }
            onInputKbdMove(x) {
              const P = this.chart;
              var h = P.rangeSelector;
              const s = (P.highlightedInputRangeIx =
                (P.highlightedInputRangeIx || 0) + x);
              if (1 < s || 0 > s) {
                if (P.accessibility)
                  return (
                    (P.accessibility.keyboardNavigation.exiting = !0),
                    P.accessibility.keyboardNavigation.tabindexContainer.focus(),
                    P.accessibility.keyboardNavigation.move(x)
                  );
              } else
                h &&
                  ((x = h[s ? "maxDateBox" : "minDateBox"]),
                  (h = h[s ? "maxInput" : "minInput"]),
                  x && h && P.setFocusToElement(x, h));
              return !0;
            }
            onInputNavInit(x) {
              const P = this;
              var h = this.chart;
              const s = 0 < x ? 0 : 1;
              var l = h.rangeSelector;
              const p = l && l[s ? "maxDateBox" : "minDateBox"];
              if (
                ((x = l && l.minInput),
                (l = l && l.maxInput),
                (h.highlightedInputRangeIx = s),
                p && x && l)
              ) {
                h.setFocusToElement(p, s ? l : x),
                  this.removeInputKeydownHandler &&
                    this.removeInputKeydownHandler(),
                  (h = (D) => {
                    (D.which || D.keyCode) === this.keyCodes.tab &&
                      P.onInputKbdMove(D.shiftKey ? -1 : 1) &&
                      (D.preventDefault(), D.stopPropagation());
                  });
                const g = L(x, "keydown", h),
                  T = L(l, "keydown", h);
                this.removeInputKeydownHandler = () => {
                  g(), T();
                };
              }
            }
            onInputNavTerminate() {
              const x = this.chart.rangeSelector || {};
              x.maxInput && x.hideInput("max"),
                x.minInput && x.hideInput("min"),
                this.removeInputKeydownHandler &&
                  (this.removeInputKeydownHandler(),
                  delete this.removeInputKeydownHandler);
            }
            initDropdownNav() {
              const x = this.chart,
                P = x.rangeSelector,
                h = P && P.dropdown;
              P &&
                h &&
                (x.setFocusToElement(P.buttonGroup, h),
                this.removeDropdownKeydownHandler &&
                  this.removeDropdownKeydownHandler(),
                (this.removeDropdownKeydownHandler = L(h, "keydown", (s) => {
                  const l = x.accessibility;
                  (s.which || s.keyCode) === this.keyCodes.tab &&
                    (s.preventDefault(),
                    s.stopPropagation(),
                    l &&
                      (l.keyboardNavigation.tabindexContainer.focus(),
                      l.keyboardNavigation.move(s.shiftKey ? -1 : 1)));
                })));
            }
            getRangeSelectorButtonNavigation() {
              const x = this.chart,
                P = this.keyCodes,
                h = this;
              return new O(x, {
                keyCodeMap: [
                  [
                    [P.left, P.right, P.up, P.down],
                    function (s) {
                      return h.onButtonNavKbdArrowKey(this, s);
                    },
                  ],
                  [
                    [P.enter, P.space],
                    function () {
                      return h.onButtonNavKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return !!(
                    x.rangeSelector &&
                    x.rangeSelector.buttons &&
                    x.rangeSelector.buttons.length
                  );
                },
                init: function (s) {
                  var l = x.rangeSelector;
                  l && l.hasVisibleDropdown
                    ? h.initDropdownNav()
                    : l &&
                      ((l = l.buttons.length - 1),
                      x.highlightRangeSelectorButton(0 < s ? 0 : l));
                },
                terminate: function () {
                  h.removeDropdownKeydownHandler &&
                    (h.removeDropdownKeydownHandler(),
                    delete h.removeDropdownKeydownHandler);
                },
              });
            }
            getRangeSelectorInputNavigation() {
              const x = this.chart,
                P = this;
              return new O(x, {
                keyCodeMap: [],
                validate: function () {
                  return !!(
                    x.rangeSelector &&
                    x.rangeSelector.inputGroup &&
                    x.rangeSelector.inputGroup.element.style.visibility !==
                      "hidden" &&
                    x.options.rangeSelector.inputEnabled !== !1 &&
                    x.rangeSelector.minInput &&
                    x.rangeSelector.maxInput
                  );
                },
                init: function (h) {
                  P.onInputNavInit(h);
                },
                terminate: function () {
                  P.onInputNavTerminate();
                },
              });
            }
            getKeyboardNavigation() {
              return [
                this.getRangeSelectorButtonNavigation(),
                this.getRangeSelectorInputNavigation(),
              ];
            }
            destroy() {
              this.removeDropdownKeydownHandler &&
                this.removeDropdownKeydownHandler(),
                this.removeInputKeydownHandler &&
                  this.removeInputKeydownHandler(),
                this.announcer && this.announcer.destroy();
            }
          }
          return (
            (function (S) {
              function x(s) {
                const l =
                    (this.rangeSelector && this.rangeSelector.buttons) || [],
                  p = this.highlightedRangeSelectorItemIx,
                  g = this.rangeSelector && this.rangeSelector.selected;
                return (
                  typeof p < "u" &&
                    l[p] &&
                    p !== g &&
                    l[p].setState(this.oldRangeSelectorItemState || 0),
                  (this.highlightedRangeSelectorItemIx = s),
                  l[s]
                    ? (this.setFocusToElement(l[s].box, l[s].element),
                      s !== g &&
                        ((this.oldRangeSelectorItemState = l[s].state),
                        l[s].setState(1)),
                      !0)
                    : !1
                );
              }
              function P() {
                const s = this.chart.accessibility;
                if (s && s.components.rangeSelector)
                  return s.components.rangeSelector.onAfterBtnClick();
              }
              const h = [];
              S.compose = function (s, l) {
                B.pushUnique(h, s) &&
                  (s.prototype.highlightRangeSelectorButton = x),
                  B.pushUnique(h, l) && L(i, "afterBtnClick", P);
              };
            })(z || (z = {})),
            z
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/SeriesComponent/ForcedMarkers.js",
        [e["Core/Utilities.js"]],
        function (i) {
          const { addEvent: a, merge: d } = i;
          var M;
          return (
            (function (O) {
              function B(S) {
                d(!0, S, {
                  marker: { enabled: !0, states: { normal: { opacity: 0 } } },
                });
              }
              function G(S) {
                return (
                  S.marker.states &&
                  S.marker.states.normal &&
                  S.marker.states.normal.opacity
                );
              }
              function Y() {
                this.chart.styledMode &&
                  (this.markerGroup &&
                    this.markerGroup[
                      this.a11yMarkersForced ? "addClass" : "removeClass"
                    ]("highcharts-a11y-markers-hidden"),
                  this._hasPointMarkers &&
                    this.points &&
                    this.points.length &&
                    this.points.forEach((S) => {
                      S.graphic &&
                        (S.graphic[
                          S.hasForcedA11yMarker ? "addClass" : "removeClass"
                        ]("highcharts-a11y-marker-hidden"),
                        S.graphic[
                          S.hasForcedA11yMarker === !1
                            ? "addClass"
                            : "removeClass"
                        ]("highcharts-a11y-marker-visible"));
                    }));
              }
              function L(S) {
                this.resetA11yMarkerOptions = d(
                  S.options.marker || {},
                  this.userOptions.marker || {}
                );
              }
              function E() {
                var S = this.options,
                  x =
                    (this.options.accessibility &&
                      this.options.accessibility.enabled) !== !1;
                if (
                  ((x = this.chart.options.accessibility.enabled && x) &&
                    ((x = this.chart.options.accessibility),
                    (x =
                      this.points.length <
                        x.series.pointDescriptionEnabledThreshold ||
                      x.series.pointDescriptionEnabledThreshold === !1)),
                  x)
                ) {
                  if (
                    (S.marker &&
                      S.marker.enabled === !1 &&
                      ((this.a11yMarkersForced = !0), B(this.options)),
                    this._hasPointMarkers && this.points && this.points.length)
                  )
                    for (S = this.points.length; S--; ) {
                      x = this.points[S];
                      const h = x.options;
                      var P = x.hasForcedA11yMarker;
                      delete x.hasForcedA11yMarker,
                        h.marker &&
                          ((P = P && G(h) === 0),
                          h.marker.enabled && !P
                            ? (d(!0, h.marker, {
                                states: { normal: { opacity: G(h) || 1 } },
                              }),
                              (x.hasForcedA11yMarker = !1))
                            : h.marker.enabled === !1 &&
                              (B(h), (x.hasForcedA11yMarker = !0)));
                    }
                } else
                  this.a11yMarkersForced &&
                    (delete this.a11yMarkersForced,
                    (S = this.resetA11yMarkerOptions) &&
                      this.update({
                        marker: {
                          enabled: S.enabled,
                          states: {
                            normal: {
                              opacity:
                                S.states &&
                                S.states.normal &&
                                S.states.normal.opacity,
                            },
                          },
                        },
                      }),
                    delete this.resetA11yMarkerOptions);
              }
              const z = [];
              O.compose = function (S) {
                i.pushUnique(z, S) &&
                  (a(S, "afterSetOptions", L),
                  a(S, "render", E),
                  a(S, "afterRender", Y));
              };
            })(M || (M = {})),
            M
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js",
        [
          e["Core/Series/Point.js"],
          e["Core/Series/Series.js"],
          e["Core/Series/SeriesRegistry.js"],
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Accessibility/Utils/EventProvider.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
        ],
        function (i, a, d, M, O, B, G, Y) {
          function L(m) {
            const f = m.index,
              b = m.series.points;
            let y = b.length;
            if (b[f] !== m) {
              for (; y--; ) if (b[y] === m) return y;
            } else return f;
          }
          function E(m) {
            const f =
                m.chart.options.accessibility.keyboardNavigation
                  .seriesNavigation,
              b = m.options.accessibility || {},
              y = b.keyboardNavigation;
            return (
              (y && y.enabled === !1) ||
              b.enabled === !1 ||
              m.options.enableMouseTracking === !1 ||
              !m.visible ||
              (f.pointNavigationEnabledThreshold &&
                f.pointNavigationEnabledThreshold <= m.points.length)
            );
          }
          function z(m) {
            const f = m.series.chart.options.accessibility,
              b =
                m.options.accessibility &&
                m.options.accessibility.enabled === !1;
            return (
              (m.isNull &&
                f.keyboardNavigation.seriesNavigation.skipNullPoints) ||
              m.visible === !1 ||
              m.isInside === !1 ||
              b ||
              E(m.series)
            );
          }
          function S(m) {
            m = m.series || [];
            const f = m.length;
            for (let y = 0; y < f; ++y)
              if (!E(m[y])) {
                t: {
                  var b = m[y].points || [];
                  const C = b.length;
                  for (let o = 0; o < C; ++o)
                    if (!z(b[o])) {
                      b = b[o];
                      break t;
                    }
                  b = null;
                }
                if (b) return b;
              }
            return null;
          }
          function x(m) {
            let f = m.series.length,
              b = !1;
            for (
              ;
              f-- &&
              ((m.highlightedPoint =
                m.series[f].points[m.series[f].points.length - 1]),
              !(b = m.series[f].highlightNextValidPoint()));

            );
            return b;
          }
          function P(m) {
            return delete m.highlightedPoint, (m = S(m)) ? m.highlight() : !1;
          }
          const { seriesTypes: h } = d,
            { doc: s } = M,
            { defined: l, fireEvent: p } = O,
            { getPointFromXY: g, getSeriesFromName: T, scrollToPoint: D } = Y;
          class A {
            constructor(f, b) {
              (this.keyCodes = b), (this.chart = f);
            }
            init() {
              const f = this,
                b = this.chart,
                y = (this.eventProvider = new G());
              y.addEvent(a, "destroy", function () {
                return f.onSeriesDestroy(this);
              }),
                y.addEvent(b, "afterApplyDrilldown", function () {
                  {
                    const C = S(this);
                    C && C.highlight(!1);
                  }
                }),
                y.addEvent(b, "drilldown", function (C) {
                  C = C.point;
                  const o = C.series;
                  f.lastDrilledDownPoint = {
                    x: C.x,
                    y: C.y,
                    seriesName: o ? o.name : "",
                  };
                }),
                y.addEvent(b, "drillupall", function () {
                  setTimeout(function () {
                    f.onDrillupAll();
                  }, 10);
                }),
                y.addEvent(i, "afterSetState", function () {
                  const C = this.graphic && this.graphic.element,
                    o = s.activeElement;
                  var r = o && o.getAttribute("class");
                  (r = r && -1 < r.indexOf("highcharts-a11y-proxy-button")),
                    b.highlightedPoint === this &&
                      o !== C &&
                      !r &&
                      C &&
                      C.focus &&
                      C.focus();
                });
            }
            onDrillupAll() {
              const f = this.lastDrilledDownPoint,
                b = this.chart,
                y = f && T(b, f.seriesName);
              let C;
              f && y && l(f.x) && l(f.y) && (C = g(y, f.x, f.y)),
                (C = C || S(b)),
                b.container && b.container.focus(),
                C && C.highlight && C.highlight(!1);
            }
            getKeyboardNavigationHandler() {
              const f = this,
                b = this.keyCodes,
                y = this.chart,
                C = y.inverted;
              return new B(y, {
                keyCodeMap: [
                  [
                    C ? [b.up, b.down] : [b.left, b.right],
                    function (o) {
                      return f.onKbdSideways(this, o);
                    },
                  ],
                  [
                    C ? [b.left, b.right] : [b.up, b.down],
                    function (o) {
                      return f.onKbdVertical(this, o);
                    },
                  ],
                  [
                    [b.enter, b.space],
                    function (o, r) {
                      return (
                        (o = y.highlightedPoint) &&
                          ((r.point = o),
                          p(o.series, "click", r),
                          o.firePointEvent("click")),
                        this.response.success
                      );
                    },
                  ],
                  [
                    [b.home],
                    function () {
                      return P(y), this.response.success;
                    },
                  ],
                  [
                    [b.end],
                    function () {
                      return x(y), this.response.success;
                    },
                  ],
                  [
                    [b.pageDown, b.pageUp],
                    function (o) {
                      return (
                        y.highlightAdjacentSeries(o === b.pageDown),
                        this.response.success
                      );
                    },
                  ],
                ],
                init: function () {
                  return f.onHandlerInit(this);
                },
                validate: function () {
                  return !!S(y);
                },
                terminate: function () {
                  return f.onHandlerTerminate();
                },
              });
            }
            onKbdSideways(f, b) {
              const y = this.keyCodes;
              return this.attemptHighlightAdjacentPoint(
                f,
                b === y.right || b === y.down
              );
            }
            onHandlerInit(f) {
              const b = this.chart;
              return (
                b.options.accessibility.keyboardNavigation.seriesNavigation
                  .rememberPointFocus && b.highlightedPoint
                  ? b.highlightedPoint.highlight()
                  : P(b),
                f.response.success
              );
            }
            onKbdVertical(f, b) {
              const y = this.chart;
              var C = this.keyCodes;
              return (
                (b = b === C.down || b === C.right),
                (C =
                  y.options.accessibility.keyboardNavigation.seriesNavigation),
                C.mode && C.mode === "serialize"
                  ? this.attemptHighlightAdjacentPoint(f, b)
                  : (y[
                      y.highlightedPoint &&
                      y.highlightedPoint.series.keyboardMoveVertical
                        ? "highlightAdjacentPointVertical"
                        : "highlightAdjacentSeries"
                    ](b),
                    f.response.success)
              );
            }
            onHandlerTerminate() {
              const f = this.chart,
                b = f.options.accessibility.keyboardNavigation;
              f.tooltip && f.tooltip.hide(0);
              const y = f.highlightedPoint && f.highlightedPoint.series;
              y && y.onMouseOut && y.onMouseOut(),
                f.highlightedPoint &&
                  f.highlightedPoint.onMouseOut &&
                  f.highlightedPoint.onMouseOut(),
                b.seriesNavigation.rememberPointFocus ||
                  delete f.highlightedPoint;
            }
            attemptHighlightAdjacentPoint(f, b) {
              const y = this.chart,
                C = y.options.accessibility.keyboardNavigation.wrapAround;
              return y.highlightAdjacentPoint(b) || (C && (b ? P(y) : x(y)))
                ? f.response.success
                : f.response[b ? "next" : "prev"];
            }
            onSeriesDestroy(f) {
              const b = this.chart;
              b.highlightedPoint &&
                b.highlightedPoint.series === f &&
                (delete b.highlightedPoint,
                b.focusElement && b.focusElement.removeFocusBorder());
            }
            destroy() {
              this.eventProvider.removeAddedEvents();
            }
          }
          return (
            (function (m) {
              function f(u) {
                var v = this.series;
                const N = this.highlightedPoint;
                var w = (N && L(N)) || 0;
                const R = (N && N.series.points) || [];
                var X = this.series && this.series[this.series.length - 1];
                if (
                  ((X = X && X.points && X.points[X.points.length - 1]),
                  !v[0] || !v[0].points)
                )
                  return !1;
                if (N) {
                  if (
                    ((v = v[N.series.index + (u ? 1 : -1)]),
                    (w = R[w + (u ? 1 : -1)]),
                    !w && v && (w = v.points[u ? 0 : v.points.length - 1]),
                    !w)
                  )
                    return !1;
                } else w = u ? v[0].points[0] : X;
                return z(w)
                  ? ((v = w.series),
                    E(v)
                      ? (this.highlightedPoint = u
                          ? v.points[v.points.length - 1]
                          : v.points[0])
                      : (this.highlightedPoint = w),
                    this.highlightAdjacentPoint(u))
                  : w.highlight();
              }
              function b(u) {
                const v = this.highlightedPoint;
                let N = 1 / 0,
                  w;
                return !l(v.plotX) || !l(v.plotY)
                  ? !1
                  : (this.series.forEach((R) => {
                      E(R) ||
                        R.points.forEach((X) => {
                          if (l(X.plotY) && l(X.plotX) && X !== v) {
                            var J = X.plotY - v.plotY,
                              K = Math.abs(X.plotX - v.plotX);
                            (K = Math.abs(J) * Math.abs(J) + K * K * 4),
                              R.yAxis && R.yAxis.reversed && (J *= -1),
                              !(
                                (0 >= J && u) ||
                                (0 <= J && !u) ||
                                5 > K ||
                                z(X)
                              ) &&
                                K < N &&
                                ((N = K), (w = X));
                          }
                        });
                    }),
                    w ? w.highlight() : !1);
              }
              function y(u) {
                const v = this.highlightedPoint;
                var N = this.series && this.series[this.series.length - 1],
                  w = N && N.points && N.points[N.points.length - 1];
                return this.highlightedPoint
                  ? ((N = this.series[v.series.index + (u ? -1 : 1)]),
                    !N || ((w = C(v, N, 4)), !w)
                      ? !1
                      : E(N)
                      ? (w.highlight(),
                        (u = this.highlightAdjacentSeries(u)),
                        u || (v.highlight(), !1))
                      : (w.highlight(), w.series.highlightNextValidPoint()))
                  : ((N = u ? this.series && this.series[0] : N),
                    (w = u ? N && N.points && N.points[0] : w)
                      ? w.highlight()
                      : !1);
              }
              function C(u, v, N, w) {
                let R = 1 / 0,
                  X,
                  J = v.points.length;
                const K = (k) => !(l(k.plotX) && l(k.plotY));
                if (!K(u)) {
                  for (; J--; ) {
                    var H = v.points[J];
                    K(H) ||
                      ((H =
                        (u.plotX - H.plotX) * (u.plotX - H.plotX) * (N || 1) +
                        (u.plotY - H.plotY) * (u.plotY - H.plotY) * (w || 1)),
                      H < R && ((R = H), (X = J)));
                  }
                  return l(X) ? v.points[X] : void 0;
                }
              }
              function o(u = !0) {
                const v = this.series.chart;
                return (
                  !this.isNull && u
                    ? this.onMouseOver()
                    : v.tooltip && v.tooltip.hide(0),
                  D(this),
                  this.graphic &&
                    (v.setFocusToElement(this.graphic),
                    !u && v.focusElement && v.focusElement.removeFocusBorder()),
                  (v.highlightedPoint = this),
                  this
                );
              }
              function r() {
                var u = this.chart.highlightedPoint,
                  v = (u && u.series) === this ? L(u) : 0;
                u = this.points;
                const N = u.length;
                if (u && N) {
                  for (let w = v; w < N; ++w)
                    if (!z(u[w])) return u[w].highlight();
                  for (; 0 <= v; --v) if (!z(u[v])) return u[v].highlight();
                }
                return !1;
              }
              const c = [];
              m.compose = function (u, v, N) {
                O.pushUnique(c, u) &&
                  ((u = u.prototype),
                  (u.highlightAdjacentPoint = f),
                  (u.highlightAdjacentPointVertical = b),
                  (u.highlightAdjacentSeries = y)),
                  O.pushUnique(c, v) && (v.prototype.highlight = o),
                  O.pushUnique(c, N) &&
                    ((v = N.prototype),
                    (v.keyboardMoveVertical = !0),
                    ["column", "gantt", "pie"].forEach((w) => {
                      h[w] && (h[w].prototype.keyboardMoveVertical = !1);
                    }),
                    (v.highlightNextValidPoint = r));
              };
            })(A || (A = {})),
            A
          );
        }
      ),
      n(
        e,
        "Accessibility/Components/SeriesComponent/SeriesComponent.js",
        [
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Components/SeriesComponent/ForcedMarkers.js"],
          e["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
          e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
          e[
            "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js"
          ],
        ],
        function (i, a, d, M, O, B) {
          const { hideSeriesFromAT: G } = a,
            { describeSeries: Y } = O;
          class L extends i {
            static compose(z, S, x) {
              M.compose(x), d.compose(x), B.compose(z, S, x);
            }
            init() {
              (this.newDataAnnouncer = new M(this.chart)),
                this.newDataAnnouncer.init(),
                (this.keyboardNavigation = new B(this.chart, this.keyCodes)),
                this.keyboardNavigation.init(),
                this.hideTooltipFromATWhenShown(),
                this.hideSeriesLabelsFromATWhenShown();
            }
            hideTooltipFromATWhenShown() {
              const z = this;
              this.chart.tooltip &&
                this.addEvent(
                  this.chart.tooltip.constructor,
                  "refresh",
                  function () {
                    this.chart === z.chart &&
                      this.label &&
                      this.label.element &&
                      this.label.element.setAttribute("aria-hidden", !0);
                  }
                );
            }
            hideSeriesLabelsFromATWhenShown() {
              this.addEvent(this.chart, "afterDrawSeriesLabels", function () {
                this.series.forEach(function (z) {
                  z.labelBySeries && z.labelBySeries.attr("aria-hidden", !0);
                });
              });
            }
            onChartRender() {
              this.chart.series.forEach(function (z) {
                (z.options.accessibility && z.options.accessibility.enabled) !==
                  !1 && z.visible
                  ? Y(z)
                  : G(z);
              });
            }
            getKeyboardNavigation() {
              return this.keyboardNavigation.getKeyboardNavigationHandler();
            }
            destroy() {
              this.newDataAnnouncer.destroy(),
                this.keyboardNavigation.destroy();
            }
          }
          return L;
        }
      ),
      n(
        e,
        "Accessibility/Components/ZoomComponent.js",
        [
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Core/Utilities.js"],
        ],
        function (i, a, d, M, O) {
          const { unhideChartElementFromAT: B } = a,
            { getFakeMouseEvent: G } = d,
            { attr: Y, pick: L } = O;
          class E extends i {
            constructor() {
              super(...arguments), (this.focusedMapNavButtonIx = -1);
            }
            init() {
              const S = this,
                x = this.chart;
              this.proxyProvider.addGroup("zoom", "div"),
                [
                  "afterShowResetZoom",
                  "afterApplyDrilldown",
                  "drillupall",
                ].forEach((P) => {
                  S.addEvent(x, P, function () {
                    S.updateProxyOverlays();
                  });
                });
            }
            onChartUpdate() {
              const S = this.chart,
                x = this;
              S.mapNavigation &&
                S.mapNavigation.navButtons.forEach((P, h) => {
                  B(S, P.element),
                    x.setMapNavButtonAttrs(
                      P.element,
                      "accessibility.zoom.mapZoom" + (h ? "Out" : "In")
                    );
                });
            }
            setMapNavButtonAttrs(S, x) {
              const P = this.chart;
              (x = P.langFormat(x, { chart: P })),
                Y(S, { tabindex: -1, role: "button", "aria-label": x });
            }
            onChartRender() {
              this.updateProxyOverlays();
            }
            updateProxyOverlays() {
              const S = this.chart;
              this.proxyProvider.clearGroup("zoom"),
                S.resetZoomButton &&
                  this.createZoomProxyButton(
                    S.resetZoomButton,
                    "resetZoomProxyButton",
                    S.langFormat("accessibility.zoom.resetZoomButton", {
                      chart: S,
                    })
                  ),
                S.drillUpButton &&
                  S.breadcrumbs &&
                  S.breadcrumbs.list &&
                  this.createZoomProxyButton(
                    S.drillUpButton,
                    "drillUpProxyButton",
                    S.langFormat("accessibility.drillUpButton", {
                      chart: S,
                      buttonText: S.breadcrumbs.getButtonText(
                        S.breadcrumbs.list[S.breadcrumbs.list.length - 1]
                      ),
                    })
                  );
            }
            createZoomProxyButton(S, x, P) {
              this[x] = this.proxyProvider.addProxyElement(
                "zoom",
                { click: S },
                { "aria-label": P, tabindex: -1 }
              );
            }
            getMapZoomNavigation() {
              const S = this.keyCodes,
                x = this.chart,
                P = this;
              return new M(x, {
                keyCodeMap: [
                  [
                    [S.up, S.down, S.left, S.right],
                    function (h) {
                      return P.onMapKbdArrow(this, h);
                    },
                  ],
                  [
                    [S.tab],
                    function (h, s) {
                      return P.onMapKbdTab(this, s);
                    },
                  ],
                  [
                    [S.space, S.enter],
                    function () {
                      return P.onMapKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return !!(
                    x.mapView &&
                    x.mapNavigation &&
                    x.mapNavigation.navButtons.length
                  );
                },
                init: function (h) {
                  return P.onMapNavInit(h);
                },
              });
            }
            onMapKbdArrow(S, x) {
              var P = this.chart,
                h = this.keyCodes;
              const s = P.container;
              var l = x === h.up || x === h.down;
              return (
                (x =
                  ((l ? P.plotHeight : P.plotWidth) / 10) *
                  (x === h.left || x === h.up ? 1 : -1)),
                (h = 10 * Math.random()),
                (P = {
                  x: s.offsetLeft + P.plotLeft + P.plotWidth / 2 + h,
                  y: s.offsetTop + P.plotTop + P.plotHeight / 2 + h,
                }),
                (l = l ? { x: P.x, y: P.y + x } : { x: P.x + x, y: P.y }),
                [G("mousedown", P), G("mousemove", l), G("mouseup", l)].forEach(
                  (p) => s.dispatchEvent(p)
                ),
                S.response.success
              );
            }
            onMapKbdTab(S, x) {
              const P = this.chart;
              S = S.response;
              const h =
                ((x = x.shiftKey) && !this.focusedMapNavButtonIx) ||
                (!x && this.focusedMapNavButtonIx);
              return (
                P.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(
                  0
                ),
                h
                  ? (P.mapView && P.mapView.zoomBy(), S[x ? "prev" : "next"])
                  : ((this.focusedMapNavButtonIx += x ? -1 : 1),
                    (x =
                      P.mapNavigation.navButtons[this.focusedMapNavButtonIx]),
                    P.setFocusToElement(x.box, x.element),
                    x.setState(2),
                    S.success)
              );
            }
            onMapKbdClick(S) {
              return (
                this.fakeClickEvent(
                  this.chart.mapNavigation.navButtons[
                    this.focusedMapNavButtonIx
                  ].element
                ),
                S.response.success
              );
            }
            onMapNavInit(S) {
              const x = this.chart;
              var P = x.mapNavigation.navButtons[0];
              const h = x.mapNavigation.navButtons[1];
              (P = 0 < S ? P : h),
                x.setFocusToElement(P.box, P.element),
                P.setState(2),
                (this.focusedMapNavButtonIx = 0 < S ? 0 : 1);
            }
            simpleButtonNavigation(S, x, P) {
              const h = this.keyCodes,
                s = this,
                l = this.chart;
              return new M(l, {
                keyCodeMap: [
                  [
                    [h.tab, h.up, h.down, h.left, h.right],
                    function (p, g) {
                      return this.response[
                        (p === h.tab && g.shiftKey) ||
                        p === h.left ||
                        p === h.up
                          ? "prev"
                          : "next"
                      ];
                    },
                  ],
                  [
                    [h.space, h.enter],
                    function () {
                      const p = P(this, l);
                      return L(p, this.response.success);
                    },
                  ],
                ],
                validate: function () {
                  return l[S] && l[S].box && s[x].buttonElement;
                },
                init: function () {
                  l.setFocusToElement(l[S].box, s[x].buttonElement);
                },
              });
            }
            getKeyboardNavigation() {
              return [
                this.simpleButtonNavigation(
                  "resetZoomButton",
                  "resetZoomProxyButton",
                  function (S, x) {
                    x.zoomOut();
                  }
                ),
                this.simpleButtonNavigation(
                  "drillUpButton",
                  "drillUpProxyButton",
                  function (S, x) {
                    return x.drillUp(), S.response.prev;
                  }
                ),
                this.getMapZoomNavigation(),
              ];
            }
          }
          return E;
        }
      ),
      n(
        e,
        "Accessibility/HighContrastMode.js",
        [e["Core/Globals.js"]],
        function (i) {
          const { doc: a, isMS: d, win: M } = i;
          return {
            isHighContrastModeActive: function () {
              var O = /(Edg)/.test(M.navigator.userAgent);
              if (M.matchMedia && O)
                return M.matchMedia("(-ms-high-contrast: active)").matches;
              if (d && M.getComputedStyle) {
                (O = a.createElement("div")),
                  (O.style.backgroundImage =
                    "url(data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)"),
                  a.body.appendChild(O);
                const B = (O.currentStyle || M.getComputedStyle(O))
                  .backgroundImage;
                return a.body.removeChild(O), B === "none";
              }
              return (
                M.matchMedia && M.matchMedia("(forced-colors: active)").matches
              );
            },
            setHighContrastTheme: function (O) {
              O.highContrastModeActive = !0;
              const B = O.options.accessibility.highContrastTheme;
              O.update(B, !1),
                O.series.forEach(function (G) {
                  const Y = B.plotOptions[G.type] || {};
                  G.update({
                    color: Y.color || "windowText",
                    colors: [Y.color || "windowText"],
                    borderColor: Y.borderColor || "window",
                  }),
                    G.points.forEach(function (L) {
                      L.options &&
                        L.options.color &&
                        L.update(
                          {
                            color: Y.color || "windowText",
                            borderColor: Y.borderColor || "window",
                          },
                          !1
                        );
                    });
                }),
                O.redraw();
            },
          };
        }
      ),
      n(e, "Accessibility/HighContrastTheme.js", [], function () {
        return {
          chart: { backgroundColor: "window" },
          title: { style: { color: "windowText" } },
          subtitle: { style: { color: "windowText" } },
          colorAxis: {
            minColor: "windowText",
            maxColor: "windowText",
            stops: [],
          },
          colors: ["windowText"],
          xAxis: {
            gridLineColor: "windowText",
            labels: { style: { color: "windowText" } },
            lineColor: "windowText",
            minorGridLineColor: "windowText",
            tickColor: "windowText",
            title: { style: { color: "windowText" } },
          },
          yAxis: {
            gridLineColor: "windowText",
            labels: { style: { color: "windowText" } },
            lineColor: "windowText",
            minorGridLineColor: "windowText",
            tickColor: "windowText",
            title: { style: { color: "windowText" } },
          },
          tooltip: {
            backgroundColor: "window",
            borderColor: "windowText",
            style: { color: "windowText" },
          },
          plotOptions: {
            series: {
              lineColor: "windowText",
              fillColor: "window",
              borderColor: "windowText",
              edgeColor: "windowText",
              borderWidth: 1,
              dataLabels: {
                connectorColor: "windowText",
                color: "windowText",
                style: { color: "windowText", textOutline: "none" },
              },
              marker: { lineColor: "windowText", fillColor: "windowText" },
            },
            pie: {
              color: "window",
              colors: ["window"],
              borderColor: "windowText",
              borderWidth: 1,
            },
            boxplot: { fillColor: "window" },
            candlestick: { lineColor: "windowText", fillColor: "window" },
            errorbar: { fillColor: "window" },
          },
          legend: {
            backgroundColor: "window",
            itemStyle: { color: "windowText" },
            itemHoverStyle: { color: "windowText" },
            itemHiddenStyle: { color: "#555" },
            title: { style: { color: "windowText" } },
          },
          credits: { style: { color: "windowText" } },
          drilldown: {
            activeAxisLabelStyle: { color: "windowText" },
            activeDataLabelStyle: { color: "windowText" },
          },
          navigation: {
            buttonOptions: {
              symbolStroke: "windowText",
              theme: { fill: "window" },
            },
          },
          rangeSelector: {
            buttonTheme: {
              fill: "window",
              stroke: "windowText",
              style: { color: "windowText" },
              states: {
                hover: {
                  fill: "window",
                  stroke: "windowText",
                  style: { color: "windowText" },
                },
                select: {
                  fill: "#444",
                  stroke: "windowText",
                  style: { color: "windowText" },
                },
              },
            },
            inputBoxBorderColor: "windowText",
            inputStyle: { backgroundColor: "window", color: "windowText" },
            labelStyle: { color: "windowText" },
          },
          navigator: {
            handles: { backgroundColor: "window", borderColor: "windowText" },
            outlineColor: "windowText",
            maskFill: "transparent",
            series: { color: "windowText", lineColor: "windowText" },
            xAxis: { gridLineColor: "windowText" },
          },
          scrollbar: {
            barBackgroundColor: "#444",
            barBorderColor: "windowText",
            buttonArrowColor: "windowText",
            buttonBackgroundColor: "window",
            buttonBorderColor: "windowText",
            rifleColor: "windowText",
            trackBackgroundColor: "window",
            trackBorderColor: "windowText",
          },
        };
      }),
      n(e, "Accessibility/Options/A11yDefaults.js", [], function () {
        return {
          accessibility: {
            enabled: !0,
            screenReaderSection: {
              beforeChartFormat:
                "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
              afterChartFormat: "{endOfChartMarker}",
              axisRangeDateFormat: "%Y-%m-%d %H:%M:%S",
            },
            series: {
              descriptionFormat:
                "{seriesDescription}{authorDescription}{axisDescription}",
              describeSingleSeries: !1,
              pointDescriptionEnabledThreshold: 200,
            },
            point: {
              valueDescriptionFormat: "{xDescription}{separator}{value}.",
              describeNull: !0,
            },
            landmarkVerbosity: "all",
            linkedDescription:
              '*[data-highcharts-chart="{index}"] + .highcharts-description',
            keyboardNavigation: {
              enabled: !0,
              focusBorder: {
                enabled: !0,
                hideBrowserFocusOutline: !0,
                style: { color: "#334eff", lineWidth: 2, borderRadius: 3 },
                margin: 2,
              },
              order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
              wrapAround: !0,
              seriesNavigation: {
                skipNullPoints: !0,
                pointNavigationEnabledThreshold: !1,
                rememberPointFocus: !1,
              },
            },
            announceNewData: {
              enabled: !1,
              minAnnounceInterval: 5e3,
              interruptUser: !1,
            },
          },
          legend: {
            accessibility: { enabled: !0, keyboardNavigation: { enabled: !0 } },
          },
          exporting: { accessibility: { enabled: !0 } },
        };
      }),
      n(e, "Accessibility/Options/LangDefaults.js", [], function () {
        return {
          accessibility: {
            defaultChartTitle: "Chart",
            chartContainerLabel: "{title}. Highcharts interactive chart.",
            svgContainerLabel: "Interactive chart",
            drillUpButton: "{buttonText}",
            credits: "Chart credits: {creditsStr}",
            thousandsSep: ",",
            svgContainerTitle: "",
            graphicContainerLabel: "",
            screenReaderSection: {
              beforeRegionLabel: "",
              afterRegionLabel: "",
              annotations: {
                heading: "Chart annotations summary",
                descriptionSinglePoint:
                  "{annotationText}. Related to {annotationPoint}",
                descriptionMultiplePoints:
                  "{annotationText}. Related to {annotationPoint}{#each additionalAnnotationPoints}, also related to {this}{/each}",
                descriptionNoPoints: "{annotationText}",
              },
              endOfChartMarker: "End of interactive chart.",
            },
            sonification: {
              playAsSoundButtonText: "Play as sound, {chartTitle}",
              playAsSoundClickAnnouncement: "Play",
            },
            legend: {
              legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
              legendLabel: "Chart legend: {legendTitle}",
              legendItem: "Show {itemName}",
            },
            zoom: {
              mapZoomIn: "Zoom chart",
              mapZoomOut: "Zoom out chart",
              resetZoomButton: "Reset zoom",
            },
            rangeSelector: {
              dropdownLabel: "{rangeTitle}",
              minInputLabel: "Select start date.",
              maxInputLabel: "Select end date.",
              clickButtonAnnouncement: "Viewing {axisRangeDescription}",
            },
            table: {
              viewAsDataTableButtonText: "View as data table, {chartTitle}",
              tableSummary: "Table representation of chart.",
            },
            announceNewData: {
              newDataAnnounce: "Updated data for chart {chartTitle}",
              newSeriesAnnounceSingle: "New data series: {seriesDesc}",
              newPointAnnounceSingle: "New data point: {pointDesc}",
              newSeriesAnnounceMultiple:
                "New data series in chart {chartTitle}: {seriesDesc}",
              newPointAnnounceMultiple:
                "New data point in chart {chartTitle}: {pointDesc}",
            },
            seriesTypeDescriptions: {
              boxplot:
                "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
              arearange:
                "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
              areasplinerange:
                "These charts are line charts displaying a range between a lower and higher value for each point.",
              bubble:
                "Bubble charts are scatter charts where each data point also has a size value.",
              columnrange:
                "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
              errorbar:
                "Errorbar series are used to display the variability of the data.",
              funnel:
                "Funnel charts are used to display reduction of data in stages.",
              pyramid:
                "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
              waterfall:
                "A waterfall chart is a column chart where each column contributes towards a total end value.",
            },
            chartTypes: {
              emptyChart: "Empty chart",
              mapTypeDescription:
                "Map of {mapTitle} with {numSeries} data series.",
              unknownMap:
                "Map of unspecified region with {numSeries} data series.",
              combinationChart:
                "Combination chart with {numSeries} data series.",
              defaultSingle:
                "Chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              defaultMultiple: "Chart with {numSeries} data series.",
              splineSingle:
                "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              splineMultiple: "Line chart with {numSeries} lines.",
              lineSingle:
                "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              lineMultiple: "Line chart with {numSeries} lines.",
              columnSingle:
                "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
              columnMultiple: "Bar chart with {numSeries} data series.",
              barSingle:
                "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
              barMultiple: "Bar chart with {numSeries} data series.",
              pieSingle:
                "Pie chart with {numPoints} {#eq numPoints 1}slice{else}slices{/eq}.",
              pieMultiple: "Pie chart with {numSeries} pies.",
              scatterSingle:
                "Scatter chart with {numPoints} {#eq numPoints 1}point{else}points{/eq}.",
              scatterMultiple: "Scatter chart with {numSeries} data series.",
              boxplotSingle:
                "Boxplot with {numPoints} {#eq numPoints 1}box{else}boxes{/eq}.",
              boxplotMultiple: "Boxplot with {numSeries} data series.",
              bubbleSingle:
                "Bubble chart with {numPoints} {#eq numPoints 1}bubbles{else}bubble{/eq}.",
              bubbleMultiple: "Bubble chart with {numSeries} data series.",
            },
            axis: {
              xAxisDescriptionSingular:
                "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
              xAxisDescriptionPlural:
                "The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
              yAxisDescriptionSingular:
                "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
              yAxisDescriptionPlural:
                "The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
              timeRangeDays: "Data range: {range} days.",
              timeRangeHours: "Data range: {range} hours.",
              timeRangeMinutes: "Data range: {range} minutes.",
              timeRangeSeconds: "Data range: {range} seconds.",
              rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.",
              rangeCategories: "Data range: {numCategories} categories.",
            },
            exporting: {
              chartMenuLabel: "Chart menu",
              menuButtonLabel: "View chart menu, {chartTitle}",
            },
            series: {
              summary: {
                default:
                  "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                defaultCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                lineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                spline:
                  "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                splineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                column:
                  "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                columnCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                barCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
                pieCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
                scatter:
                  "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
                scatterCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
                boxplot:
                  "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
                boxplotCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
                bubble:
                  "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                bubbleCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
                mapCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
                mapline:
                  "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                maplineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                mapbubble:
                  "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                mapbubbleCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
              },
              description: "{description}",
              xAxisDescription: "X axis, {name}",
              yAxisDescription: "Y axis, {name}",
              nullPointValue: "No value",
              pointAnnotationsDescription:
                "{#each annotations}Annotation: {this}{/each}",
            },
          },
        };
      }),
      n(
        e,
        "Accessibility/Options/DeprecatedOptions.js",
        [e["Core/Utilities.js"]],
        function (i) {
          function a(L, E, z) {
            let S,
              x = 0;
            for (; x < E.length - 1; ++x) (S = E[x]), (L = L[S] = Y(L[S], {}));
            L[E[E.length - 1]] = z;
          }
          function d(L, E, z, S) {
            function x(s, l) {
              return l.reduce(function (p, g) {
                return p[g];
              }, s);
            }
            const P = x(L.options, E),
              h = x(L.options, z);
            Object.keys(S).forEach(function (s) {
              const l = P[s];
              typeof l < "u" &&
                (a(h, S[s], l),
                G(32, !1, L, {
                  [E.join(".") + "." + s]: z.join(".") + "." + S[s].join("."),
                }));
            });
          }
          function M(L) {
            const E = L.options.chart,
              z = L.options.accessibility || {};
            ["description", "typeDescription"].forEach(function (S) {
              E[S] &&
                ((z[S] = E[S]),
                G(32, !1, L, { [`chart.${S}`]: `use accessibility.${S}` }));
            });
          }
          function O(L) {
            L.axes.forEach(function (E) {
              (E = E.options) &&
                E.description &&
                ((E.accessibility = E.accessibility || {}),
                (E.accessibility.description = E.description),
                G(32, !1, L, {
                  "axis.description": "use axis.accessibility.description",
                }));
            });
          }
          function B(L) {
            const E = {
              description: ["accessibility", "description"],
              exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
              pointDescriptionFormatter: [
                "accessibility",
                "point",
                "descriptionFormatter",
              ],
              skipKeyboardNavigation: [
                "accessibility",
                "keyboardNavigation",
                "enabled",
              ],
              "accessibility.pointDescriptionFormatter": [
                "accessibility",
                "point",
                "descriptionFormatter",
              ],
            };
            L.series.forEach(function (z) {
              Object.keys(E).forEach(function (S) {
                let x = z.options[S];
                S === "accessibility.pointDescriptionFormatter" &&
                  (x =
                    z.options.accessibility &&
                    z.options.accessibility.pointDescriptionFormatter),
                  typeof x < "u" &&
                    (a(
                      z.options,
                      E[S],
                      S === "skipKeyboardNavigation" ? !x : x
                    ),
                    G(32, !1, L, {
                      [`series.${S}`]: "series." + E[S].join("."),
                    }));
              });
            });
          }
          const { error: G, pick: Y } = i;
          return function (L) {
            M(L),
              O(L),
              L.series && B(L),
              d(L, ["accessibility"], ["accessibility"], {
                pointDateFormat: ["point", "dateFormat"],
                pointDateFormatter: ["point", "dateFormatter"],
                pointDescriptionFormatter: ["point", "descriptionFormatter"],
                pointDescriptionThreshold: [
                  "series",
                  "pointDescriptionEnabledThreshold",
                ],
                pointNavigationThreshold: [
                  "keyboardNavigation",
                  "seriesNavigation",
                  "pointNavigationEnabledThreshold",
                ],
                pointValueDecimals: ["point", "valueDecimals"],
                pointValuePrefix: ["point", "valuePrefix"],
                pointValueSuffix: ["point", "valueSuffix"],
                screenReaderSectionFormatter: [
                  "screenReaderSection",
                  "beforeChartFormatter",
                ],
                describeSingleSeries: ["series", "describeSingleSeries"],
                seriesDescriptionFormatter: ["series", "descriptionFormatter"],
                onTableAnchorClick: [
                  "screenReaderSection",
                  "onViewDataTableClick",
                ],
                axisRangeDateFormat: [
                  "screenReaderSection",
                  "axisRangeDateFormat",
                ],
              }),
              d(
                L,
                ["accessibility", "keyboardNavigation"],
                ["accessibility", "keyboardNavigation", "seriesNavigation"],
                { skipNullPoints: ["skipNullPoints"], mode: ["mode"] }
              ),
              d(L, ["lang", "accessibility"], ["lang", "accessibility"], {
                legendItem: ["legend", "legendItem"],
                legendLabel: ["legend", "legendLabel"],
                mapZoomIn: ["zoom", "mapZoomIn"],
                mapZoomOut: ["zoom", "mapZoomOut"],
                resetZoomButton: ["zoom", "resetZoomButton"],
                screenReaderRegionLabel: [
                  "screenReaderSection",
                  "beforeRegionLabel",
                ],
                rangeSelectorButton: ["rangeSelector", "buttonText"],
                rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
                rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
                svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
                viewAsDataTable: ["table", "viewAsDataTableButtonText"],
                tableSummary: ["table", "tableSummary"],
              });
          };
        }
      ),
      n(
        e,
        "Accessibility/Accessibility.js",
        [
          e["Core/Defaults.js"],
          e["Core/Globals.js"],
          e["Core/Utilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Accessibility/A11yI18n.js"],
          e["Accessibility/Components/ContainerComponent.js"],
          e["Accessibility/FocusBorder.js"],
          e["Accessibility/Components/InfoRegionsComponent.js"],
          e["Accessibility/KeyboardNavigation.js"],
          e["Accessibility/Components/LegendComponent.js"],
          e["Accessibility/Components/MenuComponent.js"],
          e["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
          e["Accessibility/ProxyProvider.js"],
          e["Accessibility/Components/RangeSelectorComponent.js"],
          e["Accessibility/Components/SeriesComponent/SeriesComponent.js"],
          e["Accessibility/Components/ZoomComponent.js"],
          e["Accessibility/HighContrastMode.js"],
          e["Accessibility/HighContrastTheme.js"],
          e["Accessibility/Options/A11yDefaults.js"],
          e["Accessibility/Options/LangDefaults.js"],
          e["Accessibility/Options/DeprecatedOptions.js"],
        ],
        function (
          i,
          a,
          d,
          M,
          O,
          B,
          G,
          Y,
          L,
          E,
          z,
          S,
          x,
          P,
          h,
          s,
          l,
          p,
          g,
          T,
          D
        ) {
          ({ defaultOptions: i } = i);
          const { doc: A } = a,
            { addEvent: m, extend: f, fireEvent: b, merge: y } = d,
            { removeElement: C } = M;
          class o {
            constructor(c) {
              (this.proxyProvider =
                this.keyboardNavigation =
                this.components =
                this.chart =
                  void 0),
                this.init(c);
            }
            init(c) {
              (this.chart = c),
                A.addEventListener
                  ? (D(c),
                    (this.proxyProvider = new x(this.chart)),
                    this.initComponents(),
                    (this.keyboardNavigation = new L(c, this.components)))
                  : ((this.zombie = !0),
                    (this.components = {}),
                    c.renderTo.setAttribute("aria-hidden", !0));
            }
            initComponents() {
              const c = this.chart,
                u = this.proxyProvider,
                v = c.options.accessibility;
              (this.components = {
                container: new B(),
                infoRegions: new Y(),
                legend: new E(),
                chartMenu: new z(),
                rangeSelector: new P(),
                series: new h(),
                zoom: new s(),
              }),
                v.customComponents && f(this.components, v.customComponents);
              const N = this.components;
              this.getComponentOrder().forEach(function (w) {
                N[w].initBase(c, u), N[w].init();
              });
            }
            getComponentOrder() {
              if (!this.components) return [];
              if (!this.components.series) return Object.keys(this.components);
              const c = Object.keys(this.components).filter(
                (u) => u !== "series"
              );
              return ["series"].concat(c);
            }
            update() {
              const c = this.components,
                u = this.chart;
              var v = u.options.accessibility;
              b(u, "beforeA11yUpdate"),
                (u.types = this.getChartTypes()),
                (v = v.keyboardNavigation.order),
                this.proxyProvider.updateGroupOrder(v),
                this.getComponentOrder().forEach(function (N) {
                  c[N].onChartUpdate(),
                    b(u, "afterA11yComponentUpdate", {
                      name: N,
                      component: c[N],
                    });
                }),
                this.keyboardNavigation.update(v),
                !u.highContrastModeActive &&
                  l.isHighContrastModeActive() &&
                  l.setHighContrastTheme(u),
                b(u, "afterA11yUpdate", { accessibility: this });
            }
            destroy() {
              const c = this.chart || {},
                u = this.components;
              Object.keys(u).forEach(function (v) {
                u[v].destroy(), u[v].destroyBase();
              }),
                this.proxyProvider && this.proxyProvider.destroy(),
                c.announcerContainer && C(c.announcerContainer),
                this.keyboardNavigation && this.keyboardNavigation.destroy(),
                c.renderTo && c.renderTo.setAttribute("aria-hidden", !0),
                c.focusElement && c.focusElement.removeFocusBorder();
            }
            getChartTypes() {
              const c = {};
              return (
                this.chart.series.forEach(function (u) {
                  c[u.type] = 1;
                }),
                Object.keys(c)
              );
            }
          }
          return (
            (function (r) {
              function c() {
                this.accessibility && this.accessibility.destroy();
              }
              function u() {
                this.a11yDirty &&
                  this.renderTo &&
                  (delete this.a11yDirty, this.updateA11yEnabled());
                const X = this.accessibility;
                X &&
                  !X.zombie &&
                  (X.proxyProvider.updateProxyElementPositions(),
                  X.getComponentOrder().forEach(function (J) {
                    X.components[J].onChartRender();
                  }));
              }
              function v(X) {
                (X = X.options.accessibility) &&
                  (X.customComponents &&
                    ((this.options.accessibility.customComponents =
                      X.customComponents),
                    delete X.customComponents),
                  y(!0, this.options.accessibility, X),
                  this.accessibility &&
                    this.accessibility.destroy &&
                    (this.accessibility.destroy(), delete this.accessibility)),
                  (this.a11yDirty = !0);
              }
              function N() {
                let X = this.accessibility;
                const J = this.options.accessibility;
                J && J.enabled
                  ? X && !X.zombie
                    ? X.update()
                    : ((this.accessibility = X = new r(this)),
                      !X.zombie && X.update())
                  : X
                  ? (X.destroy && X.destroy(), delete this.accessibility)
                  : this.renderTo.setAttribute("aria-hidden", !0);
              }
              function w() {
                this.series.chart.accessibility &&
                  (this.series.chart.a11yDirty = !0);
              }
              const R = [];
              (r.i18nFormat = O.i18nFormat),
                (r.compose = function (X, J, K, H, k, U) {
                  L.compose(X),
                    S.compose(H),
                    E.compose(X, J),
                    z.compose(X),
                    h.compose(X, K, H),
                    O.compose(X),
                    G.compose(X, k),
                    U && P.compose(X, U),
                    d.pushUnique(R, X) &&
                      ((X.prototype.updateA11yEnabled = N),
                      m(X, "destroy", c),
                      m(X, "render", u),
                      m(X, "update", v),
                      ["addSeries", "init"].forEach((_) => {
                        m(X, _, function () {
                          this.a11yDirty = !0;
                        });
                      }),
                      ["afterApplyDrilldown", "drillupall"].forEach((_) => {
                        m(X, _, function () {
                          const W = this.accessibility;
                          W && !W.zombie && W.update();
                        });
                      })),
                    d.pushUnique(R, K) && m(K, "update", w),
                    d.pushUnique(R, H) &&
                      ["update", "updatedData", "remove"].forEach((_) => {
                        m(H, _, function () {
                          this.chart.accessibility &&
                            (this.chart.a11yDirty = !0);
                        });
                      });
                });
            })(o || (o = {})),
            y(!0, i, g, { accessibility: { highContrastTheme: p }, lang: T }),
            o
          );
        }
      ),
      n(
        e,
        "masters/modules/accessibility.src.js",
        [
          e["Core/Globals.js"],
          e["Accessibility/Accessibility.js"],
          e["Accessibility/AccessibilityComponent.js"],
          e["Accessibility/Utils/ChartUtilities.js"],
          e["Accessibility/Utils/HTMLUtilities.js"],
          e["Accessibility/KeyboardNavigationHandler.js"],
          e["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
        ],
        function (i, a, d, M, O, B, G) {
          (i.i18nFormat = a.i18nFormat),
            (i.A11yChartUtilities = M),
            (i.A11yHTMLUtilities = O),
            (i.AccessibilityComponent = d),
            (i.KeyboardNavigationHandler = B),
            (i.SeriesAccessibilityDescriber = G),
            a.compose(
              i.Chart,
              i.Legend,
              i.Point,
              i.Series,
              i.SVGElement,
              i.RangeSelector
            );
        }
      );
  });
})(od);
var Xp = od.exports;
const Wp = Ci(Xp);
Wp(_n);
Ip(_n);
Rp(_n);
Up(_n);
const Er = new Map(),
  Lr = new Map();
for (const t of Object.values(pt)) {
  const e = t.experience;
  if (!e) continue;
  let n = Er.get(t);
  n || (n = { count: 0, months: 0 }),
    (n.count = t.projects),
    (n.months = e),
    Er.set(t, n);
  let i = Lr.get(t.type);
  i || (i = { count: 0, months: 0, tools: 0 }),
    (i.count += t.projects),
    (i.months += e),
    (i.tools += 1),
    Lr.set(t.type, i);
}
const rd = (t) => {
    const e = Math.floor(t / 12),
      n = t % 12,
      i = e ? `${e} year${e > 1 ? "s" : ""}` : "",
      a = n ? `${n} month${n > 1 ? "s" : ""}` : "";
    return `Experience: ${i}${i && a ? " and " : ""}${a}`;
  },
  Yp = Array.from(Er.entries())
    .map(([t, e]) => ({
      name: t.name,
      type: t.type,
      y: e.months,
      xp: rd(e.months),
      z: e.count,
      count: `Projects: ${e.count}`,
      color: t.type.color,
    }))
    .sort((t, e) => t.type.sort - e.type.sort || t.name.localeCompare(e.name)),
  _p = Array.from(Lr.entries())
    .map(([t, e]) => ({
      name: t.name,
      y: e.months,
      xp: rd(t.experience),
      z: t.projects,
      count: `Projects: ${t.projects}`,
      color: t.color,
      sort: t.sort,
    }))
    .sort((t, e) => t.sort - e.sort);
function Vp() {
  return `<span style="color:${this.point.color}">${this.point.name}</span>`;
}
const qp = {
  chart: {
    backgroundColor: "transparent",
    style: { fontFamily: "Saira, sans-serif" },
  },
  title: { text: "" },
  accessibility: {
    point: {
      valueDescriptionFormat:
        "{index}. From {point.from} to {point.to}: {point.weight} matches.",
    },
  },
  responsive: {
    rules: [
      {
        condition: { maxWidth: 980 },
        chartOptions: {
          plotOptions: { variablepie: { dataLabels: { enabled: !1 } } },
        },
      },
    ],
  },
  tooltip: {
    format:
      "{point.type.name} <b>{point.name}</b><br />{point.count}<br />{point.xp}",
  },
  series: [
    {
      type: "variablepie",
      name: "tools",
      borderRadius: 5,
      borderColor: "transparent",
      center: ["50%", "50%"],
      innerSize: "70%",
      dataLabels: {
        alignTo: "plotEdges",
        formatter: Vp,
        style: { textOutline: "none", fontWeight: "regular" },
        isHtml: !0,
        distance: 30,
      },
      plotOptions: {
        tooltip: { format: "{point.name}: <b>{point.z}</b> projects" },
      },
      data: Yp,
    },
    {
      type: "variablepie",
      name: "roles",
      borderRadius: 5,
      borderColor: "transparent",
      size: "60%",
      center: ["50%", "50%"],
      innerSize: "40%",
      dataLabels: {
        enabled: !1,
        alignTo: void 0,
        textPath: { enabled: !0, attributes: { dy: 10 } },
        style: { textOutline: "none", color: "black", fontWeight: "bold" },
      },
      data: _p,
    },
  ],
  credits: { enabled: !1 },
};
function Kp() {
  return dt.jsx(Fp, {
    highcharts: _n,
    options: qp,
    containerProps: {
      style: { height: "65vh", width: "100%", maxWidth: "1400px" },
    },
  });
}
const $p = "Left",
  Zp = "Right",
  Qp = "Up",
  Jp = "Down",
  Fi = {
    delta: 10,
    preventScrollOnSwipe: !1,
    rotationAngle: 0,
    trackMouse: !1,
    trackTouch: !0,
    swipeDuration: 1 / 0,
    touchEventOptions: { passive: !0 },
  },
  Dr = { first: !0, initial: [0, 0], start: 0, swiping: !1, xy: [0, 0] },
  Il = "mousemove",
  Bl = "mouseup",
  tf = "touchend",
  ef = "touchmove",
  nf = "touchstart";
function sf(t, e, n, i) {
  return t > e ? (n > 0 ? Zp : $p) : i > 0 ? Jp : Qp;
}
function Rl(t, e) {
  if (e === 0) return t;
  const n = (Math.PI / 180) * e,
    i = t[0] * Math.cos(n) + t[1] * Math.sin(n),
    a = t[1] * Math.cos(n) - t[0] * Math.sin(n);
  return [i, a];
}
function of(t, e) {
  const n = (Y) => {
      const L = "touches" in Y;
      (L && Y.touches.length > 1) ||
        t((E, z) => {
          z.trackMouse &&
            !L &&
            (document.addEventListener(Il, i),
            document.addEventListener(Bl, M));
          const { clientX: S, clientY: x } = L ? Y.touches[0] : Y,
            P = Rl([S, x], z.rotationAngle);
          return (
            z.onTouchStartOrOnMouseDown &&
              z.onTouchStartOrOnMouseDown({ event: Y }),
            Object.assign(Object.assign(Object.assign({}, E), Dr), {
              initial: P.slice(),
              xy: P,
              start: Y.timeStamp || 0,
            })
          );
        });
    },
    i = (Y) => {
      t((L, E) => {
        const z = "touches" in Y;
        if (z && Y.touches.length > 1) return L;
        if (Y.timeStamp - L.start > E.swipeDuration)
          return L.swiping
            ? Object.assign(Object.assign({}, L), { swiping: !1 })
            : L;
        const { clientX: S, clientY: x } = z ? Y.touches[0] : Y,
          [P, h] = Rl([S, x], E.rotationAngle),
          s = P - L.xy[0],
          l = h - L.xy[1],
          p = Math.abs(s),
          g = Math.abs(l),
          T = (Y.timeStamp || 0) - L.start,
          D = Math.sqrt(p * p + g * g) / (T || 1),
          A = [s / (T || 1), l / (T || 1)],
          m = sf(p, g, s, l),
          f =
            typeof E.delta == "number"
              ? E.delta
              : E.delta[m.toLowerCase()] || Fi.delta;
        if (p < f && g < f && !L.swiping) return L;
        const b = {
          absX: p,
          absY: g,
          deltaX: s,
          deltaY: l,
          dir: m,
          event: Y,
          first: L.first,
          initial: L.initial,
          velocity: D,
          vxvy: A,
        };
        b.first && E.onSwipeStart && E.onSwipeStart(b),
          E.onSwiping && E.onSwiping(b);
        let y = !1;
        return (
          (E.onSwiping || E.onSwiped || E[`onSwiped${m}`]) && (y = !0),
          y &&
            E.preventScrollOnSwipe &&
            E.trackTouch &&
            Y.cancelable &&
            Y.preventDefault(),
          Object.assign(Object.assign({}, L), {
            first: !1,
            eventData: b,
            swiping: !0,
          })
        );
      });
    },
    a = (Y) => {
      t((L, E) => {
        let z;
        if (L.swiping && L.eventData) {
          if (Y.timeStamp - L.start < E.swipeDuration) {
            (z = Object.assign(Object.assign({}, L.eventData), { event: Y })),
              E.onSwiped && E.onSwiped(z);
            const S = E[`onSwiped${z.dir}`];
            S && S(z);
          }
        } else E.onTap && E.onTap({ event: Y });
        return (
          E.onTouchEndOrOnMouseUp && E.onTouchEndOrOnMouseUp({ event: Y }),
          Object.assign(Object.assign(Object.assign({}, L), Dr), {
            eventData: z,
          })
        );
      });
    },
    d = () => {
      document.removeEventListener(Il, i), document.removeEventListener(Bl, M);
    },
    M = (Y) => {
      d(), a(Y);
    },
    O = (Y, L) => {
      let E = () => {};
      if (Y && Y.addEventListener) {
        const z = Object.assign(
            Object.assign({}, Fi.touchEventOptions),
            L.touchEventOptions
          ),
          S = [
            [nf, n, z],
            [
              ef,
              i,
              Object.assign(
                Object.assign({}, z),
                L.preventScrollOnSwipe ? { passive: !1 } : {}
              ),
            ],
            [tf, a, z],
          ];
        S.forEach(([x, P, h]) => Y.addEventListener(x, P, h)),
          (E = () => S.forEach(([x, P]) => Y.removeEventListener(x, P)));
      }
      return E;
    },
    G = {
      ref: (Y) => {
        Y !== null &&
          t((L, E) => {
            if (L.el === Y) return L;
            const z = {};
            return (
              L.el &&
                L.el !== Y &&
                L.cleanUpTouch &&
                (L.cleanUpTouch(), (z.cleanUpTouch = void 0)),
              E.trackTouch && Y && (z.cleanUpTouch = O(Y, E)),
              Object.assign(Object.assign(Object.assign({}, L), { el: Y }), z)
            );
          });
      },
    };
  return e.trackMouse && (G.onMouseDown = n), [G, O];
}
function rf(t, e, n, i) {
  return !e.trackTouch || !t.el
    ? (t.cleanUpTouch && t.cleanUpTouch(),
      Object.assign(Object.assign({}, t), { cleanUpTouch: void 0 }))
    : t.cleanUpTouch
    ? e.preventScrollOnSwipe !== n.preventScrollOnSwipe ||
      e.touchEventOptions.passive !== n.touchEventOptions.passive
      ? (t.cleanUpTouch(),
        Object.assign(Object.assign({}, t), { cleanUpTouch: i(t.el, e) }))
      : t
    : Object.assign(Object.assign({}, t), { cleanUpTouch: i(t.el, e) });
}
function af(t) {
  const { trackMouse: e } = t,
    n = Ft.useRef(Object.assign({}, Dr)),
    i = Ft.useRef(Object.assign({}, Fi)),
    a = Ft.useRef(Object.assign({}, i.current));
  (a.current = Object.assign({}, i.current)),
    (i.current = Object.assign(Object.assign({}, Fi), t));
  let d;
  for (d in Fi) i.current[d] === void 0 && (i.current[d] = Fi[d]);
  const [M, O] = Ft.useMemo(
    () => of((B) => (n.current = B(n.current, i.current)), { trackMouse: e }),
    [e]
  );
  return (n.current = rf(n.current, i.current, a.current, O)), M;
}
const cs = Gp.filter((t) => !t.hideInList);
function lf() {
  var h, s, l, p, g, T, D;
  const t = Ft.useRef(null),
    [e, n] = Ft.useState(null),
    [i, a] = Ft.useState(0),
    d = af({ onSwipedLeft: () => O(i + 1), onSwipedRight: () => O(i - 1) }),
    M = () => {
      var A;
      (document.body.style.overflow = "auto"),
        n(null),
        a(0),
        (A = t.current) == null || A.close();
    },
    O = (A) => {
      var m, f;
      (document.body.style.overflow = "hidden"),
        A < 0 && (A = cs.length - 1),
        A >= cs.length && (A = 0),
        a(A),
        L(0),
        n(cs[A]),
        x(!1),
        ((m = t.current) != null && m.open) ||
          (f = t.current) == null ||
          f.showModal();
    },
    B = (A) => {
      var m;
      (m = e == null ? void 0 : e.images) != null &&
        m.length &&
        (A < 0 && (A = e.images.length - 1),
        A >= (e == null ? void 0 : e.images.length) && (A = 0),
        L(A),
        x(!0));
    },
    G = (A) => (A ? "hidden" : ""),
    [Y, L] = Ft.useState(0),
    [E, z] = Ft.useState(!1),
    [S, x] = Ft.useState(!1);
  Ft.useEffect(() => {
    const A = setTimeout(() => {
      if (S || !e) return;
      const m = e.images.length - 1;
      if (m <= 1) return;
      let f = Y + 1;
      f > m && (f = 0), L(f);
    }, 5e3);
    return () => clearTimeout(A);
  });
  const P = () => {
    const A = !E;
    z(A), x(A);
  };
  return dt.jsxs(dt.Fragment, {
    children: [
      dt.jsxs("dialog", {
        ref: t,
        className:
          "overflow-y-auto clear-both project-dialog p-5 backdrop:bg-neutral-950 backdrop:opacity-95 rounded-2xl",
        children: [
          dt.jsxs("div", {
            ...d,
            className: "mb-10 flex justify-between items-center",
            children: [
              dt.jsx("img", {
                src: "/iamdustin/icons/favicon-32x32.png",
                alt: "logo",
              }),
              dt.jsxs("div", {
                className: "flex gap-2 items-center",
                children: [
                  dt.jsx("a", {
                    className:
                      "cursor-pointer px-2 py-1 hover:text-amber-500 material-symbols-outlined text-3xl",
                    onClick: () => O(i - 1),
                    children: "chevron_left",
                  }),
                  dt.jsx("h2", {
                    className: "md:w-80 text-center text-2xl font-bold",
                    children: e == null ? void 0 : e.name,
                  }),
                  dt.jsx("a", {
                    className:
                      "cursor-pointer px-2 py-1 hover:text-amber-500 material-symbols-outlined text-3xl",
                    onClick: () => O(i + 1),
                    children: "chevron_right",
                  }),
                ],
              }),
              dt.jsx("a", {
                className:
                  "cursor-pointer px-2 py-1 hover:text-amber-500 material-symbols-outlined text-3xl",
                onClick: () => M(),
                children: "close",
              }),
            ],
          }),
          dt.jsxs("div", {
            className: `${E ? "" : "gap-5 md:flex"}`,
            children: [
              dt.jsxs("div", {
                className:
                  "project-gallery relative flex items-center pb-12 aspect-square  ",
                style: { maxHeight: "75vh" },
                children: [
                  dt.jsxs("div", {
                    className:
                      "w-full absolute bottom-0 flex justify-between items-center bg-neutral-950/50 text-amber-500",
                    children: [
                      dt.jsx("a", {
                        className:
                          "cursor-pointer px-2 py-1 hover:text-white material-symbols-outlined text-3xl",
                        onClick: () => B(Y - 1),
                        children: "chevron_left",
                      }),
                      dt.jsx("div", {
                        className: "text-md",
                        children:
                          (h = e == null ? void 0 : e.images[Y]) == null
                            ? void 0
                            : h.title,
                      }),
                      dt.jsx("a", {
                        className:
                          "cursor-pointer px-2 py-1 hover:text-white material-symbols-outlined text-3xl",
                        onClick: () => B(Y + 1),
                        children: "chevron_right",
                      }),
                    ],
                  }),
                  dt.jsx("img", {
                    className: `${
                      E ? "md:cursor-zoom-out" : "md:cursor-zoom-in"
                    }`,
                    src:
                      (s = e == null ? void 0 : e.images[Y]) == null
                        ? void 0
                        : s.src,
                    alt:
                      (l = e == null ? void 0 : e.images[Y]) == null
                        ? void 0
                        : l.title,
                    onClick: () => P(),
                  }),
                ],
              }),
              dt.jsx("div", {
                className: "w-full flex content-center py-5",
                children: dt.jsxs("ul", {
                  className: "my-auto project-details",
                  children: [
                    dt.jsxs("li", {
                      className: `flex gap-1 ${G(!(e != null && e.url))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Link:",
                        }),
                        dt.jsx("a", {
                          className: "basis-full underline",
                          href: e == null ? void 0 : e.url,
                          target: "_blank",
                          children: e == null ? void 0 : e.url,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-1 ${G(!(e != null && e.github))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Github:",
                        }),
                        dt.jsx("a", {
                          className: "basis-full underline",
                          href: e == null ? void 0 : e.github,
                          target: "_blank",
                          children: e == null ? void 0 : e.github,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-1 ${G(
                        !(e != null && e.presentation)
                      )}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Presentation:",
                        }),
                        dt.jsx("a", {
                          className: "basis-full underline",
                          href: e == null ? void 0 : e.presentation,
                          target: "_blank",
                          children: e == null ? void 0 : e.presentation,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-1 ${G(!(e != null && e.demo))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Demo:",
                        }),
                        dt.jsx("a", {
                          className: "basis-full underline",
                          href: e == null ? void 0 : e.demo,
                          target: "_blank",
                          children: e == null ? void 0 : e.demo,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-2 ${G(!(e != null && e.type))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Type:",
                        }),
                        dt.jsx("div", {
                          className: "basis-full",
                          children: e == null ? void 0 : e.type,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-2 ${G(!(e != null && e.company))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Company:",
                        }),
                        dt.jsx("div", {
                          className: "basis-full",
                          children: e == null ? void 0 : e.company,
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-2 ${G(!(e != null && e.start))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Duration:",
                        }),
                        dt.jsxs("div", {
                          className: "basis-full",
                          children: [
                            (p = e == null ? void 0 : e.start) == null
                              ? void 0
                              : p.toLocaleString("en-us", {
                                  month: "short",
                                  year: "numeric",
                                }),
                            " - ",
                            (g = e == null ? void 0 : e.end) == null
                              ? void 0
                              : g.toLocaleString("en-us", {
                                  month: "short",
                                  year: "numeric",
                                }),
                          ],
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-2 ${G(
                        !(
                          (T = e == null ? void 0 : e.roles) != null && T.length
                        )
                      )}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "My Role:",
                        }),
                        dt.jsx("div", {
                          className: "basis-full",
                          children: e == null ? void 0 : e.roles.join(" / "),
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-2 ${G(
                        !(
                          (D = e == null ? void 0 : e.tools) != null && D.length
                        )
                      )}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Tech Stack:",
                        }),
                        dt.jsx("div", {
                          className: "basis-full",
                          children:
                            e == null
                              ? void 0
                              : e.tools.map((A) =>
                                  dt.jsx(
                                    "span",
                                    {
                                      className: "comma",
                                      style: { color: A.type.color },
                                      children: A.name,
                                    },
                                    A.name
                                  )
                                ),
                        }),
                      ],
                    }),
                    dt.jsxs("li", {
                      className: `flex gap-1 ${G(!(e != null && e.url))}`,
                      children: [
                        dt.jsx("div", {
                          className: "basis-28 font-bold text-right",
                          children: "Description:",
                        }),
                        dt.jsx("div", {
                          className: "basis-full",
                          children: e == null ? void 0 : e.description,
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          }),
        ],
      }),
      dt.jsx("ul", {
        className: "flex flex-wrap justify-evenly",
        children: cs.map((A, m) =>
          dt.jsx(
            "li",
            {
              onClick: () => O(m),
              children: dt.jsxs("a", {
                className:
                  "project-link block mb-5 cursor-pointer w-80 text-center hover:text-gray-400",
                children: [
                  dt.jsx("div", {
                    className: `w-80 h-80 flex justify-center rounded-full
                 overflow-hidden project-preview border-amber-500 border`,
                    style: {
                      backgroundImage: `url("${A.preview}")`,
                      backgroundSize: "cover",
                      backgroundPosition: "center center",
                    },
                  }),
                  dt.jsx("div", { className: "pt-5", children: A.name }),
                  dt.jsxs("div", {
                    className: "font-thin text-sm",
                    children: [
                      A.tools.slice(0, 5).map((f) =>
                        dt.jsx(
                          "span",
                          {
                            className: "inline-block p-1",
                            style: { color: f.type.color },
                            children: f.name,
                          },
                          f.name
                        )
                      ),
                      " ",
                      "...",
                    ],
                  }),
                ],
              }),
            },
            A.name
          )
        ),
      }),
    ],
  });
}
const hf = 500,
  zl =
    "https://tns4lpgmziiypnxxzel5ss5nyu0nftol.lambda-url.us-east-1.on.aws/challenge",
  Fl = 'code[data-class^="23"] div[data-tag$="93"] span[data-id*="21"] i.char',
  cf = async () => {
    console.info(
      "Ramp Solution: ",
      `import { useEffect, useRef, useState } from "react"

const delay = 500
const challengeLink = "https://tns4lpgmziiypnxxzel5ss5nyu0nftol.lambda-url.us-east-1.on.aws/challenge"
const querySelector = \`code[data-class^="23"] div[data-tag$="93"] span[data-id*="21"] i.char\`

const solveRampChallenge = async () => {
  const request = await fetch(challengeLink)
  const text = await request.text()
  if (!text) return console.error("Failed to fetch challenge html", challengeLink)
  const parser = new DOMParser()
  const body = parser.parseFromString(text, "text/html").body
  const secretUrl = Array.from(body.querySelectorAll(querySelector))
    .map((x) => x.getAttribute("value"))
    .join("")
  if (!secretUrl) return console.error("Failed to parse secret url", querySelector)
  const response = await fetch(secretUrl)
  const flag = await response.text()
  if (!flag) return console.error("Failed to fetch secret flag", secretUrl)
  return flag
}

const RampChallenge = () => {
  const isSolving = useRef(false)
  const [text, setText] = useState("Loading")
  const [flag, setFlag] = useState("")

  useEffect(() => {
    let charIndex = -1
    const updateFlag = () => {
      charIndex++
      if (charIndex >= flag.length) clearInterval(loading)
      setText(" " + flag.substring(0, charIndex))
    }

    let dots = ""
    const updateLoading = () => {
      dots += "."
      if (dots.length > 3) dots = ""
      setText(\`Loading \${dots}\`)
    }

    setTimeout(async () => {
      if (isSolving.current) return
      isSolving.current = true
      const flag = await solveRampChallenge()
      setFlag(flag ?? "Solving failed")
    }, 2000)

    const loading = setInterval(() => (flag.length ? updateFlag() : updateLoading()), delay)
    return () => clearInterval(loading)
  }, [flag])

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        width: "100%",
        placeItems: "center",
        justifyContent: "center",
        rowGap: "2rem",
      }}
    >
      <h1>{text}</h1>
    </div>
  )
}

export default RampChallenge`
    );
    const e = await (await fetch(zl)).text();
    if (!e) return console.error("Failed to fetch challenge html", zl);
    const i = new DOMParser().parseFromString(e, "text/html").body,
      a = Array.from(i.querySelectorAll(Fl))
        .map((O) => O.getAttribute("value"))
        .join("");
    if (!a) return console.error("Failed to parse secret url", Fl);
    const M = await (await fetch(a)).text();
    return M || console.error("Failed to fetch secret flag", a);
  },
  df = () => {
    const t = Ft.useRef(!1),
      [e, n] = Ft.useState("Loading"),
      [i, a] = Ft.useState("");
    return (
      Ft.useEffect(() => {
        let d = -1;
        const M = () => {
          d++, d >= i.length && clearInterval(G), n(" " + i.substring(0, d));
        };
        let O = "";
        const B = () => {
          (O += "."), O.length > 3 && (O = ""), n(`Loading ${O}`);
        };
        setTimeout(async () => {
          if (t.current) return;
          t.current = !0;
          const Y = await cf();
          a(Y ?? "Solving failed");
        }, 2e3);
        const G = setInterval(() => (i.length ? M() : B()), hf);
        return () => clearInterval(G);
      }, [i]),
      dt.jsx("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100vh",
          width: "100%",
          placeItems: "center",
          justifyContent: "center",
          rowGap: "2rem",
        },
        children: dt.jsx("h1", { children: e }),
      })
    );
  };
function uf() {
  const t = window.location.pathname,
    [e, n] = Ft.useState(!1),
    i = () => {
      n(!0);
    };
  return t.startsWith("/ramp-challenge")
    ? dt.jsx(df, {})
    : dt.jsxs(dt.Fragment, {
        children: [
          dt.jsxs("div", {
            className:
              "flex justify-between sticky top-0 py-2 bg-neutral-950/90 z-10",
            children: [
              dt.jsx("a", {
                href: "#",
                children: dt.jsx("img", {
                  src: "/iamdustin/icons/favicon-96x96.png",
                  className: "logo",
                  alt: "Personal logo",
                }),
              }),
              dt.jsxs("div", {
                className: "flex gap-2 text-neutral-950",
                children: [
                  dt.jsxs("a", {
                    href: "#projects",
                    className:
                      "w-20 p-2 rounded-2xl bg-amber-500 hover:bg-amber-400 text-center",
                    children: [
                      dt.jsx("div", {
                        className: "material-symbols-outlined text-3xl",
                        children: "vrpano",
                      }),
                      dt.jsx("div", { children: "Projects" }),
                    ],
                  }),
                  dt.jsxs("a", {
                    href: "#stack",
                    className:
                      "w-20 p-2 rounded-2xl bg-amber-500 hover:bg-amber-400 text-center",
                    children: [
                      dt.jsx("div", {
                        className: "material-symbols-outlined text-3xl",
                        children: "donut_large",
                      }),
                      dt.jsx("div", { children: "Stack" }),
                    ],
                  }),
                  dt.jsxs("a", {
                    href: "#contact",
                    className:
                      "w-20 p-2 rounded-2xl bg-amber-500 hover:bg-amber-400 text-center",
                    children: [
                      dt.jsx("div", {
                        className: "material-symbols-outlined text-3xl",
                        children: "alternate_email",
                      }),
                      dt.jsx("div", { children: "Contact" }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          dt.jsxs("div", {
            className: "mt-5 text-center",
            children: [
              dt.jsxs("h2", {
                className: "p-5 text-2xl",
                children: [
                  "Hi, I am ",
                  dt.jsx("span", {
                    className: "font-bold",
                    children: "Dustin",
                  }),
                  "!",
                ],
              }),
              dt.jsx("div", {
                className: "flex justify-center",
                children: dt.jsx("p", {
                  className: "max-w-prose",
                  children:
                    "I am a full-stack developer with over a decade of experience in web and cloud development. I have an early-career background in graphic design, so I am passionate about creating beautiful, functional, user-friendly apps and solutions. I'm always looking for new and interesting challenges, and ways to improve personally and professionally. I live with my family in Texas, United States, and in my spare time I enjoy playing board games, watching movies, and traveling.",
                }),
              }),
            ],
          }),
          dt.jsxs("div", {
            id: "projects",
            className: "card pt-20",
            children: [
              dt.jsxs("h2", {
                className: "py-10 text-4xl text-amber-500 text-center",
                children: [
                  dt.jsx("div", {
                    className: "material-symbols-outlined text-5xl",
                    children: "vrpano",
                  }),
                  dt.jsx("div", { children: "Projects" }),
                ],
              }),
              dt.jsx(lf, {}),
            ],
          }),
          dt.jsxs("div", {
            id: "stack",
            className: "card pt-20",
            children: [
              dt.jsxs("h2", {
                className: "py-10 text-4xl text-amber-500 text-center",
                children: [
                  dt.jsx("div", {
                    className: "material-symbols-outlined text-5xl",
                    children: "donut_large",
                  }),
                  dt.jsx("div", { children: "Tech Stack" }),
                ],
              }),
              dt.jsx(Kp, {}),
            ],
          }),
          dt.jsxs("div", {
            id: "contact",
            className: "card pt-20",
            children: [
              dt.jsxs("h2", {
                className: "py-10 text-4xl text-amber-500 text-center",
                children: [
                  dt.jsx("div", {
                    className: "material-symbols-outlined text-5xl",
                    children: "alternate_email",
                  }),
                  dt.jsx("div", { children: "Contact" }),
                ],
              }),
              dt.jsxs("div", {
                className: "mb-10 md:flex md:flex-row-reverse items-end gap-10",
                children: [
                  dt.jsxs("form", {
                    className: "basis-1/2 flex-column gap-6",
                    action:
                      "https://formsubmit.co/rodneytinneydustin@gmail.com",
                    method: "POST",
                    onSubmit: i,
                    children: [
                      dt.jsx("label", {
                        className: "block mt-5 w-full",
                        htmlFor: "name",
                        children: "Your Name",
                      }),
                      dt.jsx("input", {
                        className: "block my-2 p-3 w-full rounded-md",
                        name: "name",
                        required: !0,
                      }),
                      dt.jsx("label", {
                        className: "block mt-5 w-full",
                        htmlFor: "name",
                        children: "Your Email",
                      }),
                      dt.jsx("input", {
                        className: "block my-2 p-3 w-full rounded-md",
                        type: "email",
                        name: "email",
                        required: !0,
                      }),
                      dt.jsx("label", {
                        className: "block mt-5 w-full",
                        htmlFor: "name",
                        children: "Your Message",
                      }),
                      dt.jsx("textarea", {
                        className: "block my-2 p-3 w-full rounded-md",
                        name: "message",
                        required: !0,
                      }),
                      dt.jsxs("button", {
                        className:
                          "flex items-center justify-center gap-3 w-full mt-5 p3 border-amber-500 border rounded-md text-amber-500 hover:text-white hover:border-white",
                        type: "submit",
                        disabled: e ? !0 : void 0,
                        children: [
                          dt.jsx("div", {
                            className: `material-symbols-outlined text-2xl ${
                              e ? "" : "spin"
                            }`,
                            children: e ? "" : "send",
                          }),
                          dt.jsx("span", { children: e ? "Loading" : "Send" }),
                        ],
                      }),
                    ],
                  }),
                  dt.jsxs("div", {
                    className: "basis-1/2 text-center",
                    children: [
                      dt.jsxs("div", {
                        className: "p-10",
                        children: [
                          dt.jsx("p", {
                            children: "Thanks for visiting my website.",
                          }),
                          dt.jsx("p", {
                            children:
                              "Feel free to drop me a message via the contact form. ",
                          }),
                          dt.jsx("p", {
                            children:
                              "Or at one of the website profiles below:",
                          }),
                        ],
                      }),
                      dt.jsxs("ul", {
                        className: "flex justify-center",
                        children: [
                          dt.jsx("li", {
                            className: "m-10",
                            children: dt.jsx("a", {
                              className:
                                "p-3 border-amber-500 border rounded-md text-amber-500 hover:text-white hover:border-white",
                              href: "https://github.com/Dustin10091984",
                              target: "_",
                              children: "Github",
                            }),
                          }),
                          dt.jsx("li", {
                            className: "m-10",
                            children: dt.jsx("a", {
                              className:
                                "p-3 border-amber-500 border rounded-md text-amber-500 hover:text-white hover:border-white",
                              href: "https://www.linkedin.com/in/dustin-tinney-40b3a531a/",
                              target: "_",
                              children: "Linkedin",
                            }),
                          }),
                        ],
                      }),
                      dt.jsx("p", {
                        className: "pt-10",
                        children: "Copyright  2024  www.whimsy-cat.com",
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      });
}
Bo.createRoot(document.getElementById("root")).render(
  dt.jsx(kd.StrictMode, { children: dt.jsx(uf, {}) })
);
